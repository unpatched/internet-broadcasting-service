# [ repr ( C ) ] pub struct __BindgenUnionField < T > ( :: std :: marker :: PhantomData < T > ) ; impl < T > __BindgenUnionField < T > { # [ inline ] pub fn new ( ) -> Self { __BindgenUnionField ( :: std :: marker :: PhantomData ) } # [ inline ] pub unsafe fn as_ref ( & self ) -> & T { :: std :: mem :: transmute ( self ) } # [ inline ] pub unsafe fn as_mut ( & mut self ) -> & mut T { :: std :: mem :: transmute ( self ) } } impl < T > :: std :: default :: Default for __BindgenUnionField < T > { # [ inline ] fn default ( ) -> Self { Self :: new ( ) } } impl < T > :: std :: clone :: Clone for __BindgenUnionField < T > { # [ inline ] fn clone ( & self ) -> Self { Self :: new ( ) } } impl < T > :: std :: marker :: Copy for __BindgenUnionField < T > { } impl < T > :: std :: fmt :: Debug for __BindgenUnionField < T > { fn fmt ( & self , fmt : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { fmt . write_str ( "__BindgenUnionField" ) } } pub const FF_LAMBDA_SHIFT : :: std :: os :: raw :: c_uint = 7 ; pub const FF_LAMBDA_SCALE : :: std :: os :: raw :: c_uint = 128 ; pub const FF_QP2LAMBDA : :: std :: os :: raw :: c_uint = 118 ; pub const FF_LAMBDA_MAX : :: std :: os :: raw :: c_uint = 32767 ; pub const FF_QUALITY_SCALE : :: std :: os :: raw :: c_uint = 128 ; pub const AV_TIME_BASE : :: std :: os :: raw :: c_uint = 1000000 ; pub const SEEK_SET : :: std :: os :: raw :: c_uint = 0 ; pub const SEEK_CUR : :: std :: os :: raw :: c_uint = 1 ; pub const SEEK_END : :: std :: os :: raw :: c_uint = 2 ; pub const AV_HAVE_BIGENDIAN : :: std :: os :: raw :: c_uint = 0 ; pub const AV_HAVE_FAST_UNALIGNED : :: std :: os :: raw :: c_uint = 1 ; pub const AVERROR_EXPERIMENTAL : :: std :: os :: raw :: c_int = - 733130664 ; pub const AVERROR_INPUT_CHANGED : :: std :: os :: raw :: c_int = - 1668179713 ; pub const AVERROR_OUTPUT_CHANGED : :: std :: os :: raw :: c_int = - 1668179714 ; pub const AV_ERROR_MAX_STRING_SIZE : :: std :: os :: raw :: c_uint = 64 ; pub const AV_LOG_QUIET : :: std :: os :: raw :: c_int = - 8 ; pub const AV_LOG_PANIC : :: std :: os :: raw :: c_uint = 0 ; pub const AV_LOG_FATAL : :: std :: os :: raw :: c_uint = 8 ; pub const AV_LOG_ERROR : :: std :: os :: raw :: c_uint = 16 ; pub const AV_LOG_WARNING : :: std :: os :: raw :: c_uint = 24 ; pub const AV_LOG_INFO : :: std :: os :: raw :: c_uint = 32 ; pub const AV_LOG_VERBOSE : :: std :: os :: raw :: c_uint = 40 ; pub const AV_LOG_DEBUG : :: std :: os :: raw :: c_uint = 48 ; pub const AV_LOG_TRACE : :: std :: os :: raw :: c_uint = 56 ; pub const AV_LOG_MAX_OFFSET : :: std :: os :: raw :: c_uint = 64 ; pub const AV_LOG_SKIP_REPEATED : :: std :: os :: raw :: c_uint = 1 ; pub const AV_LOG_PRINT_LEVEL : :: std :: os :: raw :: c_uint = 2 ; pub const AVPALETTE_SIZE : :: std :: os :: raw :: c_uint = 1024 ; pub const AVPALETTE_COUNT : :: std :: os :: raw :: c_uint = 256 ; pub const AV_FOURCC_MAX_STRING_SIZE : :: std :: os :: raw :: c_uint = 32 ; pub const AV_PIX_FMT_FLAG_BE : :: std :: os :: raw :: c_uint = 1 ; pub const AV_PIX_FMT_FLAG_PAL : :: std :: os :: raw :: c_uint = 2 ; pub const AV_PIX_FMT_FLAG_BITSTREAM : :: std :: os :: raw :: c_uint = 4 ; pub const AV_PIX_FMT_FLAG_HWACCEL : :: std :: os :: raw :: c_uint = 8 ; pub const AV_PIX_FMT_FLAG_PLANAR : :: std :: os :: raw :: c_uint = 16 ; pub const AV_PIX_FMT_FLAG_RGB : :: std :: os :: raw :: c_uint = 32 ; pub const AV_PIX_FMT_FLAG_PSEUDOPAL : :: std :: os :: raw :: c_uint = 64 ; pub const AV_PIX_FMT_FLAG_ALPHA : :: std :: os :: raw :: c_uint = 128 ; pub const AV_PIX_FMT_FLAG_BAYER : :: std :: os :: raw :: c_uint = 256 ; pub const FF_LOSS_RESOLUTION : :: std :: os :: raw :: c_uint = 1 ; pub const FF_LOSS_DEPTH : :: std :: os :: raw :: c_uint = 2 ; pub const FF_LOSS_COLORSPACE : :: std :: os :: raw :: c_uint = 4 ; pub const FF_LOSS_ALPHA : :: std :: os :: raw :: c_uint = 8 ; pub const FF_LOSS_COLORQUANT : :: std :: os :: raw :: c_uint = 16 ; pub const FF_LOSS_CHROMA : :: std :: os :: raw :: c_uint = 32 ; pub const AV_TS_MAX_STRING_SIZE : :: std :: os :: raw :: c_uint = 32 ; pub const AV_BUFFER_FLAG_READONLY : :: std :: os :: raw :: c_uint = 1 ; pub const AV_CPU_FLAG_FORCE : :: std :: os :: raw :: c_uint = 2147483648 ; pub const AV_CPU_FLAG_MMX : :: std :: os :: raw :: c_uint = 1 ; pub const AV_CPU_FLAG_MMXEXT : :: std :: os :: raw :: c_uint = 2 ; pub const AV_CPU_FLAG_MMX2 : :: std :: os :: raw :: c_uint = 2 ; pub const AV_CPU_FLAG_3DNOW : :: std :: os :: raw :: c_uint = 4 ; pub const AV_CPU_FLAG_SSE : :: std :: os :: raw :: c_uint = 8 ; pub const AV_CPU_FLAG_SSE2 : :: std :: os :: raw :: c_uint = 16 ; pub const AV_CPU_FLAG_SSE2SLOW : :: std :: os :: raw :: c_uint = 1073741824 ; pub const AV_CPU_FLAG_3DNOWEXT : :: std :: os :: raw :: c_uint = 32 ; pub const AV_CPU_FLAG_SSE3 : :: std :: os :: raw :: c_uint = 64 ; pub const AV_CPU_FLAG_SSE3SLOW : :: std :: os :: raw :: c_uint = 536870912 ; pub const AV_CPU_FLAG_SSSE3 : :: std :: os :: raw :: c_uint = 128 ; pub const AV_CPU_FLAG_SSSE3SLOW : :: std :: os :: raw :: c_uint = 67108864 ; pub const AV_CPU_FLAG_ATOM : :: std :: os :: raw :: c_uint = 268435456 ; pub const AV_CPU_FLAG_SSE4 : :: std :: os :: raw :: c_uint = 256 ; pub const AV_CPU_FLAG_SSE42 : :: std :: os :: raw :: c_uint = 512 ; pub const AV_CPU_FLAG_AESNI : :: std :: os :: raw :: c_uint = 524288 ; pub const AV_CPU_FLAG_AVX : :: std :: os :: raw :: c_uint = 16384 ; pub const AV_CPU_FLAG_AVXSLOW : :: std :: os :: raw :: c_uint = 134217728 ; pub const AV_CPU_FLAG_XOP : :: std :: os :: raw :: c_uint = 1024 ; pub const AV_CPU_FLAG_FMA4 : :: std :: os :: raw :: c_uint = 2048 ; pub const AV_CPU_FLAG_CMOV : :: std :: os :: raw :: c_uint = 4096 ; pub const AV_CPU_FLAG_AVX2 : :: std :: os :: raw :: c_uint = 32768 ; pub const AV_CPU_FLAG_FMA3 : :: std :: os :: raw :: c_uint = 65536 ; pub const AV_CPU_FLAG_BMI1 : :: std :: os :: raw :: c_uint = 131072 ; pub const AV_CPU_FLAG_BMI2 : :: std :: os :: raw :: c_uint = 262144 ; pub const AV_CPU_FLAG_ALTIVEC : :: std :: os :: raw :: c_uint = 1 ; pub const AV_CPU_FLAG_VSX : :: std :: os :: raw :: c_uint = 2 ; pub const AV_CPU_FLAG_POWER8 : :: std :: os :: raw :: c_uint = 4 ; pub const AV_CPU_FLAG_ARMV5TE : :: std :: os :: raw :: c_uint = 1 ; pub const AV_CPU_FLAG_ARMV6 : :: std :: os :: raw :: c_uint = 2 ; pub const AV_CPU_FLAG_ARMV6T2 : :: std :: os :: raw :: c_uint = 4 ; pub const AV_CPU_FLAG_VFP : :: std :: os :: raw :: c_uint = 8 ; pub const AV_CPU_FLAG_VFPV3 : :: std :: os :: raw :: c_uint = 16 ; pub const AV_CPU_FLAG_NEON : :: std :: os :: raw :: c_uint = 32 ; pub const AV_CPU_FLAG_ARMV8 : :: std :: os :: raw :: c_uint = 64 ; pub const AV_CPU_FLAG_VFP_VM : :: std :: os :: raw :: c_uint = 128 ; pub const AV_CPU_FLAG_SETEND : :: std :: os :: raw :: c_uint = 65536 ; pub const AV_CH_FRONT_LEFT : :: std :: os :: raw :: c_uint = 1 ; pub const AV_CH_FRONT_RIGHT : :: std :: os :: raw :: c_uint = 2 ; pub const AV_CH_FRONT_CENTER : :: std :: os :: raw :: c_uint = 4 ; pub const AV_CH_LOW_FREQUENCY : :: std :: os :: raw :: c_uint = 8 ; pub const AV_CH_BACK_LEFT : :: std :: os :: raw :: c_uint = 16 ; pub const AV_CH_BACK_RIGHT : :: std :: os :: raw :: c_uint = 32 ; pub const AV_CH_FRONT_LEFT_OF_CENTER : :: std :: os :: raw :: c_uint = 64 ; pub const AV_CH_FRONT_RIGHT_OF_CENTER : :: std :: os :: raw :: c_uint = 128 ; pub const AV_CH_BACK_CENTER : :: std :: os :: raw :: c_uint = 256 ; pub const AV_CH_SIDE_LEFT : :: std :: os :: raw :: c_uint = 512 ; pub const AV_CH_SIDE_RIGHT : :: std :: os :: raw :: c_uint = 1024 ; pub const AV_CH_TOP_CENTER : :: std :: os :: raw :: c_uint = 2048 ; pub const AV_CH_TOP_FRONT_LEFT : :: std :: os :: raw :: c_uint = 4096 ; pub const AV_CH_TOP_FRONT_CENTER : :: std :: os :: raw :: c_uint = 8192 ; pub const AV_CH_TOP_FRONT_RIGHT : :: std :: os :: raw :: c_uint = 16384 ; pub const AV_CH_TOP_BACK_LEFT : :: std :: os :: raw :: c_uint = 32768 ; pub const AV_CH_TOP_BACK_CENTER : :: std :: os :: raw :: c_uint = 65536 ; pub const AV_CH_TOP_BACK_RIGHT : :: std :: os :: raw :: c_uint = 131072 ; pub const AV_CH_STEREO_LEFT : :: std :: os :: raw :: c_uint = 536870912 ; pub const AV_CH_STEREO_RIGHT : :: std :: os :: raw :: c_uint = 1073741824 ; pub const AV_CH_WIDE_LEFT : :: std :: os :: raw :: c_uint = 2147483648 ; pub const AV_CH_WIDE_RIGHT : :: std :: os :: raw :: c_ulonglong = 4294967296 ; pub const AV_CH_SURROUND_DIRECT_LEFT : :: std :: os :: raw :: c_ulonglong = 8589934592 ; pub const AV_CH_SURROUND_DIRECT_RIGHT : :: std :: os :: raw :: c_ulonglong = 17179869184 ; pub const AV_CH_LOW_FREQUENCY_2 : :: std :: os :: raw :: c_ulonglong = 34359738368 ; pub const AV_CH_LAYOUT_NATIVE : :: std :: os :: raw :: c_longlong = - 9223372036854775808 ; pub const AV_CH_LAYOUT_MONO : :: std :: os :: raw :: c_uint = 4 ; pub const AV_CH_LAYOUT_STEREO : :: std :: os :: raw :: c_uint = 3 ; pub const AV_CH_LAYOUT_2POINT1 : :: std :: os :: raw :: c_uint = 11 ; pub const AV_CH_LAYOUT_2_1 : :: std :: os :: raw :: c_uint = 259 ; pub const AV_CH_LAYOUT_SURROUND : :: std :: os :: raw :: c_uint = 7 ; pub const AV_CH_LAYOUT_3POINT1 : :: std :: os :: raw :: c_uint = 15 ; pub const AV_CH_LAYOUT_4POINT0 : :: std :: os :: raw :: c_uint = 263 ; pub const AV_CH_LAYOUT_4POINT1 : :: std :: os :: raw :: c_uint = 271 ; pub const AV_CH_LAYOUT_2_2 : :: std :: os :: raw :: c_uint = 1539 ; pub const AV_CH_LAYOUT_QUAD : :: std :: os :: raw :: c_uint = 51 ; pub const AV_CH_LAYOUT_5POINT0 : :: std :: os :: raw :: c_uint = 1543 ; pub const AV_CH_LAYOUT_5POINT1 : :: std :: os :: raw :: c_uint = 1551 ; pub const AV_CH_LAYOUT_5POINT0_BACK : :: std :: os :: raw :: c_uint = 55 ; pub const AV_CH_LAYOUT_5POINT1_BACK : :: std :: os :: raw :: c_uint = 63 ; pub const AV_CH_LAYOUT_6POINT0 : :: std :: os :: raw :: c_uint = 1799 ; pub const AV_CH_LAYOUT_6POINT0_FRONT : :: std :: os :: raw :: c_uint = 1731 ; pub const AV_CH_LAYOUT_HEXAGONAL : :: std :: os :: raw :: c_uint = 311 ; pub const AV_CH_LAYOUT_6POINT1 : :: std :: os :: raw :: c_uint = 1807 ; pub const AV_CH_LAYOUT_6POINT1_BACK : :: std :: os :: raw :: c_uint = 319 ; pub const AV_CH_LAYOUT_6POINT1_FRONT : :: std :: os :: raw :: c_uint = 1739 ; pub const AV_CH_LAYOUT_7POINT0 : :: std :: os :: raw :: c_uint = 1591 ; pub const AV_CH_LAYOUT_7POINT0_FRONT : :: std :: os :: raw :: c_uint = 1735 ; pub const AV_CH_LAYOUT_7POINT1 : :: std :: os :: raw :: c_uint = 1599 ; pub const AV_CH_LAYOUT_7POINT1_WIDE : :: std :: os :: raw :: c_uint = 1743 ; pub const AV_CH_LAYOUT_7POINT1_WIDE_BACK : :: std :: os :: raw :: c_uint = 255 ; pub const AV_CH_LAYOUT_OCTAGONAL : :: std :: os :: raw :: c_uint = 1847 ; pub const AV_CH_LAYOUT_HEXADECAGONAL : :: std :: os :: raw :: c_ulonglong = 6442710839 ; pub const AV_CH_LAYOUT_STEREO_DOWNMIX : :: std :: os :: raw :: c_uint = 1610612736 ; pub const AV_DICT_MATCH_CASE : :: std :: os :: raw :: c_uint = 1 ; pub const AV_DICT_IGNORE_SUFFIX : :: std :: os :: raw :: c_uint = 2 ; pub const AV_DICT_DONT_STRDUP_KEY : :: std :: os :: raw :: c_uint = 4 ; pub const AV_DICT_DONT_STRDUP_VAL : :: std :: os :: raw :: c_uint = 8 ; pub const AV_DICT_DONT_OVERWRITE : :: std :: os :: raw :: c_uint = 16 ; pub const AV_DICT_APPEND : :: std :: os :: raw :: c_uint = 32 ; pub const AV_DICT_MULTIKEY : :: std :: os :: raw :: c_uint = 64 ; pub const AV_NUM_DATA_POINTERS : :: std :: os :: raw :: c_uint = 8 ; pub const AV_FRAME_FLAG_CORRUPT : :: std :: os :: raw :: c_uint = 1 ; pub const AV_FRAME_FLAG_DISCARD : :: std :: os :: raw :: c_uint = 4 ; pub const FF_DECODE_ERROR_INVALID_BITSTREAM : :: std :: os :: raw :: c_uint = 1 ; pub const FF_DECODE_ERROR_MISSING_REFERENCE : :: std :: os :: raw :: c_uint = 2 ; pub const AV_CODEC_PROP_INTRA_ONLY : :: std :: os :: raw :: c_uint = 1 ; pub const AV_CODEC_PROP_LOSSY : :: std :: os :: raw :: c_uint = 2 ; pub const AV_CODEC_PROP_LOSSLESS : :: std :: os :: raw :: c_uint = 4 ; pub const AV_CODEC_PROP_REORDER : :: std :: os :: raw :: c_uint = 8 ; pub const AV_CODEC_PROP_BITMAP_SUB : :: std :: os :: raw :: c_uint = 65536 ; pub const AV_CODEC_PROP_TEXT_SUB : :: std :: os :: raw :: c_uint = 131072 ; pub const AV_INPUT_BUFFER_PADDING_SIZE : :: std :: os :: raw :: c_uint = 32 ; pub const AV_INPUT_BUFFER_MIN_SIZE : :: std :: os :: raw :: c_uint = 16384 ; pub const FF_INPUT_BUFFER_PADDING_SIZE : :: std :: os :: raw :: c_uint = 32 ; pub const FF_MIN_BUFFER_SIZE : :: std :: os :: raw :: c_uint = 16384 ; pub const FF_MAX_B_FRAMES : :: std :: os :: raw :: c_uint = 16 ; pub const AV_CODEC_FLAG_UNALIGNED : :: std :: os :: raw :: c_uint = 1 ; pub const AV_CODEC_FLAG_QSCALE : :: std :: os :: raw :: c_uint = 2 ; pub const AV_CODEC_FLAG_4MV : :: std :: os :: raw :: c_uint = 4 ; pub const AV_CODEC_FLAG_OUTPUT_CORRUPT : :: std :: os :: raw :: c_uint = 8 ; pub const AV_CODEC_FLAG_QPEL : :: std :: os :: raw :: c_uint = 16 ; pub const AV_CODEC_FLAG_PASS1 : :: std :: os :: raw :: c_uint = 512 ; pub const AV_CODEC_FLAG_PASS2 : :: std :: os :: raw :: c_uint = 1024 ; pub const AV_CODEC_FLAG_LOOP_FILTER : :: std :: os :: raw :: c_uint = 2048 ; pub const AV_CODEC_FLAG_GRAY : :: std :: os :: raw :: c_uint = 8192 ; pub const AV_CODEC_FLAG_PSNR : :: std :: os :: raw :: c_uint = 32768 ; pub const AV_CODEC_FLAG_TRUNCATED : :: std :: os :: raw :: c_uint = 65536 ; pub const AV_CODEC_FLAG_INTERLACED_DCT : :: std :: os :: raw :: c_uint = 262144 ; pub const AV_CODEC_FLAG_LOW_DELAY : :: std :: os :: raw :: c_uint = 524288 ; pub const AV_CODEC_FLAG_GLOBAL_HEADER : :: std :: os :: raw :: c_uint = 4194304 ; pub const AV_CODEC_FLAG_BITEXACT : :: std :: os :: raw :: c_uint = 8388608 ; pub const AV_CODEC_FLAG_AC_PRED : :: std :: os :: raw :: c_uint = 16777216 ; pub const AV_CODEC_FLAG_INTERLACED_ME : :: std :: os :: raw :: c_uint = 536870912 ; pub const AV_CODEC_FLAG_CLOSED_GOP : :: std :: os :: raw :: c_uint = 2147483648 ; pub const AV_CODEC_FLAG2_FAST : :: std :: os :: raw :: c_uint = 1 ; pub const AV_CODEC_FLAG2_NO_OUTPUT : :: std :: os :: raw :: c_uint = 4 ; pub const AV_CODEC_FLAG2_LOCAL_HEADER : :: std :: os :: raw :: c_uint = 8 ; pub const AV_CODEC_FLAG2_DROP_FRAME_TIMECODE : :: std :: os :: raw :: c_uint = 8192 ; pub const AV_CODEC_FLAG2_CHUNKS : :: std :: os :: raw :: c_uint = 32768 ; pub const AV_CODEC_FLAG2_IGNORE_CROP : :: std :: os :: raw :: c_uint = 65536 ; pub const AV_CODEC_FLAG2_SHOW_ALL : :: std :: os :: raw :: c_uint = 4194304 ; pub const AV_CODEC_FLAG2_EXPORT_MVS : :: std :: os :: raw :: c_uint = 268435456 ; pub const AV_CODEC_FLAG2_SKIP_MANUAL : :: std :: os :: raw :: c_uint = 536870912 ; pub const AV_CODEC_FLAG2_RO_FLUSH_NOOP : :: std :: os :: raw :: c_uint = 1073741824 ; pub const AV_CODEC_CAP_DRAW_HORIZ_BAND : :: std :: os :: raw :: c_uint = 1 ; pub const AV_CODEC_CAP_DR1 : :: std :: os :: raw :: c_uint = 2 ; pub const AV_CODEC_CAP_TRUNCATED : :: std :: os :: raw :: c_uint = 8 ; pub const AV_CODEC_CAP_DELAY : :: std :: os :: raw :: c_uint = 32 ; pub const AV_CODEC_CAP_SMALL_LAST_FRAME : :: std :: os :: raw :: c_uint = 64 ; pub const AV_CODEC_CAP_HWACCEL_VDPAU : :: std :: os :: raw :: c_uint = 128 ; pub const AV_CODEC_CAP_SUBFRAMES : :: std :: os :: raw :: c_uint = 256 ; pub const AV_CODEC_CAP_EXPERIMENTAL : :: std :: os :: raw :: c_uint = 512 ; pub const AV_CODEC_CAP_CHANNEL_CONF : :: std :: os :: raw :: c_uint = 1024 ; pub const AV_CODEC_CAP_FRAME_THREADS : :: std :: os :: raw :: c_uint = 4096 ; pub const AV_CODEC_CAP_SLICE_THREADS : :: std :: os :: raw :: c_uint = 8192 ; pub const AV_CODEC_CAP_PARAM_CHANGE : :: std :: os :: raw :: c_uint = 16384 ; pub const AV_CODEC_CAP_AUTO_THREADS : :: std :: os :: raw :: c_uint = 32768 ; pub const AV_CODEC_CAP_VARIABLE_FRAME_SIZE : :: std :: os :: raw :: c_uint = 65536 ; pub const AV_CODEC_CAP_AVOID_PROBING : :: std :: os :: raw :: c_uint = 131072 ; pub const AV_CODEC_CAP_INTRA_ONLY : :: std :: os :: raw :: c_uint = 1073741824 ; pub const AV_CODEC_CAP_LOSSLESS : :: std :: os :: raw :: c_uint = 2147483648 ; pub const FF_QSCALE_TYPE_MPEG1 : :: std :: os :: raw :: c_uint = 0 ; pub const FF_QSCALE_TYPE_MPEG2 : :: std :: os :: raw :: c_uint = 1 ; pub const FF_QSCALE_TYPE_H264 : :: std :: os :: raw :: c_uint = 2 ; pub const FF_QSCALE_TYPE_VP56 : :: std :: os :: raw :: c_uint = 3 ; pub const AV_GET_BUFFER_FLAG_REF : :: std :: os :: raw :: c_uint = 1 ; pub const AV_PKT_FLAG_KEY : :: std :: os :: raw :: c_uint = 1 ; pub const AV_PKT_FLAG_CORRUPT : :: std :: os :: raw :: c_uint = 2 ; pub const AV_PKT_FLAG_DISCARD : :: std :: os :: raw :: c_uint = 4 ; pub const FF_COMPRESSION_DEFAULT : :: std :: os :: raw :: c_int = - 1 ; pub const FF_ASPECT_EXTENDED : :: std :: os :: raw :: c_uint = 15 ; pub const FF_RC_STRATEGY_XVID : :: std :: os :: raw :: c_uint = 1 ; pub const FF_PRED_LEFT : :: std :: os :: raw :: c_uint = 0 ; pub const FF_PRED_PLANE : :: std :: os :: raw :: c_uint = 1 ; pub const FF_PRED_MEDIAN : :: std :: os :: raw :: c_uint = 2 ; pub const FF_CMP_SAD : :: std :: os :: raw :: c_uint = 0 ; pub const FF_CMP_SSE : :: std :: os :: raw :: c_uint = 1 ; pub const FF_CMP_SATD : :: std :: os :: raw :: c_uint = 2 ; pub const FF_CMP_DCT : :: std :: os :: raw :: c_uint = 3 ; pub const FF_CMP_PSNR : :: std :: os :: raw :: c_uint = 4 ; pub const FF_CMP_BIT : :: std :: os :: raw :: c_uint = 5 ; pub const FF_CMP_RD : :: std :: os :: raw :: c_uint = 6 ; pub const FF_CMP_ZERO : :: std :: os :: raw :: c_uint = 7 ; pub const FF_CMP_VSAD : :: std :: os :: raw :: c_uint = 8 ; pub const FF_CMP_VSSE : :: std :: os :: raw :: c_uint = 9 ; pub const FF_CMP_NSSE : :: std :: os :: raw :: c_uint = 10 ; pub const FF_CMP_W53 : :: std :: os :: raw :: c_uint = 11 ; pub const FF_CMP_W97 : :: std :: os :: raw :: c_uint = 12 ; pub const FF_CMP_DCTMAX : :: std :: os :: raw :: c_uint = 13 ; pub const FF_CMP_DCT264 : :: std :: os :: raw :: c_uint = 14 ; pub const FF_CMP_MEDIAN_SAD : :: std :: os :: raw :: c_uint = 15 ; pub const FF_CMP_CHROMA : :: std :: os :: raw :: c_uint = 256 ; pub const FF_DTG_AFD_SAME : :: std :: os :: raw :: c_uint = 8 ; pub const FF_DTG_AFD_4_3 : :: std :: os :: raw :: c_uint = 9 ; pub const FF_DTG_AFD_16_9 : :: std :: os :: raw :: c_uint = 10 ; pub const FF_DTG_AFD_14_9 : :: std :: os :: raw :: c_uint = 11 ; pub const FF_DTG_AFD_4_3_SP_14_9 : :: std :: os :: raw :: c_uint = 13 ; pub const FF_DTG_AFD_16_9_SP_14_9 : :: std :: os :: raw :: c_uint = 14 ; pub const FF_DTG_AFD_SP_4_3 : :: std :: os :: raw :: c_uint = 15 ; pub const FF_DEFAULT_QUANT_BIAS : :: std :: os :: raw :: c_uint = 999999 ; pub const FF_MB_DECISION_SIMPLE : :: std :: os :: raw :: c_uint = 0 ; pub const FF_MB_DECISION_BITS : :: std :: os :: raw :: c_uint = 1 ; pub const FF_MB_DECISION_RD : :: std :: os :: raw :: c_uint = 2 ; pub const FF_CODER_TYPE_VLC : :: std :: os :: raw :: c_uint = 0 ; pub const FF_CODER_TYPE_AC : :: std :: os :: raw :: c_uint = 1 ; pub const FF_CODER_TYPE_RAW : :: std :: os :: raw :: c_uint = 2 ; pub const FF_CODER_TYPE_RLE : :: std :: os :: raw :: c_uint = 3 ; pub const FF_CODER_TYPE_DEFLATE : :: std :: os :: raw :: c_uint = 4 ; pub const FF_BUG_AUTODETECT : :: std :: os :: raw :: c_uint = 1 ; pub const FF_BUG_OLD_MSMPEG4 : :: std :: os :: raw :: c_uint = 2 ; pub const FF_BUG_XVID_ILACE : :: std :: os :: raw :: c_uint = 4 ; pub const FF_BUG_UMP4 : :: std :: os :: raw :: c_uint = 8 ; pub const FF_BUG_NO_PADDING : :: std :: os :: raw :: c_uint = 16 ; pub const FF_BUG_AMV : :: std :: os :: raw :: c_uint = 32 ; pub const FF_BUG_AC_VLC : :: std :: os :: raw :: c_uint = 0 ; pub const FF_BUG_QPEL_CHROMA : :: std :: os :: raw :: c_uint = 64 ; pub const FF_BUG_STD_QPEL : :: std :: os :: raw :: c_uint = 128 ; pub const FF_BUG_QPEL_CHROMA2 : :: std :: os :: raw :: c_uint = 256 ; pub const FF_BUG_DIRECT_BLOCKSIZE : :: std :: os :: raw :: c_uint = 512 ; pub const FF_BUG_EDGE : :: std :: os :: raw :: c_uint = 1024 ; pub const FF_BUG_HPEL_CHROMA : :: std :: os :: raw :: c_uint = 2048 ; pub const FF_BUG_DC_CLIP : :: std :: os :: raw :: c_uint = 4096 ; pub const FF_BUG_MS : :: std :: os :: raw :: c_uint = 8192 ; pub const FF_BUG_TRUNCATED : :: std :: os :: raw :: c_uint = 16384 ; pub const FF_BUG_IEDGE : :: std :: os :: raw :: c_uint = 32768 ; pub const FF_COMPLIANCE_VERY_STRICT : :: std :: os :: raw :: c_uint = 2 ; pub const FF_COMPLIANCE_STRICT : :: std :: os :: raw :: c_uint = 1 ; pub const FF_COMPLIANCE_NORMAL : :: std :: os :: raw :: c_uint = 0 ; pub const FF_COMPLIANCE_UNOFFICIAL : :: std :: os :: raw :: c_int = - 1 ; pub const FF_COMPLIANCE_EXPERIMENTAL : :: std :: os :: raw :: c_int = - 2 ; pub const FF_EC_GUESS_MVS : :: std :: os :: raw :: c_uint = 1 ; pub const FF_EC_DEBLOCK : :: std :: os :: raw :: c_uint = 2 ; pub const FF_EC_FAVOR_INTER : :: std :: os :: raw :: c_uint = 256 ; pub const FF_DEBUG_PICT_INFO : :: std :: os :: raw :: c_uint = 1 ; pub const FF_DEBUG_RC : :: std :: os :: raw :: c_uint = 2 ; pub const FF_DEBUG_BITSTREAM : :: std :: os :: raw :: c_uint = 4 ; pub const FF_DEBUG_MB_TYPE : :: std :: os :: raw :: c_uint = 8 ; pub const FF_DEBUG_QP : :: std :: os :: raw :: c_uint = 16 ; pub const FF_DEBUG_MV : :: std :: os :: raw :: c_uint = 32 ; pub const FF_DEBUG_DCT_COEFF : :: std :: os :: raw :: c_uint = 64 ; pub const FF_DEBUG_SKIP : :: std :: os :: raw :: c_uint = 128 ; pub const FF_DEBUG_STARTCODE : :: std :: os :: raw :: c_uint = 256 ; pub const FF_DEBUG_PTS : :: std :: os :: raw :: c_uint = 512 ; pub const FF_DEBUG_ER : :: std :: os :: raw :: c_uint = 1024 ; pub const FF_DEBUG_MMCO : :: std :: os :: raw :: c_uint = 2048 ; pub const FF_DEBUG_BUGS : :: std :: os :: raw :: c_uint = 4096 ; pub const FF_DEBUG_VIS_QP : :: std :: os :: raw :: c_uint = 8192 ; pub const FF_DEBUG_VIS_MB_TYPE : :: std :: os :: raw :: c_uint = 16384 ; pub const FF_DEBUG_BUFFERS : :: std :: os :: raw :: c_uint = 32768 ; pub const FF_DEBUG_THREADS : :: std :: os :: raw :: c_uint = 65536 ; pub const FF_DEBUG_GREEN_MD : :: std :: os :: raw :: c_uint = 8388608 ; pub const FF_DEBUG_NOMC : :: std :: os :: raw :: c_uint = 16777216 ; pub const FF_DEBUG_VIS_MV_P_FOR : :: std :: os :: raw :: c_uint = 1 ; pub const FF_DEBUG_VIS_MV_B_FOR : :: std :: os :: raw :: c_uint = 2 ; pub const FF_DEBUG_VIS_MV_B_BACK : :: std :: os :: raw :: c_uint = 4 ; pub const AV_EF_CRCCHECK : :: std :: os :: raw :: c_uint = 1 ; pub const AV_EF_BITSTREAM : :: std :: os :: raw :: c_uint = 2 ; pub const AV_EF_BUFFER : :: std :: os :: raw :: c_uint = 4 ; pub const AV_EF_EXPLODE : :: std :: os :: raw :: c_uint = 8 ; pub const AV_EF_IGNORE_ERR : :: std :: os :: raw :: c_uint = 32768 ; pub const AV_EF_CAREFUL : :: std :: os :: raw :: c_uint = 65536 ; pub const AV_EF_COMPLIANT : :: std :: os :: raw :: c_uint = 131072 ; pub const AV_EF_AGGRESSIVE : :: std :: os :: raw :: c_uint = 262144 ; pub const FF_DCT_AUTO : :: std :: os :: raw :: c_uint = 0 ; pub const FF_DCT_FASTINT : :: std :: os :: raw :: c_uint = 1 ; pub const FF_DCT_INT : :: std :: os :: raw :: c_uint = 2 ; pub const FF_DCT_MMX : :: std :: os :: raw :: c_uint = 3 ; pub const FF_DCT_ALTIVEC : :: std :: os :: raw :: c_uint = 5 ; pub const FF_DCT_FAAN : :: std :: os :: raw :: c_uint = 6 ; pub const FF_IDCT_AUTO : :: std :: os :: raw :: c_uint = 0 ; pub const FF_IDCT_INT : :: std :: os :: raw :: c_uint = 1 ; pub const FF_IDCT_SIMPLE : :: std :: os :: raw :: c_uint = 2 ; pub const FF_IDCT_SIMPLEMMX : :: std :: os :: raw :: c_uint = 3 ; pub const FF_IDCT_ARM : :: std :: os :: raw :: c_uint = 7 ; pub const FF_IDCT_ALTIVEC : :: std :: os :: raw :: c_uint = 8 ; pub const FF_IDCT_SH4 : :: std :: os :: raw :: c_uint = 9 ; pub const FF_IDCT_SIMPLEARM : :: std :: os :: raw :: c_uint = 10 ; pub const FF_IDCT_IPP : :: std :: os :: raw :: c_uint = 13 ; pub const FF_IDCT_XVID : :: std :: os :: raw :: c_uint = 14 ; pub const FF_IDCT_XVIDMMX : :: std :: os :: raw :: c_uint = 14 ; pub const FF_IDCT_SIMPLEARMV5TE : :: std :: os :: raw :: c_uint = 16 ; pub const FF_IDCT_SIMPLEARMV6 : :: std :: os :: raw :: c_uint = 17 ; pub const FF_IDCT_SIMPLEVIS : :: std :: os :: raw :: c_uint = 18 ; pub const FF_IDCT_FAAN : :: std :: os :: raw :: c_uint = 20 ; pub const FF_IDCT_SIMPLENEON : :: std :: os :: raw :: c_uint = 22 ; pub const FF_IDCT_SIMPLEALPHA : :: std :: os :: raw :: c_uint = 23 ; pub const FF_IDCT_SIMPLEAUTO : :: std :: os :: raw :: c_uint = 128 ; pub const FF_THREAD_FRAME : :: std :: os :: raw :: c_uint = 1 ; pub const FF_THREAD_SLICE : :: std :: os :: raw :: c_uint = 2 ; pub const FF_PROFILE_UNKNOWN : :: std :: os :: raw :: c_int = - 99 ; pub const FF_PROFILE_RESERVED : :: std :: os :: raw :: c_int = - 100 ; pub const FF_PROFILE_AAC_MAIN : :: std :: os :: raw :: c_uint = 0 ; pub const FF_PROFILE_AAC_LOW : :: std :: os :: raw :: c_uint = 1 ; pub const FF_PROFILE_AAC_SSR : :: std :: os :: raw :: c_uint = 2 ; pub const FF_PROFILE_AAC_LTP : :: std :: os :: raw :: c_uint = 3 ; pub const FF_PROFILE_AAC_HE : :: std :: os :: raw :: c_uint = 4 ; pub const FF_PROFILE_AAC_HE_V2 : :: std :: os :: raw :: c_uint = 28 ; pub const FF_PROFILE_AAC_LD : :: std :: os :: raw :: c_uint = 22 ; pub const FF_PROFILE_AAC_ELD : :: std :: os :: raw :: c_uint = 38 ; pub const FF_PROFILE_MPEG2_AAC_LOW : :: std :: os :: raw :: c_uint = 128 ; pub const FF_PROFILE_MPEG2_AAC_HE : :: std :: os :: raw :: c_uint = 131 ; pub const FF_PROFILE_DNXHD : :: std :: os :: raw :: c_uint = 0 ; pub const FF_PROFILE_DNXHR_LB : :: std :: os :: raw :: c_uint = 1 ; pub const FF_PROFILE_DNXHR_SQ : :: std :: os :: raw :: c_uint = 2 ; pub const FF_PROFILE_DNXHR_HQ : :: std :: os :: raw :: c_uint = 3 ; pub const FF_PROFILE_DNXHR_HQX : :: std :: os :: raw :: c_uint = 4 ; pub const FF_PROFILE_DNXHR_444 : :: std :: os :: raw :: c_uint = 5 ; pub const FF_PROFILE_DTS : :: std :: os :: raw :: c_uint = 20 ; pub const FF_PROFILE_DTS_ES : :: std :: os :: raw :: c_uint = 30 ; pub const FF_PROFILE_DTS_96_24 : :: std :: os :: raw :: c_uint = 40 ; pub const FF_PROFILE_DTS_HD_HRA : :: std :: os :: raw :: c_uint = 50 ; pub const FF_PROFILE_DTS_HD_MA : :: std :: os :: raw :: c_uint = 60 ; pub const FF_PROFILE_DTS_EXPRESS : :: std :: os :: raw :: c_uint = 70 ; pub const FF_PROFILE_MPEG2_422 : :: std :: os :: raw :: c_uint = 0 ; pub const FF_PROFILE_MPEG2_HIGH : :: std :: os :: raw :: c_uint = 1 ; pub const FF_PROFILE_MPEG2_SS : :: std :: os :: raw :: c_uint = 2 ; pub const FF_PROFILE_MPEG2_SNR_SCALABLE : :: std :: os :: raw :: c_uint = 3 ; pub const FF_PROFILE_MPEG2_MAIN : :: std :: os :: raw :: c_uint = 4 ; pub const FF_PROFILE_MPEG2_SIMPLE : :: std :: os :: raw :: c_uint = 5 ; pub const FF_PROFILE_H264_CONSTRAINED : :: std :: os :: raw :: c_uint = 512 ; pub const FF_PROFILE_H264_INTRA : :: std :: os :: raw :: c_uint = 2048 ; pub const FF_PROFILE_H264_BASELINE : :: std :: os :: raw :: c_uint = 66 ; pub const FF_PROFILE_H264_CONSTRAINED_BASELINE : :: std :: os :: raw :: c_uint = 578 ; pub const FF_PROFILE_H264_MAIN : :: std :: os :: raw :: c_uint = 77 ; pub const FF_PROFILE_H264_EXTENDED : :: std :: os :: raw :: c_uint = 88 ; pub const FF_PROFILE_H264_HIGH : :: std :: os :: raw :: c_uint = 100 ; pub const FF_PROFILE_H264_HIGH_10 : :: std :: os :: raw :: c_uint = 110 ; pub const FF_PROFILE_H264_HIGH_10_INTRA : :: std :: os :: raw :: c_uint = 2158 ; pub const FF_PROFILE_H264_MULTIVIEW_HIGH : :: std :: os :: raw :: c_uint = 118 ; pub const FF_PROFILE_H264_HIGH_422 : :: std :: os :: raw :: c_uint = 122 ; pub const FF_PROFILE_H264_HIGH_422_INTRA : :: std :: os :: raw :: c_uint = 2170 ; pub const FF_PROFILE_H264_STEREO_HIGH : :: std :: os :: raw :: c_uint = 128 ; pub const FF_PROFILE_H264_HIGH_444 : :: std :: os :: raw :: c_uint = 144 ; pub const FF_PROFILE_H264_HIGH_444_PREDICTIVE : :: std :: os :: raw :: c_uint = 244 ; pub const FF_PROFILE_H264_HIGH_444_INTRA : :: std :: os :: raw :: c_uint = 2292 ; pub const FF_PROFILE_H264_CAVLC_444 : :: std :: os :: raw :: c_uint = 44 ; pub const FF_PROFILE_VC1_SIMPLE : :: std :: os :: raw :: c_uint = 0 ; pub const FF_PROFILE_VC1_MAIN : :: std :: os :: raw :: c_uint = 1 ; pub const FF_PROFILE_VC1_COMPLEX : :: std :: os :: raw :: c_uint = 2 ; pub const FF_PROFILE_VC1_ADVANCED : :: std :: os :: raw :: c_uint = 3 ; pub const FF_PROFILE_MPEG4_SIMPLE : :: std :: os :: raw :: c_uint = 0 ; pub const FF_PROFILE_MPEG4_SIMPLE_SCALABLE : :: std :: os :: raw :: c_uint = 1 ; pub const FF_PROFILE_MPEG4_CORE : :: std :: os :: raw :: c_uint = 2 ; pub const FF_PROFILE_MPEG4_MAIN : :: std :: os :: raw :: c_uint = 3 ; pub const FF_PROFILE_MPEG4_N_BIT : :: std :: os :: raw :: c_uint = 4 ; pub const FF_PROFILE_MPEG4_SCALABLE_TEXTURE : :: std :: os :: raw :: c_uint = 5 ; pub const FF_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION : :: std :: os :: raw :: c_uint = 6 ; pub const FF_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE : :: std :: os :: raw :: c_uint = 7 ; pub const FF_PROFILE_MPEG4_HYBRID : :: std :: os :: raw :: c_uint = 8 ; pub const FF_PROFILE_MPEG4_ADVANCED_REAL_TIME : :: std :: os :: raw :: c_uint = 9 ; pub const FF_PROFILE_MPEG4_CORE_SCALABLE : :: std :: os :: raw :: c_uint = 10 ; pub const FF_PROFILE_MPEG4_ADVANCED_CODING : :: std :: os :: raw :: c_uint = 11 ; pub const FF_PROFILE_MPEG4_ADVANCED_CORE : :: std :: os :: raw :: c_uint = 12 ; pub const FF_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE : :: std :: os :: raw :: c_uint = 13 ; pub const FF_PROFILE_MPEG4_SIMPLE_STUDIO : :: std :: os :: raw :: c_uint = 14 ; pub const FF_PROFILE_MPEG4_ADVANCED_SIMPLE : :: std :: os :: raw :: c_uint = 15 ; pub const FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0 : :: std :: os :: raw :: c_uint = 1 ; pub const FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1 : :: std :: os :: raw :: c_uint = 2 ; pub const FF_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION : :: std :: os :: raw :: c_uint = 32768 ; pub const FF_PROFILE_JPEG2000_DCINEMA_2K : :: std :: os :: raw :: c_uint = 3 ; pub const FF_PROFILE_JPEG2000_DCINEMA_4K : :: std :: os :: raw :: c_uint = 4 ; pub const FF_PROFILE_VP9_0 : :: std :: os :: raw :: c_uint = 0 ; pub const FF_PROFILE_VP9_1 : :: std :: os :: raw :: c_uint = 1 ; pub const FF_PROFILE_VP9_2 : :: std :: os :: raw :: c_uint = 2 ; pub const FF_PROFILE_VP9_3 : :: std :: os :: raw :: c_uint = 3 ; pub const FF_PROFILE_HEVC_MAIN : :: std :: os :: raw :: c_uint = 1 ; pub const FF_PROFILE_HEVC_MAIN_10 : :: std :: os :: raw :: c_uint = 2 ; pub const FF_PROFILE_HEVC_MAIN_STILL_PICTURE : :: std :: os :: raw :: c_uint = 3 ; pub const FF_PROFILE_HEVC_REXT : :: std :: os :: raw :: c_uint = 4 ; pub const FF_LEVEL_UNKNOWN : :: std :: os :: raw :: c_int = - 99 ; pub const FF_SUB_CHARENC_MODE_DO_NOTHING : :: std :: os :: raw :: c_int = - 1 ; pub const FF_SUB_CHARENC_MODE_AUTOMATIC : :: std :: os :: raw :: c_uint = 0 ; pub const FF_SUB_CHARENC_MODE_PRE_DECODER : :: std :: os :: raw :: c_uint = 1 ; pub const FF_CODEC_PROPERTY_LOSSLESS : :: std :: os :: raw :: c_uint = 1 ; pub const FF_CODEC_PROPERTY_CLOSED_CAPTIONS : :: std :: os :: raw :: c_uint = 2 ; pub const FF_SUB_TEXT_FMT_ASS : :: std :: os :: raw :: c_uint = 0 ; pub const FF_SUB_TEXT_FMT_ASS_WITH_TIMINGS : :: std :: os :: raw :: c_uint = 1 ; pub const AV_HWACCEL_FLAG_IGNORE_LEVEL : :: std :: os :: raw :: c_uint = 1 ; pub const AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH : :: std :: os :: raw :: c_uint = 2 ; pub const AV_SUBTITLE_FLAG_FORCED : :: std :: os :: raw :: c_uint = 1 ; pub const AV_PARSER_PTS_NB : :: std :: os :: raw :: c_uint = 4 ; pub const FF_API_R_FRAME_RATE : :: std :: os :: raw :: c_uint = 1 ; pub const AVIO_SEEKABLE_NORMAL : :: std :: os :: raw :: c_uint = 1 ; pub const AVIO_SEEKABLE_TIME : :: std :: os :: raw :: c_uint = 2 ; pub const AVSEEK_SIZE : :: std :: os :: raw :: c_uint = 65536 ; pub const AVSEEK_FORCE : :: std :: os :: raw :: c_uint = 131072 ; pub const AVIO_FLAG_READ : :: std :: os :: raw :: c_uint = 1 ; pub const AVIO_FLAG_WRITE : :: std :: os :: raw :: c_uint = 2 ; pub const AVIO_FLAG_READ_WRITE : :: std :: os :: raw :: c_uint = 3 ; pub const AVIO_FLAG_NONBLOCK : :: std :: os :: raw :: c_uint = 8 ; pub const AVIO_FLAG_DIRECT : :: std :: os :: raw :: c_uint = 32768 ; pub const AVPROBE_SCORE_EXTENSION : :: std :: os :: raw :: c_uint = 50 ; pub const AVPROBE_SCORE_MIME : :: std :: os :: raw :: c_uint = 75 ; pub const AVPROBE_SCORE_MAX : :: std :: os :: raw :: c_uint = 100 ; pub const AVPROBE_PADDING_SIZE : :: std :: os :: raw :: c_uint = 32 ; pub const AVFMT_NOFILE : :: std :: os :: raw :: c_uint = 1 ; pub const AVFMT_NEEDNUMBER : :: std :: os :: raw :: c_uint = 2 ; pub const AVFMT_SHOW_IDS : :: std :: os :: raw :: c_uint = 8 ; pub const AVFMT_RAWPICTURE : :: std :: os :: raw :: c_uint = 32 ; pub const AVFMT_GLOBALHEADER : :: std :: os :: raw :: c_uint = 64 ; pub const AVFMT_NOTIMESTAMPS : :: std :: os :: raw :: c_uint = 128 ; pub const AVFMT_GENERIC_INDEX : :: std :: os :: raw :: c_uint = 256 ; pub const AVFMT_TS_DISCONT : :: std :: os :: raw :: c_uint = 512 ; pub const AVFMT_VARIABLE_FPS : :: std :: os :: raw :: c_uint = 1024 ; pub const AVFMT_NODIMENSIONS : :: std :: os :: raw :: c_uint = 2048 ; pub const AVFMT_NOSTREAMS : :: std :: os :: raw :: c_uint = 4096 ; pub const AVFMT_NOBINSEARCH : :: std :: os :: raw :: c_uint = 8192 ; pub const AVFMT_NOGENSEARCH : :: std :: os :: raw :: c_uint = 16384 ; pub const AVFMT_NO_BYTE_SEEK : :: std :: os :: raw :: c_uint = 32768 ; pub const AVFMT_ALLOW_FLUSH : :: std :: os :: raw :: c_uint = 65536 ; pub const AVFMT_TS_NONSTRICT : :: std :: os :: raw :: c_uint = 131072 ; pub const AVFMT_TS_NEGATIVE : :: std :: os :: raw :: c_uint = 262144 ; pub const AVFMT_SEEK_TO_PTS : :: std :: os :: raw :: c_uint = 67108864 ; pub const AVINDEX_KEYFRAME : :: std :: os :: raw :: c_uint = 1 ; pub const AVINDEX_DISCARD_FRAME : :: std :: os :: raw :: c_uint = 2 ; pub const AV_DISPOSITION_DEFAULT : :: std :: os :: raw :: c_uint = 1 ; pub const AV_DISPOSITION_DUB : :: std :: os :: raw :: c_uint = 2 ; pub const AV_DISPOSITION_ORIGINAL : :: std :: os :: raw :: c_uint = 4 ; pub const AV_DISPOSITION_COMMENT : :: std :: os :: raw :: c_uint = 8 ; pub const AV_DISPOSITION_LYRICS : :: std :: os :: raw :: c_uint = 16 ; pub const AV_DISPOSITION_KARAOKE : :: std :: os :: raw :: c_uint = 32 ; pub const AV_DISPOSITION_FORCED : :: std :: os :: raw :: c_uint = 64 ; pub const AV_DISPOSITION_HEARING_IMPAIRED : :: std :: os :: raw :: c_uint = 128 ; pub const AV_DISPOSITION_VISUAL_IMPAIRED : :: std :: os :: raw :: c_uint = 256 ; pub const AV_DISPOSITION_CLEAN_EFFECTS : :: std :: os :: raw :: c_uint = 512 ; pub const AV_DISPOSITION_ATTACHED_PIC : :: std :: os :: raw :: c_uint = 1024 ; pub const AV_DISPOSITION_TIMED_THUMBNAILS : :: std :: os :: raw :: c_uint = 2048 ; pub const AV_DISPOSITION_CAPTIONS : :: std :: os :: raw :: c_uint = 65536 ; pub const AV_DISPOSITION_DESCRIPTIONS : :: std :: os :: raw :: c_uint = 131072 ; pub const AV_DISPOSITION_METADATA : :: std :: os :: raw :: c_uint = 262144 ; pub const AV_PTS_WRAP_IGNORE : :: std :: os :: raw :: c_uint = 0 ; pub const AV_PTS_WRAP_ADD_OFFSET : :: std :: os :: raw :: c_uint = 1 ; pub const AV_PTS_WRAP_SUB_OFFSET : :: std :: os :: raw :: c_int = - 1 ; pub const AVSTREAM_EVENT_FLAG_METADATA_UPDATED : :: std :: os :: raw :: c_uint = 1 ; pub const AV_PROGRAM_RUNNING : :: std :: os :: raw :: c_uint = 1 ; pub const AVFMTCTX_NOHEADER : :: std :: os :: raw :: c_uint = 1 ; pub const AVFMT_FLAG_GENPTS : :: std :: os :: raw :: c_uint = 1 ; pub const AVFMT_FLAG_IGNIDX : :: std :: os :: raw :: c_uint = 2 ; pub const AVFMT_FLAG_NONBLOCK : :: std :: os :: raw :: c_uint = 4 ; pub const AVFMT_FLAG_IGNDTS : :: std :: os :: raw :: c_uint = 8 ; pub const AVFMT_FLAG_NOFILLIN : :: std :: os :: raw :: c_uint = 16 ; pub const AVFMT_FLAG_NOPARSE : :: std :: os :: raw :: c_uint = 32 ; pub const AVFMT_FLAG_NOBUFFER : :: std :: os :: raw :: c_uint = 64 ; pub const AVFMT_FLAG_CUSTOM_IO : :: std :: os :: raw :: c_uint = 128 ; pub const AVFMT_FLAG_DISCARD_CORRUPT : :: std :: os :: raw :: c_uint = 256 ; pub const AVFMT_FLAG_FLUSH_PACKETS : :: std :: os :: raw :: c_uint = 512 ; pub const AVFMT_FLAG_BITEXACT : :: std :: os :: raw :: c_uint = 1024 ; pub const AVFMT_FLAG_MP4A_LATM : :: std :: os :: raw :: c_uint = 32768 ; pub const AVFMT_FLAG_SORT_DTS : :: std :: os :: raw :: c_uint = 65536 ; pub const AVFMT_FLAG_PRIV_OPT : :: std :: os :: raw :: c_uint = 131072 ; pub const AVFMT_FLAG_KEEP_SIDE_DATA : :: std :: os :: raw :: c_uint = 262144 ; pub const AVFMT_FLAG_FAST_SEEK : :: std :: os :: raw :: c_uint = 524288 ; pub const AVFMT_FLAG_SHORTEST : :: std :: os :: raw :: c_uint = 1048576 ; pub const AVFMT_FLAG_AUTO_BSF : :: std :: os :: raw :: c_uint = 2097152 ; pub const FF_FDEBUG_TS : :: std :: os :: raw :: c_uint = 1 ; pub const AVFMT_EVENT_FLAG_METADATA_UPDATED : :: std :: os :: raw :: c_uint = 1 ; pub const AVFMT_AVOID_NEG_TS_AUTO : :: std :: os :: raw :: c_int = - 1 ; pub const AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE : :: std :: os :: raw :: c_uint = 1 ; pub const AVFMT_AVOID_NEG_TS_MAKE_ZERO : :: std :: os :: raw :: c_uint = 2 ; pub const AVSEEK_FLAG_BACKWARD : :: std :: os :: raw :: c_uint = 1 ; pub const AVSEEK_FLAG_BYTE : :: std :: os :: raw :: c_uint = 2 ; pub const AVSEEK_FLAG_ANY : :: std :: os :: raw :: c_uint = 4 ; pub const AVSEEK_FLAG_FRAME : :: std :: os :: raw :: c_uint = 8 ; pub const AVSTREAM_INIT_IN_WRITE_HEADER : :: std :: os :: raw :: c_uint = 0 ; pub const AVSTREAM_INIT_IN_INIT_OUTPUT : :: std :: os :: raw :: c_uint = 1 ; pub const AV_FRAME_FILENAME_FLAGS_MULTIPLE : :: std :: os :: raw :: c_uint = 1 ; pub const SWS_FAST_BILINEAR : :: std :: os :: raw :: c_uint = 1 ; pub const SWS_BILINEAR : :: std :: os :: raw :: c_uint = 2 ; pub const SWS_BICUBIC : :: std :: os :: raw :: c_uint = 4 ; pub const SWS_X : :: std :: os :: raw :: c_uint = 8 ; pub const SWS_POINT : :: std :: os :: raw :: c_uint = 16 ; pub const SWS_AREA : :: std :: os :: raw :: c_uint = 32 ; pub const SWS_BICUBLIN : :: std :: os :: raw :: c_uint = 64 ; pub const SWS_GAUSS : :: std :: os :: raw :: c_uint = 128 ; pub const SWS_SINC : :: std :: os :: raw :: c_uint = 256 ; pub const SWS_LANCZOS : :: std :: os :: raw :: c_uint = 512 ; pub const SWS_SPLINE : :: std :: os :: raw :: c_uint = 1024 ; pub const SWS_SRC_V_CHR_DROP_MASK : :: std :: os :: raw :: c_uint = 196608 ; pub const SWS_SRC_V_CHR_DROP_SHIFT : :: std :: os :: raw :: c_uint = 16 ; pub const SWS_PARAM_DEFAULT : :: std :: os :: raw :: c_uint = 123456 ; pub const SWS_PRINT_INFO : :: std :: os :: raw :: c_uint = 4096 ; pub const SWS_FULL_CHR_H_INT : :: std :: os :: raw :: c_uint = 8192 ; pub const SWS_FULL_CHR_H_INP : :: std :: os :: raw :: c_uint = 16384 ; pub const SWS_DIRECT_BGR : :: std :: os :: raw :: c_uint = 32768 ; pub const SWS_ACCURATE_RND : :: std :: os :: raw :: c_uint = 262144 ; pub const SWS_BITEXACT : :: std :: os :: raw :: c_uint = 524288 ; pub const SWS_ERROR_DIFFUSION : :: std :: os :: raw :: c_uint = 8388608 ; pub const SWS_MAX_REDUCE_CUTOFF : f64 = 0.002 ; pub const SWS_CS_ITU709 : :: std :: os :: raw :: c_uint = 1 ; pub const SWS_CS_FCC : :: std :: os :: raw :: c_uint = 4 ; pub const SWS_CS_ITU601 : :: std :: os :: raw :: c_uint = 5 ; pub const SWS_CS_ITU624 : :: std :: os :: raw :: c_uint = 5 ; pub const SWS_CS_SMPTE170M : :: std :: os :: raw :: c_uint = 5 ; pub const SWS_CS_SMPTE240M : :: std :: os :: raw :: c_uint = 7 ; pub const SWS_CS_DEFAULT : :: std :: os :: raw :: c_uint = 5 ; pub const SWS_CS_BT2020 : :: std :: os :: raw :: c_uint = 9 ; extern "C" { pub fn avutil_version ( ) -> :: std :: os :: raw :: c_uint ; } extern "C" { pub fn av_version_info ( ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn avutil_configuration ( ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn avutil_license ( ) -> * const :: std :: os :: raw :: c_char ; } # [ repr ( i32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum AVMediaType { AVMEDIA_TYPE_UNKNOWN = - 1 , AVMEDIA_TYPE_VIDEO = 0 , AVMEDIA_TYPE_AUDIO = 1 , AVMEDIA_TYPE_DATA = 2 , AVMEDIA_TYPE_SUBTITLE = 3 , AVMEDIA_TYPE_ATTACHMENT = 4 , AVMEDIA_TYPE_NB = 5 , } extern "C" { pub fn av_get_media_type_string ( media_type : AVMediaType ) -> * const :: std :: os :: raw :: c_char ; } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum AVPictureType { AV_PICTURE_TYPE_NONE = 0 , AV_PICTURE_TYPE_I = 1 , AV_PICTURE_TYPE_P = 2 , AV_PICTURE_TYPE_B = 3 , AV_PICTURE_TYPE_S = 4 , AV_PICTURE_TYPE_SI = 5 , AV_PICTURE_TYPE_SP = 6 , AV_PICTURE_TYPE_BI = 7 , } extern "C" { pub fn av_get_picture_type_char ( pict_type : AVPictureType ) -> :: std :: os :: raw :: c_char ; } pub type int_least8_t = :: std :: os :: raw :: c_schar ; pub type int_least16_t = :: std :: os :: raw :: c_short ; pub type int_least32_t = :: std :: os :: raw :: c_int ; pub type int_least64_t = :: std :: os :: raw :: c_long ; pub type uint_least8_t = :: std :: os :: raw :: c_uchar ; pub type uint_least16_t = :: std :: os :: raw :: c_ushort ; pub type uint_least32_t = :: std :: os :: raw :: c_uint ; pub type uint_least64_t = :: std :: os :: raw :: c_ulong ; pub type int_fast8_t = :: std :: os :: raw :: c_schar ; pub type int_fast16_t = :: std :: os :: raw :: c_long ; pub type int_fast32_t = :: std :: os :: raw :: c_long ; pub type int_fast64_t = :: std :: os :: raw :: c_long ; pub type uint_fast8_t = :: std :: os :: raw :: c_uchar ; pub type uint_fast16_t = :: std :: os :: raw :: c_ulong ; pub type uint_fast32_t = :: std :: os :: raw :: c_ulong ; pub type uint_fast64_t = :: std :: os :: raw :: c_ulong ; pub type intmax_t = :: std :: os :: raw :: c_long ; pub type uintmax_t = :: std :: os :: raw :: c_ulong ; pub type __gwchar_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct imaxdiv_t { pub quot : :: std :: os :: raw :: c_long , pub rem : :: std :: os :: raw :: c_long } # [ test ] fn bindgen_test_layout_imaxdiv_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < imaxdiv_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( imaxdiv_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < imaxdiv_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( imaxdiv_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const imaxdiv_t ) ) . quot as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( imaxdiv_t ) , "::" , stringify ! ( quot ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const imaxdiv_t ) ) . rem as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( imaxdiv_t ) , "::" , stringify ! ( rem ) ) ) ; } impl Clone for imaxdiv_t { fn clone ( & self ) -> Self { * self } } pub type float_t = f32 ; pub type double_t = f64 ; pub type __int8_t = :: std :: os :: raw :: c_schar ; pub type __uint8_t = :: std :: os :: raw :: c_uchar ; pub type __int16_t = :: std :: os :: raw :: c_short ; pub type __uint16_t = :: std :: os :: raw :: c_ushort ; pub type __int32_t = :: std :: os :: raw :: c_int ; pub type __uint32_t = :: std :: os :: raw :: c_uint ; pub type __int64_t = :: std :: os :: raw :: c_long ; pub type __uint64_t = :: std :: os :: raw :: c_ulong ; pub type __quad_t = :: std :: os :: raw :: c_long ; pub type __u_quad_t = :: std :: os :: raw :: c_ulong ; pub type __dev_t = :: std :: os :: raw :: c_ulong ; pub type __uid_t = :: std :: os :: raw :: c_uint ; pub type __gid_t = :: std :: os :: raw :: c_uint ; pub type __ino_t = :: std :: os :: raw :: c_ulong ; pub type __ino64_t = :: std :: os :: raw :: c_ulong ; pub type __mode_t = :: std :: os :: raw :: c_uint ; pub type __nlink_t = :: std :: os :: raw :: c_ulong ; pub type __off_t = :: std :: os :: raw :: c_long ; pub type __off64_t = :: std :: os :: raw :: c_long ; pub type __pid_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct __fsid_t { pub __val : [ :: std :: os :: raw :: c_int ; 2usize ] } # [ test ] fn bindgen_test_layout___fsid_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __fsid_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __fsid_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __fsid_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __fsid_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __fsid_t ) ) . __val as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __fsid_t ) , "::" , stringify ! ( __val ) ) ) ; } impl Clone for __fsid_t { fn clone ( & self ) -> Self { * self } } pub type __clock_t = :: std :: os :: raw :: c_long ; pub type __rlim_t = :: std :: os :: raw :: c_ulong ; pub type __rlim64_t = :: std :: os :: raw :: c_ulong ; pub type __id_t = :: std :: os :: raw :: c_uint ; pub type __time_t = :: std :: os :: raw :: c_long ; pub type __useconds_t = :: std :: os :: raw :: c_uint ; pub type __suseconds_t = :: std :: os :: raw :: c_long ; pub type __daddr_t = :: std :: os :: raw :: c_int ; pub type __key_t = :: std :: os :: raw :: c_int ; pub type __clockid_t = :: std :: os :: raw :: c_int ; pub type __timer_t = * mut :: std :: os :: raw :: c_void ; pub type __blksize_t = :: std :: os :: raw :: c_long ; pub type __blkcnt_t = :: std :: os :: raw :: c_long ; pub type __blkcnt64_t = :: std :: os :: raw :: c_long ; pub type __fsblkcnt_t = :: std :: os :: raw :: c_ulong ; pub type __fsblkcnt64_t = :: std :: os :: raw :: c_ulong ; pub type __fsfilcnt_t = :: std :: os :: raw :: c_ulong ; pub type __fsfilcnt64_t = :: std :: os :: raw :: c_ulong ; pub type __fsword_t = :: std :: os :: raw :: c_long ; pub type __ssize_t = :: std :: os :: raw :: c_long ; pub type __syscall_slong_t = :: std :: os :: raw :: c_long ; pub type __syscall_ulong_t = :: std :: os :: raw :: c_ulong ; pub type __loff_t = __off64_t ; pub type __qaddr_t = * mut __quad_t ; pub type __caddr_t = * mut :: std :: os :: raw :: c_char ; pub type __intptr_t = :: std :: os :: raw :: c_long ; pub type __socklen_t = :: std :: os :: raw :: c_uint ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct _IO_FILE { pub _flags : :: std :: os :: raw :: c_int , pub _IO_read_ptr : * mut :: std :: os :: raw :: c_char , pub _IO_read_end : * mut :: std :: os :: raw :: c_char , pub _IO_read_base : * mut :: std :: os :: raw :: c_char , pub _IO_write_base : * mut :: std :: os :: raw :: c_char , pub _IO_write_ptr : * mut :: std :: os :: raw :: c_char , pub _IO_write_end : * mut :: std :: os :: raw :: c_char , pub _IO_buf_base : * mut :: std :: os :: raw :: c_char , pub _IO_buf_end : * mut :: std :: os :: raw :: c_char , pub _IO_save_base : * mut :: std :: os :: raw :: c_char , pub _IO_backup_base : * mut :: std :: os :: raw :: c_char , pub _IO_save_end : * mut :: std :: os :: raw :: c_char , pub _markers : * mut _IO_marker , pub _chain : * mut _IO_FILE , pub _fileno : :: std :: os :: raw :: c_int , pub _flags2 : :: std :: os :: raw :: c_int , pub _old_offset : __off_t , pub _cur_column : :: std :: os :: raw :: c_ushort , pub _vtable_offset : :: std :: os :: raw :: c_schar , pub _shortbuf : [ :: std :: os :: raw :: c_char ; 1usize ] , pub _lock : * mut _IO_lock_t , pub _offset : __off64_t , pub __pad1 : * mut :: std :: os :: raw :: c_void , pub __pad2 : * mut :: std :: os :: raw :: c_void , pub __pad3 : * mut :: std :: os :: raw :: c_void , pub __pad4 : * mut :: std :: os :: raw :: c_void , pub __pad5 : usize , pub _mode : :: std :: os :: raw :: c_int , pub _unused2 : [ :: std :: os :: raw :: c_char ; 20usize ] } # [ test ] fn bindgen_test_layout__IO_FILE ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _IO_FILE > ( ) , 216usize , concat ! ( "Size of: " , stringify ! ( _IO_FILE ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _IO_FILE > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _IO_FILE ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _IO_FILE ) ) . _flags as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_ptr as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_read_ptr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_end as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_read_end ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_base as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_read_base ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_base as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_write_base ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_ptr as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_write_ptr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_end as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_write_end ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _IO_FILE ) ) . _IO_buf_base as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_buf_base ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _IO_FILE ) ) . _IO_buf_end as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_buf_end ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _IO_FILE ) ) . _IO_save_base as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_save_base ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _IO_FILE ) ) . _IO_backup_base as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_backup_base ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _IO_FILE ) ) . _IO_save_end as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_save_end ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _IO_FILE ) ) . _markers as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _markers ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _IO_FILE ) ) . _chain as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _chain ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _IO_FILE ) ) . _fileno as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _fileno ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _IO_FILE ) ) . _flags2 as * const _ as usize } , 116usize , concat ! ( "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _flags2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _IO_FILE ) ) . _old_offset as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _old_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _IO_FILE ) ) . _cur_column as * const _ as usize } , 128usize , concat ! ( "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _cur_column ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _IO_FILE ) ) . _vtable_offset as * const _ as usize } , 130usize , concat ! ( "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _vtable_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _IO_FILE ) ) . _shortbuf as * const _ as usize } , 131usize , concat ! ( "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _shortbuf ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _IO_FILE ) ) . _lock as * const _ as usize } , 136usize , concat ! ( "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _lock ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _IO_FILE ) ) . _offset as * const _ as usize } , 144usize , concat ! ( "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _IO_FILE ) ) . __pad1 as * const _ as usize } , 152usize , concat ! ( "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( __pad1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _IO_FILE ) ) . __pad2 as * const _ as usize } , 160usize , concat ! ( "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( __pad2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _IO_FILE ) ) . __pad3 as * const _ as usize } , 168usize , concat ! ( "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( __pad3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _IO_FILE ) ) . __pad4 as * const _ as usize } , 176usize , concat ! ( "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( __pad4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _IO_FILE ) ) . __pad5 as * const _ as usize } , 184usize , concat ! ( "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( __pad5 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _IO_FILE ) ) . _mode as * const _ as usize } , 192usize , concat ! ( "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _mode ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _IO_FILE ) ) . _unused2 as * const _ as usize } , 196usize , concat ! ( "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _unused2 ) ) ) ; } impl Clone for _IO_FILE { fn clone ( & self ) -> Self { * self } } pub type FILE = _IO_FILE ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct __mbstate_t { pub __count : :: std :: os :: raw :: c_int , pub __value : __mbstate_t__bindgen_ty_1 } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct __mbstate_t__bindgen_ty_1 { pub __wch : __BindgenUnionField < :: std :: os :: raw :: c_uint > , pub __wchb : __BindgenUnionField < [ :: std :: os :: raw :: c_char ; 4usize ] > , pub bindgen_union_field : u32 } # [ test ] fn bindgen_test_layout___mbstate_t__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __mbstate_t__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __mbstate_t__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __mbstate_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __mbstate_t__bindgen_ty_1 ) ) . __wch as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wch ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __mbstate_t__bindgen_ty_1 ) ) . __wchb as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wchb ) ) ) ; } impl Clone for __mbstate_t__bindgen_ty_1 { fn clone ( & self ) -> Self { * self } } # [ test ] fn bindgen_test_layout___mbstate_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __mbstate_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __mbstate_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __mbstate_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __mbstate_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __mbstate_t ) ) . __count as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" , stringify ! ( __count ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __mbstate_t ) ) . __value as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" , stringify ! ( __value ) ) ) ; } impl Clone for __mbstate_t { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct _G_fpos_t { pub __pos : __off_t , pub __state : __mbstate_t } # [ test ] fn bindgen_test_layout__G_fpos_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _G_fpos_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( _G_fpos_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _G_fpos_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _G_fpos_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _G_fpos_t ) ) . __pos as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _G_fpos_t ) , "::" , stringify ! ( __pos ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _G_fpos_t ) ) . __state as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _G_fpos_t ) , "::" , stringify ! ( __state ) ) ) ; } impl Clone for _G_fpos_t { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct _G_fpos64_t { pub __pos : __off64_t , pub __state : __mbstate_t } # [ test ] fn bindgen_test_layout__G_fpos64_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _G_fpos64_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( _G_fpos64_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _G_fpos64_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _G_fpos64_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _G_fpos64_t ) ) . __pos as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _G_fpos64_t ) , "::" , stringify ! ( __pos ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _G_fpos64_t ) ) . __state as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _G_fpos64_t ) , "::" , stringify ! ( __state ) ) ) ; } impl Clone for _G_fpos64_t { fn clone ( & self ) -> Self { * self } } pub type va_list = __builtin_va_list ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_jump_t ( [ u8 ; 0 ] ) ; pub type _IO_lock_t = :: std :: os :: raw :: c_void ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct _IO_marker { pub _next : * mut _IO_marker , pub _sbuf : * mut _IO_FILE , pub _pos : :: std :: os :: raw :: c_int } # [ test ] fn bindgen_test_layout__IO_marker ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _IO_marker > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( _IO_marker ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _IO_marker > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _IO_marker ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _IO_marker ) ) . _next as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _IO_marker ) , "::" , stringify ! ( _next ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _IO_marker ) ) . _sbuf as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _IO_marker ) , "::" , stringify ! ( _sbuf ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _IO_marker ) ) . _pos as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( _IO_marker ) , "::" , stringify ! ( _pos ) ) ) ; } impl Clone for _IO_marker { fn clone ( & self ) -> Self { * self } } pub type off_t = __off_t ; pub type fpos_t = _G_fpos_t ; pub type wchar_t = :: std :: os :: raw :: c_int ; # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum idtype_t { P_ALL = 0 , P_PID = 1 , P_PGID = 2 , } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct div_t { pub quot : :: std :: os :: raw :: c_int , pub rem : :: std :: os :: raw :: c_int } # [ test ] fn bindgen_test_layout_div_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < div_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( div_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < div_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( div_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const div_t ) ) . quot as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( div_t ) , "::" , stringify ! ( quot ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const div_t ) ) . rem as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( div_t ) , "::" , stringify ! ( rem ) ) ) ; } impl Clone for div_t { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct ldiv_t { pub quot : :: std :: os :: raw :: c_long , pub rem : :: std :: os :: raw :: c_long } # [ test ] fn bindgen_test_layout_ldiv_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ldiv_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( ldiv_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ldiv_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ldiv_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ldiv_t ) ) . quot as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ldiv_t ) , "::" , stringify ! ( quot ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ldiv_t ) ) . rem as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( ldiv_t ) , "::" , stringify ! ( rem ) ) ) ; } impl Clone for ldiv_t { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct lldiv_t { pub quot : :: std :: os :: raw :: c_longlong , pub rem : :: std :: os :: raw :: c_longlong } # [ test ] fn bindgen_test_layout_lldiv_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < lldiv_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( lldiv_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < lldiv_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( lldiv_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const lldiv_t ) ) . quot as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( lldiv_t ) , "::" , stringify ! ( quot ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const lldiv_t ) ) . rem as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( lldiv_t ) , "::" , stringify ! ( rem ) ) ) ; } impl Clone for lldiv_t { fn clone ( & self ) -> Self { * self } } pub type quad_t = __quad_t ; pub type u_quad_t = __u_quad_t ; pub type fsid_t = __fsid_t ; pub type loff_t = __loff_t ; pub type ino_t = __ino_t ; pub type dev_t = __dev_t ; pub type gid_t = __gid_t ; pub type mode_t = __mode_t ; pub type nlink_t = __nlink_t ; pub type uid_t = __uid_t ; pub type pid_t = __pid_t ; pub type id_t = __id_t ; pub type daddr_t = __daddr_t ; pub type caddr_t = __caddr_t ; pub type key_t = __key_t ; pub type clock_t = __clock_t ; pub type time_t = __time_t ; pub type clockid_t = __clockid_t ; pub type timer_t = __timer_t ; pub type u_int8_t = :: std :: os :: raw :: c_uchar ; pub type u_int16_t = :: std :: os :: raw :: c_ushort ; pub type u_int32_t = :: std :: os :: raw :: c_uint ; pub type u_int64_t = :: std :: os :: raw :: c_ulong ; pub type register_t = :: std :: os :: raw :: c_long ; pub type __sig_atomic_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct __sigset_t { pub __val : [ :: std :: os :: raw :: c_ulong ; 16usize ] } # [ test ] fn bindgen_test_layout___sigset_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __sigset_t > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( __sigset_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __sigset_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __sigset_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __sigset_t ) ) . __val as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __sigset_t ) , "::" , stringify ! ( __val ) ) ) ; } impl Clone for __sigset_t { fn clone ( & self ) -> Self { * self } } pub type sigset_t = __sigset_t ; pub type suseconds_t = __suseconds_t ; pub type blksize_t = __blksize_t ; pub type blkcnt_t = __blkcnt_t ; pub type fsblkcnt_t = __fsblkcnt_t ; pub type fsfilcnt_t = __fsfilcnt_t ; pub type pthread_t = :: std :: os :: raw :: c_ulong ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct pthread_attr_t { pub __size : __BindgenUnionField < [ :: std :: os :: raw :: c_char ; 56usize ] > , pub __align : __BindgenUnionField < :: std :: os :: raw :: c_long > , pub bindgen_union_field : [ u64 ; 7usize ] } # [ test ] fn bindgen_test_layout_pthread_attr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_attr_t > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( pthread_attr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_attr_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_attr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_attr_t ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_attr_t ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::" , stringify ! ( __align ) ) ) ; } impl Clone for pthread_attr_t { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct __pthread_internal_list { pub __prev : * mut __pthread_internal_list , pub __next : * mut __pthread_internal_list } # [ test ] fn bindgen_test_layout___pthread_internal_list ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_internal_list > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( __pthread_internal_list ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_internal_list > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_internal_list ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_internal_list ) ) . __prev as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_internal_list ) , "::" , stringify ! ( __prev ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __pthread_internal_list ) ) . __next as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( __pthread_internal_list ) , "::" , stringify ! ( __next ) ) ) ; } impl Clone for __pthread_internal_list { fn clone ( & self ) -> Self { * self } } pub type __pthread_list_t = __pthread_internal_list ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct pthread_mutex_t { pub __data : __BindgenUnionField < pthread_mutex_t___pthread_mutex_s > , pub __size : __BindgenUnionField < [ :: std :: os :: raw :: c_char ; 40usize ] > , pub __align : __BindgenUnionField < :: std :: os :: raw :: c_long > , pub bindgen_union_field : [ u64 ; 5usize ] } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct pthread_mutex_t___pthread_mutex_s { pub __lock : :: std :: os :: raw :: c_int , pub __count : :: std :: os :: raw :: c_uint , pub __owner : :: std :: os :: raw :: c_int , pub __nusers : :: std :: os :: raw :: c_uint , pub __kind : :: std :: os :: raw :: c_int , pub __spins : :: std :: os :: raw :: c_short , pub __elision : :: std :: os :: raw :: c_short , pub __list : __pthread_list_t } # [ test ] fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_mutex_t___pthread_mutex_s > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_mutex_t___pthread_mutex_s > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) . __lock as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! ( __lock ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) . __count as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! ( __count ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) . __owner as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! ( __owner ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) . __nusers as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! ( __nusers ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) . __kind as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! ( __kind ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) . __spins as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! ( __spins ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) . __elision as * const _ as usize } , 22usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! ( __elision ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) . __list as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! ( __list ) ) ) ; } impl Clone for pthread_mutex_t___pthread_mutex_s { fn clone ( & self ) -> Self { * self } } # [ test ] fn bindgen_test_layout_pthread_mutex_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_mutex_t > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( pthread_mutex_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_mutex_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_mutex_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_mutex_t ) ) . __data as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_mutex_t ) , "::" , stringify ! ( __data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_mutex_t ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_mutex_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_mutex_t ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_mutex_t ) , "::" , stringify ! ( __align ) ) ) ; } impl Clone for pthread_mutex_t { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct pthread_mutexattr_t { pub __size : __BindgenUnionField < [ :: std :: os :: raw :: c_char ; 4usize ] > , pub __align : __BindgenUnionField < :: std :: os :: raw :: c_int > , pub bindgen_union_field : u32 } # [ test ] fn bindgen_test_layout_pthread_mutexattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_mutexattr_t > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( pthread_mutexattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_mutexattr_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( pthread_mutexattr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_mutexattr_t ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_mutexattr_t ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) , "::" , stringify ! ( __align ) ) ) ; } impl Clone for pthread_mutexattr_t { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct pthread_cond_t { pub __data : __BindgenUnionField < pthread_cond_t__bindgen_ty_1 > , pub __size : __BindgenUnionField < [ :: std :: os :: raw :: c_char ; 48usize ] > , pub __align : __BindgenUnionField < :: std :: os :: raw :: c_longlong > , pub bindgen_union_field : [ u64 ; 6usize ] } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct pthread_cond_t__bindgen_ty_1 { pub __lock : :: std :: os :: raw :: c_int , pub __futex : :: std :: os :: raw :: c_uint , pub __total_seq : :: std :: os :: raw :: c_ulonglong , pub __wakeup_seq : :: std :: os :: raw :: c_ulonglong , pub __woken_seq : :: std :: os :: raw :: c_ulonglong , pub __mutex : * mut :: std :: os :: raw :: c_void , pub __nwaiters : :: std :: os :: raw :: c_uint , pub __broadcast_seq : :: std :: os :: raw :: c_uint } # [ test ] fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_cond_t__bindgen_ty_1 > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_cond_t__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) . __lock as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __lock ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) . __futex as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __futex ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) . __total_seq as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __total_seq ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) . __wakeup_seq as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __wakeup_seq ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) . __woken_seq as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __woken_seq ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) . __mutex as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __mutex ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) . __nwaiters as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __nwaiters ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) . __broadcast_seq as * const _ as usize } , 44usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __broadcast_seq ) ) ) ; } impl Clone for pthread_cond_t__bindgen_ty_1 { fn clone ( & self ) -> Self { * self } } # [ test ] fn bindgen_test_layout_pthread_cond_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_cond_t > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( pthread_cond_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_cond_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_cond_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_cond_t ) ) . __data as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::" , stringify ! ( __data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_cond_t ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_cond_t ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::" , stringify ! ( __align ) ) ) ; } impl Clone for pthread_cond_t { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct pthread_condattr_t { pub __size : __BindgenUnionField < [ :: std :: os :: raw :: c_char ; 4usize ] > , pub __align : __BindgenUnionField < :: std :: os :: raw :: c_int > , pub bindgen_union_field : u32 } # [ test ] fn bindgen_test_layout_pthread_condattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_condattr_t > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( pthread_condattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_condattr_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( pthread_condattr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_condattr_t ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_condattr_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_condattr_t ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_condattr_t ) , "::" , stringify ! ( __align ) ) ) ; } impl Clone for pthread_condattr_t { fn clone ( & self ) -> Self { * self } } pub type pthread_key_t = :: std :: os :: raw :: c_uint ; pub type pthread_once_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct pthread_rwlock_t { pub __data : __BindgenUnionField < pthread_rwlock_t__bindgen_ty_1 > , pub __size : __BindgenUnionField < [ :: std :: os :: raw :: c_char ; 56usize ] > , pub __align : __BindgenUnionField < :: std :: os :: raw :: c_long > , pub bindgen_union_field : [ u64 ; 7usize ] } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct pthread_rwlock_t__bindgen_ty_1 { pub __lock : :: std :: os :: raw :: c_int , pub __nr_readers : :: std :: os :: raw :: c_uint , pub __readers_wakeup : :: std :: os :: raw :: c_uint , pub __writer_wakeup : :: std :: os :: raw :: c_uint , pub __nr_readers_queued : :: std :: os :: raw :: c_uint , pub __nr_writers_queued : :: std :: os :: raw :: c_uint , pub __writer : :: std :: os :: raw :: c_int , pub __shared : :: std :: os :: raw :: c_int , pub __rwelision : :: std :: os :: raw :: c_schar , pub __pad1 : [ :: std :: os :: raw :: c_uchar ; 7usize ] , pub __pad2 : :: std :: os :: raw :: c_ulong , pub __flags : :: std :: os :: raw :: c_uint } # [ test ] fn bindgen_test_layout_pthread_rwlock_t__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_rwlock_t__bindgen_ty_1 > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_rwlock_t__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) . __lock as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __lock ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) . __nr_readers as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __nr_readers ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) . __readers_wakeup as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __readers_wakeup ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) . __writer_wakeup as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __writer_wakeup ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) . __nr_readers_queued as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __nr_readers_queued ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) . __nr_writers_queued as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __nr_writers_queued ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) . __writer as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __writer ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) . __shared as * const _ as usize } , 28usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __shared ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) . __rwelision as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __rwelision ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) . __pad1 as * const _ as usize } , 33usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) . __pad2 as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) . __flags as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __flags ) ) ) ; } impl Clone for pthread_rwlock_t__bindgen_ty_1 { fn clone ( & self ) -> Self { * self } } # [ test ] fn bindgen_test_layout_pthread_rwlock_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_rwlock_t > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( pthread_rwlock_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_rwlock_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_rwlock_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_rwlock_t ) ) . __data as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_rwlock_t ) , "::" , stringify ! ( __data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_rwlock_t ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_rwlock_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_rwlock_t ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_rwlock_t ) , "::" , stringify ! ( __align ) ) ) ; } impl Clone for pthread_rwlock_t { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct pthread_rwlockattr_t { pub __size : __BindgenUnionField < [ :: std :: os :: raw :: c_char ; 8usize ] > , pub __align : __BindgenUnionField < :: std :: os :: raw :: c_long > , pub bindgen_union_field : u64 } # [ test ] fn bindgen_test_layout_pthread_rwlockattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_rwlockattr_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( pthread_rwlockattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_rwlockattr_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_rwlockattr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_rwlockattr_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_rwlockattr_t ) , "::" , stringify ! ( __align ) ) ) ; } impl Clone for pthread_rwlockattr_t { fn clone ( & self ) -> Self { * self } } pub type pthread_spinlock_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct pthread_barrier_t { pub __size : __BindgenUnionField < [ :: std :: os :: raw :: c_char ; 32usize ] > , pub __align : __BindgenUnionField < :: std :: os :: raw :: c_long > , pub bindgen_union_field : [ u64 ; 4usize ] } # [ test ] fn bindgen_test_layout_pthread_barrier_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_barrier_t > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( pthread_barrier_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_barrier_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_barrier_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_barrier_t ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_barrier_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_barrier_t ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_barrier_t ) , "::" , stringify ! ( __align ) ) ) ; } impl Clone for pthread_barrier_t { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct pthread_barrierattr_t { pub __size : __BindgenUnionField < [ :: std :: os :: raw :: c_char ; 4usize ] > , pub __align : __BindgenUnionField < :: std :: os :: raw :: c_int > , pub bindgen_union_field : u32 } # [ test ] fn bindgen_test_layout_pthread_barrierattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_barrierattr_t > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( pthread_barrierattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_barrierattr_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( pthread_barrierattr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_barrierattr_t ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_barrierattr_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const pthread_barrierattr_t ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( pthread_barrierattr_t ) , "::" , stringify ! ( __align ) ) ) ; } impl Clone for pthread_barrierattr_t { fn clone ( & self ) -> Self { * self } } pub type __compar_fn_t = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * const :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct __locale_struct { pub __locales : [ * mut __locale_data ; 13usize ] , pub __ctype_b : * const :: std :: os :: raw :: c_ushort , pub __ctype_tolower : * const :: std :: os :: raw :: c_int , pub __ctype_toupper : * const :: std :: os :: raw :: c_int , pub __names : [ * const :: std :: os :: raw :: c_char ; 13usize ] } # [ test ] fn bindgen_test_layout___locale_struct ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __locale_struct > ( ) , 232usize , concat ! ( "Size of: " , stringify ! ( __locale_struct ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __locale_struct > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __locale_struct ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __locale_struct ) ) . __locales as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __locales ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __locale_struct ) ) . __ctype_b as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __ctype_b ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __locale_struct ) ) . __ctype_tolower as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __ctype_tolower ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __locale_struct ) ) . __ctype_toupper as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __ctype_toupper ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __locale_struct ) ) . __names as * const _ as usize } , 128usize , concat ! ( "Alignment of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __names ) ) ) ; } impl Clone for __locale_struct { fn clone ( & self ) -> Self { * self } } pub type __locale_t = * mut __locale_struct ; pub type locale_t = __locale_t ; extern "C" { pub fn av_log2 ( v : :: std :: os :: raw :: c_uint ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_log2_16bit ( v : :: std :: os :: raw :: c_uint ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct max_align_t { pub __clang_max_align_nonce1 : :: std :: os :: raw :: c_longlong , pub __bindgen_padding_0 : u64 , pub __clang_max_align_nonce2 : f64 } # [ test ] fn bindgen_test_layout_max_align_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < max_align_t > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( max_align_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const max_align_t ) ) . __clang_max_align_nonce1 as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( max_align_t ) , "::" , stringify ! ( __clang_max_align_nonce1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const max_align_t ) ) . __clang_max_align_nonce2 as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( max_align_t ) , "::" , stringify ! ( __clang_max_align_nonce2 ) ) ) ; } impl Clone for max_align_t { fn clone ( & self ) -> Self { * self } } extern "C" { pub fn av_strerror ( errnum : :: std :: os :: raw :: c_int , errbuf : * mut :: std :: os :: raw :: c_char , errbuf_size : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_malloc ( size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn av_mallocz ( size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn av_calloc ( nmemb : usize , size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn av_realloc ( ptr : * mut :: std :: os :: raw :: c_void , size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn av_reallocp ( ptr : * mut :: std :: os :: raw :: c_void , size : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_realloc_f ( ptr : * mut :: std :: os :: raw :: c_void , nelem : usize , elsize : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn av_realloc_array ( ptr : * mut :: std :: os :: raw :: c_void , nmemb : usize , size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn av_reallocp_array ( ptr : * mut :: std :: os :: raw :: c_void , nmemb : usize , size : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_fast_realloc ( ptr : * mut :: std :: os :: raw :: c_void , size : * mut :: std :: os :: raw :: c_uint , min_size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn av_fast_malloc ( ptr : * mut :: std :: os :: raw :: c_void , size : * mut :: std :: os :: raw :: c_uint , min_size : usize ) ; } extern "C" { pub fn av_fast_mallocz ( ptr : * mut :: std :: os :: raw :: c_void , size : * mut :: std :: os :: raw :: c_uint , min_size : usize ) ; } extern "C" { pub fn av_free ( ptr : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { pub fn av_freep ( ptr : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { pub fn av_strdup ( s : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn av_strndup ( s : * const :: std :: os :: raw :: c_char , len : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn av_memdup ( p : * const :: std :: os :: raw :: c_void , size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn av_memcpy_backptr ( dst : * mut u8 , back : :: std :: os :: raw :: c_int , cnt : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn av_dynarray_add ( tab_ptr : * mut :: std :: os :: raw :: c_void , nb_ptr : * mut :: std :: os :: raw :: c_int , elem : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { pub fn av_dynarray_add_nofree ( tab_ptr : * mut :: std :: os :: raw :: c_void , nb_ptr : * mut :: std :: os :: raw :: c_int , elem : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_dynarray2_add ( tab_ptr : * mut * mut :: std :: os :: raw :: c_void , nb_ptr : * mut :: std :: os :: raw :: c_int , elem_size : usize , elem_data : * const u8 ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn av_max_alloc ( max : usize ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVRational { pub num : :: std :: os :: raw :: c_int , pub den : :: std :: os :: raw :: c_int } # [ test ] fn bindgen_test_layout_AVRational ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVRational > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( AVRational ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVRational > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( AVRational ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVRational ) ) . num as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVRational ) , "::" , stringify ! ( num ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVRational ) ) . den as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( AVRational ) , "::" , stringify ! ( den ) ) ) ; } impl Clone for AVRational { fn clone ( & self ) -> Self { * self } } extern "C" { pub fn av_reduce ( dst_num : * mut :: std :: os :: raw :: c_int , dst_den : * mut :: std :: os :: raw :: c_int , num : i64 , den : i64 , max : i64 ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_mul_q ( b : AVRational , c : AVRational ) -> AVRational ; } extern "C" { pub fn av_div_q ( b : AVRational , c : AVRational ) -> AVRational ; } extern "C" { pub fn av_add_q ( b : AVRational , c : AVRational ) -> AVRational ; } extern "C" { pub fn av_sub_q ( b : AVRational , c : AVRational ) -> AVRational ; } extern "C" { pub fn av_d2q ( d : f64 , max : :: std :: os :: raw :: c_int ) -> AVRational ; } extern "C" { pub fn av_nearer_q ( q : AVRational , q1 : AVRational , q2 : AVRational ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_find_nearest_q_idx ( q : AVRational , q_list : * const AVRational ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_q2intfloat ( q : AVRational ) -> u32 ; } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum AVRounding { AV_ROUND_ZERO = 0 , AV_ROUND_INF = 1 , AV_ROUND_DOWN = 2 , AV_ROUND_UP = 3 , AV_ROUND_NEAR_INF = 5 , AV_ROUND_PASS_MINMAX = 8192 , } extern "C" { pub fn av_gcd ( a : i64 , b : i64 ) -> i64 ; } extern "C" { pub fn av_rescale ( a : i64 , b : i64 , c : i64 ) -> i64 ; } extern "C" { pub fn av_rescale_rnd ( a : i64 , b : i64 , c : i64 , rnd : AVRounding ) -> i64 ; } extern "C" { pub fn av_rescale_q ( a : i64 , bq : AVRational , cq : AVRational ) -> i64 ; } extern "C" { pub fn av_rescale_q_rnd ( a : i64 , bq : AVRational , cq : AVRational , rnd : AVRounding ) -> i64 ; } extern "C" { pub fn av_compare_ts ( ts_a : i64 , tb_a : AVRational , ts_b : i64 , tb_b : AVRational ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_compare_mod ( a : u64 , b : u64 , mod_ : u64 ) -> i64 ; } extern "C" { pub fn av_rescale_delta ( in_tb : AVRational , in_ts : i64 , fs_tb : AVRational , duration : :: std :: os :: raw :: c_int , last : * mut i64 , out_tb : AVRational ) -> i64 ; } extern "C" { pub fn av_add_stable ( ts_tb : AVRational , ts : i64 , inc_tb : AVRational , inc : i64 ) -> i64 ; } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum AVClassCategory { AV_CLASS_CATEGORY_NA = 0 , AV_CLASS_CATEGORY_INPUT = 1 , AV_CLASS_CATEGORY_OUTPUT = 2 , AV_CLASS_CATEGORY_MUXER = 3 , AV_CLASS_CATEGORY_DEMUXER = 4 , AV_CLASS_CATEGORY_ENCODER = 5 , AV_CLASS_CATEGORY_DECODER = 6 , AV_CLASS_CATEGORY_FILTER = 7 , AV_CLASS_CATEGORY_BITSTREAM_FILTER = 8 , AV_CLASS_CATEGORY_SWSCALER = 9 , AV_CLASS_CATEGORY_SWRESAMPLER = 10 , AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT = 40 , AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT = 41 , AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT = 42 , AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT = 43 , AV_CLASS_CATEGORY_DEVICE_OUTPUT = 44 , AV_CLASS_CATEGORY_DEVICE_INPUT = 45 , AV_CLASS_CATEGORY_NB = 46 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct AVOptionRanges ( [ u8 ; 0 ] ) ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVClass { pub class_name : * const :: std :: os :: raw :: c_char , pub item_name : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void ) -> * const :: std :: os :: raw :: c_char > , pub option : * mut AVOption , pub version : :: std :: os :: raw :: c_int , pub log_level_offset_offset : :: std :: os :: raw :: c_int , pub parent_log_context_offset : :: std :: os :: raw :: c_int , pub child_next : :: std :: option :: Option < unsafe extern "C" fn ( obj : * mut :: std :: os :: raw :: c_void , prev : * mut :: std :: os :: raw :: c_void ) -> * mut :: std :: os :: raw :: c_void > , pub child_class_next : :: std :: option :: Option < unsafe extern "C" fn ( prev : * const AVClass ) -> * const AVClass > , pub category : AVClassCategory , pub get_category : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void ) -> AVClassCategory > , pub query_ranges : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut * mut AVOptionRanges , obj : * mut :: std :: os :: raw :: c_void , key : * const :: std :: os :: raw :: c_char , flags : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > } # [ test ] fn bindgen_test_layout_AVClass ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVClass > ( ) , 80usize , concat ! ( "Size of: " , stringify ! ( AVClass ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVClass > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVClass ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVClass ) ) . class_name as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVClass ) , "::" , stringify ! ( class_name ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVClass ) ) . item_name as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AVClass ) , "::" , stringify ! ( item_name ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVClass ) ) . option as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( AVClass ) , "::" , stringify ! ( option ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVClass ) ) . version as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( AVClass ) , "::" , stringify ! ( version ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVClass ) ) . log_level_offset_offset as * const _ as usize } , 28usize , concat ! ( "Alignment of field: " , stringify ! ( AVClass ) , "::" , stringify ! ( log_level_offset_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVClass ) ) . parent_log_context_offset as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( AVClass ) , "::" , stringify ! ( parent_log_context_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVClass ) ) . child_next as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( AVClass ) , "::" , stringify ! ( child_next ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVClass ) ) . child_class_next as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( AVClass ) , "::" , stringify ! ( child_class_next ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVClass ) ) . category as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( AVClass ) , "::" , stringify ! ( category ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVClass ) ) . get_category as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( AVClass ) , "::" , stringify ! ( get_category ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVClass ) ) . query_ranges as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( AVClass ) , "::" , stringify ! ( query_ranges ) ) ) ; } impl Clone for AVClass { fn clone ( & self ) -> Self { * self } } extern "C" { pub fn av_log ( avcl : * mut :: std :: os :: raw :: c_void , level : :: std :: os :: raw :: c_int , fmt : * const :: std :: os :: raw :: c_char , ... ) ; } extern "C" { pub fn av_vlog ( avcl : * mut :: std :: os :: raw :: c_void , level : :: std :: os :: raw :: c_int , fmt : * const :: std :: os :: raw :: c_char , vl : * mut __va_list_tag ) ; } extern "C" { pub fn av_log_get_level ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_log_set_level ( level : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn av_log_set_callback ( callback : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void , arg2 : :: std :: os :: raw :: c_int , arg3 : * const :: std :: os :: raw :: c_char , arg4 : * mut __va_list_tag ) > ) ; } extern "C" { pub fn av_log_default_callback ( avcl : * mut :: std :: os :: raw :: c_void , level : :: std :: os :: raw :: c_int , fmt : * const :: std :: os :: raw :: c_char , vl : * mut __va_list_tag ) ; } extern "C" { pub fn av_default_item_name ( ctx : * mut :: std :: os :: raw :: c_void ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn av_default_get_category ( ptr : * mut :: std :: os :: raw :: c_void ) -> AVClassCategory ; } extern "C" { pub fn av_log_format_line ( ptr : * mut :: std :: os :: raw :: c_void , level : :: std :: os :: raw :: c_int , fmt : * const :: std :: os :: raw :: c_char , vl : * mut __va_list_tag , line : * mut :: std :: os :: raw :: c_char , line_size : :: std :: os :: raw :: c_int , print_prefix : * mut :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn av_log_format_line2 ( ptr : * mut :: std :: os :: raw :: c_void , level : :: std :: os :: raw :: c_int , fmt : * const :: std :: os :: raw :: c_char , vl : * mut __va_list_tag , line : * mut :: std :: os :: raw :: c_char , line_size : :: std :: os :: raw :: c_int , print_prefix : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_log_set_flags ( arg : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn av_log_get_flags ( ) -> :: std :: os :: raw :: c_int ; } pub const AVPixelFormat_AV_PIX_FMT_XVMC : AVPixelFormat = AVPixelFormat :: AV_PIX_FMT_XVMC_MPEG2_IDCT ; pub const AVPixelFormat_AV_PIX_FMT_VAAPI : AVPixelFormat = AVPixelFormat :: AV_PIX_FMT_VAAPI_VLD ; pub const AVPixelFormat_AV_PIX_FMT_Y400A : AVPixelFormat = AVPixelFormat :: AV_PIX_FMT_YA8 ; pub const AVPixelFormat_AV_PIX_FMT_GRAY8A : AVPixelFormat = AVPixelFormat :: AV_PIX_FMT_YA8 ; pub const AVPixelFormat_AV_PIX_FMT_GBR24P : AVPixelFormat = AVPixelFormat :: AV_PIX_FMT_GBRP ; # [ repr ( i32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum AVPixelFormat { AV_PIX_FMT_NONE = - 1 , AV_PIX_FMT_YUV420P = 0 , AV_PIX_FMT_YUYV422 = 1 , AV_PIX_FMT_RGB24 = 2 , AV_PIX_FMT_BGR24 = 3 , AV_PIX_FMT_YUV422P = 4 , AV_PIX_FMT_YUV444P = 5 , AV_PIX_FMT_YUV410P = 6 , AV_PIX_FMT_YUV411P = 7 , AV_PIX_FMT_GRAY8 = 8 , AV_PIX_FMT_MONOWHITE = 9 , AV_PIX_FMT_MONOBLACK = 10 , AV_PIX_FMT_PAL8 = 11 , AV_PIX_FMT_YUVJ420P = 12 , AV_PIX_FMT_YUVJ422P = 13 , AV_PIX_FMT_YUVJ444P = 14 , AV_PIX_FMT_XVMC_MPEG2_MC = 15 , AV_PIX_FMT_XVMC_MPEG2_IDCT = 16 , AV_PIX_FMT_UYVY422 = 17 , AV_PIX_FMT_UYYVYY411 = 18 , AV_PIX_FMT_BGR8 = 19 , AV_PIX_FMT_BGR4 = 20 , AV_PIX_FMT_BGR4_BYTE = 21 , AV_PIX_FMT_RGB8 = 22 , AV_PIX_FMT_RGB4 = 23 , AV_PIX_FMT_RGB4_BYTE = 24 , AV_PIX_FMT_NV12 = 25 , AV_PIX_FMT_NV21 = 26 , AV_PIX_FMT_ARGB = 27 , AV_PIX_FMT_RGBA = 28 , AV_PIX_FMT_ABGR = 29 , AV_PIX_FMT_BGRA = 30 , AV_PIX_FMT_GRAY16BE = 31 , AV_PIX_FMT_GRAY16LE = 32 , AV_PIX_FMT_YUV440P = 33 , AV_PIX_FMT_YUVJ440P = 34 , AV_PIX_FMT_YUVA420P = 35 , AV_PIX_FMT_VDPAU_H264 = 36 , AV_PIX_FMT_VDPAU_MPEG1 = 37 , AV_PIX_FMT_VDPAU_MPEG2 = 38 , AV_PIX_FMT_VDPAU_WMV3 = 39 , AV_PIX_FMT_VDPAU_VC1 = 40 , AV_PIX_FMT_RGB48BE = 41 , AV_PIX_FMT_RGB48LE = 42 , AV_PIX_FMT_RGB565BE = 43 , AV_PIX_FMT_RGB565LE = 44 , AV_PIX_FMT_RGB555BE = 45 , AV_PIX_FMT_RGB555LE = 46 , AV_PIX_FMT_BGR565BE = 47 , AV_PIX_FMT_BGR565LE = 48 , AV_PIX_FMT_BGR555BE = 49 , AV_PIX_FMT_BGR555LE = 50 , AV_PIX_FMT_VAAPI_MOCO = 51 , AV_PIX_FMT_VAAPI_IDCT = 52 , AV_PIX_FMT_VAAPI_VLD = 53 , AV_PIX_FMT_YUV420P16LE = 54 , AV_PIX_FMT_YUV420P16BE = 55 , AV_PIX_FMT_YUV422P16LE = 56 , AV_PIX_FMT_YUV422P16BE = 57 , AV_PIX_FMT_YUV444P16LE = 58 , AV_PIX_FMT_YUV444P16BE = 59 , AV_PIX_FMT_VDPAU_MPEG4 = 60 , AV_PIX_FMT_DXVA2_VLD = 61 , AV_PIX_FMT_RGB444LE = 62 , AV_PIX_FMT_RGB444BE = 63 , AV_PIX_FMT_BGR444LE = 64 , AV_PIX_FMT_BGR444BE = 65 , AV_PIX_FMT_YA8 = 66 , AV_PIX_FMT_BGR48BE = 67 , AV_PIX_FMT_BGR48LE = 68 , AV_PIX_FMT_YUV420P9BE = 69 , AV_PIX_FMT_YUV420P9LE = 70 , AV_PIX_FMT_YUV420P10BE = 71 , AV_PIX_FMT_YUV420P10LE = 72 , AV_PIX_FMT_YUV422P10BE = 73 , AV_PIX_FMT_YUV422P10LE = 74 , AV_PIX_FMT_YUV444P9BE = 75 , AV_PIX_FMT_YUV444P9LE = 76 , AV_PIX_FMT_YUV444P10BE = 77 , AV_PIX_FMT_YUV444P10LE = 78 , AV_PIX_FMT_YUV422P9BE = 79 , AV_PIX_FMT_YUV422P9LE = 80 , AV_PIX_FMT_VDA_VLD = 81 , AV_PIX_FMT_GBRP = 82 , AV_PIX_FMT_GBRP9BE = 83 , AV_PIX_FMT_GBRP9LE = 84 , AV_PIX_FMT_GBRP10BE = 85 , AV_PIX_FMT_GBRP10LE = 86 , AV_PIX_FMT_GBRP16BE = 87 , AV_PIX_FMT_GBRP16LE = 88 , AV_PIX_FMT_YUVA422P = 89 , AV_PIX_FMT_YUVA444P = 90 , AV_PIX_FMT_YUVA420P9BE = 91 , AV_PIX_FMT_YUVA420P9LE = 92 , AV_PIX_FMT_YUVA422P9BE = 93 , AV_PIX_FMT_YUVA422P9LE = 94 , AV_PIX_FMT_YUVA444P9BE = 95 , AV_PIX_FMT_YUVA444P9LE = 96 , AV_PIX_FMT_YUVA420P10BE = 97 , AV_PIX_FMT_YUVA420P10LE = 98 , AV_PIX_FMT_YUVA422P10BE = 99 , AV_PIX_FMT_YUVA422P10LE = 100 , AV_PIX_FMT_YUVA444P10BE = 101 , AV_PIX_FMT_YUVA444P10LE = 102 , AV_PIX_FMT_YUVA420P16BE = 103 , AV_PIX_FMT_YUVA420P16LE = 104 , AV_PIX_FMT_YUVA422P16BE = 105 , AV_PIX_FMT_YUVA422P16LE = 106 , AV_PIX_FMT_YUVA444P16BE = 107 , AV_PIX_FMT_YUVA444P16LE = 108 , AV_PIX_FMT_VDPAU = 109 , AV_PIX_FMT_XYZ12LE = 110 , AV_PIX_FMT_XYZ12BE = 111 , AV_PIX_FMT_NV16 = 112 , AV_PIX_FMT_NV20LE = 113 , AV_PIX_FMT_NV20BE = 114 , AV_PIX_FMT_RGBA64BE = 115 , AV_PIX_FMT_RGBA64LE = 116 , AV_PIX_FMT_BGRA64BE = 117 , AV_PIX_FMT_BGRA64LE = 118 , AV_PIX_FMT_YVYU422 = 119 , AV_PIX_FMT_VDA = 120 , AV_PIX_FMT_YA16BE = 121 , AV_PIX_FMT_YA16LE = 122 , AV_PIX_FMT_GBRAP = 123 , AV_PIX_FMT_GBRAP16BE = 124 , AV_PIX_FMT_GBRAP16LE = 125 , AV_PIX_FMT_QSV = 126 , AV_PIX_FMT_MMAL = 127 , AV_PIX_FMT_D3D11VA_VLD = 128 , AV_PIX_FMT_CUDA = 129 , AV_PIX_FMT_0RGB = 295 , AV_PIX_FMT_RGB0 = 296 , AV_PIX_FMT_0BGR = 297 , AV_PIX_FMT_BGR0 = 298 , AV_PIX_FMT_YUV420P12BE = 299 , AV_PIX_FMT_YUV420P12LE = 300 , AV_PIX_FMT_YUV420P14BE = 301 , AV_PIX_FMT_YUV420P14LE = 302 , AV_PIX_FMT_YUV422P12BE = 303 , AV_PIX_FMT_YUV422P12LE = 304 , AV_PIX_FMT_YUV422P14BE = 305 , AV_PIX_FMT_YUV422P14LE = 306 , AV_PIX_FMT_YUV444P12BE = 307 , AV_PIX_FMT_YUV444P12LE = 308 , AV_PIX_FMT_YUV444P14BE = 309 , AV_PIX_FMT_YUV444P14LE = 310 , AV_PIX_FMT_GBRP12BE = 311 , AV_PIX_FMT_GBRP12LE = 312 , AV_PIX_FMT_GBRP14BE = 313 , AV_PIX_FMT_GBRP14LE = 314 , AV_PIX_FMT_YUVJ411P = 315 , AV_PIX_FMT_BAYER_BGGR8 = 316 , AV_PIX_FMT_BAYER_RGGB8 = 317 , AV_PIX_FMT_BAYER_GBRG8 = 318 , AV_PIX_FMT_BAYER_GRBG8 = 319 , AV_PIX_FMT_BAYER_BGGR16LE = 320 , AV_PIX_FMT_BAYER_BGGR16BE = 321 , AV_PIX_FMT_BAYER_RGGB16LE = 322 , AV_PIX_FMT_BAYER_RGGB16BE = 323 , AV_PIX_FMT_BAYER_GBRG16LE = 324 , AV_PIX_FMT_BAYER_GBRG16BE = 325 , AV_PIX_FMT_BAYER_GRBG16LE = 326 , AV_PIX_FMT_BAYER_GRBG16BE = 327 , AV_PIX_FMT_YUV440P10LE = 328 , AV_PIX_FMT_YUV440P10BE = 329 , AV_PIX_FMT_YUV440P12LE = 330 , AV_PIX_FMT_YUV440P12BE = 331 , AV_PIX_FMT_AYUV64LE = 332 , AV_PIX_FMT_AYUV64BE = 333 , AV_PIX_FMT_VIDEOTOOLBOX = 334 , AV_PIX_FMT_P010LE = 335 , AV_PIX_FMT_P010BE = 336 , AV_PIX_FMT_GBRAP12BE = 337 , AV_PIX_FMT_GBRAP12LE = 338 , AV_PIX_FMT_GBRAP10BE = 339 , AV_PIX_FMT_GBRAP10LE = 340 , AV_PIX_FMT_MEDIACODEC = 341 , AV_PIX_FMT_GRAY12BE = 342 , AV_PIX_FMT_GRAY12LE = 343 , AV_PIX_FMT_GRAY10BE = 344 , AV_PIX_FMT_GRAY10LE = 345 , AV_PIX_FMT_P016LE = 346 , AV_PIX_FMT_P016BE = 347 , AV_PIX_FMT_NB = 348 , } pub const AVColorPrimaries_AVCOL_PRI_SMPTEST428_1 : AVColorPrimaries = AVColorPrimaries :: AVCOL_PRI_SMPTE428 ; # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum AVColorPrimaries { AVCOL_PRI_RESERVED0 = 0 , AVCOL_PRI_BT709 = 1 , AVCOL_PRI_UNSPECIFIED = 2 , AVCOL_PRI_RESERVED = 3 , AVCOL_PRI_BT470M = 4 , AVCOL_PRI_BT470BG = 5 , AVCOL_PRI_SMPTE170M = 6 , AVCOL_PRI_SMPTE240M = 7 , AVCOL_PRI_FILM = 8 , AVCOL_PRI_BT2020 = 9 , AVCOL_PRI_SMPTE428 = 10 , AVCOL_PRI_SMPTE431 = 11 , AVCOL_PRI_SMPTE432 = 12 , AVCOL_PRI_JEDEC_P22 = 22 , AVCOL_PRI_NB = 23 , } pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTEST2084 : AVColorTransferCharacteristic = AVColorTransferCharacteristic :: AVCOL_TRC_SMPTE2084 ; pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTEST428_1 : AVColorTransferCharacteristic = AVColorTransferCharacteristic :: AVCOL_TRC_SMPTE428 ; # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum AVColorTransferCharacteristic { AVCOL_TRC_RESERVED0 = 0 , AVCOL_TRC_BT709 = 1 , AVCOL_TRC_UNSPECIFIED = 2 , AVCOL_TRC_RESERVED = 3 , AVCOL_TRC_GAMMA22 = 4 , AVCOL_TRC_GAMMA28 = 5 , AVCOL_TRC_SMPTE170M = 6 , AVCOL_TRC_SMPTE240M = 7 , AVCOL_TRC_LINEAR = 8 , AVCOL_TRC_LOG = 9 , AVCOL_TRC_LOG_SQRT = 10 , AVCOL_TRC_IEC61966_2_4 = 11 , AVCOL_TRC_BT1361_ECG = 12 , AVCOL_TRC_IEC61966_2_1 = 13 , AVCOL_TRC_BT2020_10 = 14 , AVCOL_TRC_BT2020_12 = 15 , AVCOL_TRC_SMPTE2084 = 16 , AVCOL_TRC_SMPTE428 = 17 , AVCOL_TRC_ARIB_STD_B67 = 18 , AVCOL_TRC_NB = 19 , } pub const AVColorSpace_AVCOL_SPC_YCOCG : AVColorSpace = AVColorSpace :: AVCOL_SPC_YCGCO ; # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum AVColorSpace { AVCOL_SPC_RGB = 0 , AVCOL_SPC_BT709 = 1 , AVCOL_SPC_UNSPECIFIED = 2 , AVCOL_SPC_RESERVED = 3 , AVCOL_SPC_FCC = 4 , AVCOL_SPC_BT470BG = 5 , AVCOL_SPC_SMPTE170M = 6 , AVCOL_SPC_SMPTE240M = 7 , AVCOL_SPC_YCGCO = 8 , AVCOL_SPC_BT2020_NCL = 9 , AVCOL_SPC_BT2020_CL = 10 , AVCOL_SPC_SMPTE2085 = 11 , AVCOL_SPC_NB = 12 , } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum AVColorRange { AVCOL_RANGE_UNSPECIFIED = 0 , AVCOL_RANGE_MPEG = 1 , AVCOL_RANGE_JPEG = 2 , AVCOL_RANGE_NB = 3 , } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum AVChromaLocation { AVCHROMA_LOC_UNSPECIFIED = 0 , AVCHROMA_LOC_LEFT = 1 , AVCHROMA_LOC_CENTER = 2 , AVCHROMA_LOC_TOPLEFT = 3 , AVCHROMA_LOC_TOP = 4 , AVCHROMA_LOC_BOTTOMLEFT = 5 , AVCHROMA_LOC_BOTTOM = 6 , AVCHROMA_LOC_NB = 7 , } extern "C" { pub fn av_int_list_length_for_size ( elsize : :: std :: os :: raw :: c_uint , list : * const :: std :: os :: raw :: c_void , term : u64 ) -> :: std :: os :: raw :: c_uint ; } extern "C" { pub fn av_fopen_utf8 ( path : * const :: std :: os :: raw :: c_char , mode : * const :: std :: os :: raw :: c_char ) -> * mut FILE ; } extern "C" { pub fn av_get_time_base_q ( ) -> AVRational ; } extern "C" { pub fn av_fourcc_make_string ( buf : * mut :: std :: os :: raw :: c_char , fourcc : u32 ) -> * mut :: std :: os :: raw :: c_char ; } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVComponentDescriptor { pub plane : :: std :: os :: raw :: c_int , pub step : :: std :: os :: raw :: c_int , pub offset : :: std :: os :: raw :: c_int , pub shift : :: std :: os :: raw :: c_int , pub depth : :: std :: os :: raw :: c_int , pub step_minus1 : :: std :: os :: raw :: c_int , pub depth_minus1 : :: std :: os :: raw :: c_int , pub offset_plus1 : :: std :: os :: raw :: c_int } # [ test ] fn bindgen_test_layout_AVComponentDescriptor ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVComponentDescriptor > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( AVComponentDescriptor ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVComponentDescriptor > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( AVComponentDescriptor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVComponentDescriptor ) ) . plane as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVComponentDescriptor ) , "::" , stringify ! ( plane ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVComponentDescriptor ) ) . step as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( AVComponentDescriptor ) , "::" , stringify ! ( step ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVComponentDescriptor ) ) . offset as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AVComponentDescriptor ) , "::" , stringify ! ( offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVComponentDescriptor ) ) . shift as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( AVComponentDescriptor ) , "::" , stringify ! ( shift ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVComponentDescriptor ) ) . depth as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( AVComponentDescriptor ) , "::" , stringify ! ( depth ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVComponentDescriptor ) ) . step_minus1 as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( AVComponentDescriptor ) , "::" , stringify ! ( step_minus1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVComponentDescriptor ) ) . depth_minus1 as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( AVComponentDescriptor ) , "::" , stringify ! ( depth_minus1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVComponentDescriptor ) ) . offset_plus1 as * const _ as usize } , 28usize , concat ! ( "Alignment of field: " , stringify ! ( AVComponentDescriptor ) , "::" , stringify ! ( offset_plus1 ) ) ) ; } impl Clone for AVComponentDescriptor { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVPixFmtDescriptor { pub name : * const :: std :: os :: raw :: c_char , pub nb_components : u8 , pub log2_chroma_w : u8 , pub log2_chroma_h : u8 , pub flags : u64 , pub comp : [ AVComponentDescriptor ; 4usize ] , pub alias : * const :: std :: os :: raw :: c_char } # [ test ] fn bindgen_test_layout_AVPixFmtDescriptor ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVPixFmtDescriptor > ( ) , 160usize , concat ! ( "Size of: " , stringify ! ( AVPixFmtDescriptor ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVPixFmtDescriptor > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVPixFmtDescriptor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVPixFmtDescriptor ) ) . name as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVPixFmtDescriptor ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVPixFmtDescriptor ) ) . nb_components as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AVPixFmtDescriptor ) , "::" , stringify ! ( nb_components ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVPixFmtDescriptor ) ) . log2_chroma_w as * const _ as usize } , 9usize , concat ! ( "Alignment of field: " , stringify ! ( AVPixFmtDescriptor ) , "::" , stringify ! ( log2_chroma_w ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVPixFmtDescriptor ) ) . log2_chroma_h as * const _ as usize } , 10usize , concat ! ( "Alignment of field: " , stringify ! ( AVPixFmtDescriptor ) , "::" , stringify ! ( log2_chroma_h ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVPixFmtDescriptor ) ) . flags as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( AVPixFmtDescriptor ) , "::" , stringify ! ( flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVPixFmtDescriptor ) ) . comp as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( AVPixFmtDescriptor ) , "::" , stringify ! ( comp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVPixFmtDescriptor ) ) . alias as * const _ as usize } , 152usize , concat ! ( "Alignment of field: " , stringify ! ( AVPixFmtDescriptor ) , "::" , stringify ! ( alias ) ) ) ; } impl Clone for AVPixFmtDescriptor { fn clone ( & self ) -> Self { * self } } extern "C" { pub fn av_get_bits_per_pixel ( pixdesc : * const AVPixFmtDescriptor ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_get_padded_bits_per_pixel ( pixdesc : * const AVPixFmtDescriptor ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_pix_fmt_desc_get ( pix_fmt : AVPixelFormat ) -> * const AVPixFmtDescriptor ; } extern "C" { pub fn av_pix_fmt_desc_next ( prev : * const AVPixFmtDescriptor ) -> * const AVPixFmtDescriptor ; } extern "C" { pub fn av_pix_fmt_desc_get_id ( desc : * const AVPixFmtDescriptor ) -> AVPixelFormat ; } extern "C" { pub fn av_pix_fmt_get_chroma_sub_sample ( pix_fmt : AVPixelFormat , h_shift : * mut :: std :: os :: raw :: c_int , v_shift : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_pix_fmt_count_planes ( pix_fmt : AVPixelFormat ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_color_range_name ( range : AVColorRange ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn av_color_primaries_name ( primaries : AVColorPrimaries ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn av_color_transfer_name ( transfer : AVColorTransferCharacteristic ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn av_color_space_name ( space : AVColorSpace ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn av_chroma_location_name ( location : AVChromaLocation ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn av_get_pix_fmt ( name : * const :: std :: os :: raw :: c_char ) -> AVPixelFormat ; } extern "C" { pub fn av_get_pix_fmt_name ( pix_fmt : AVPixelFormat ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn av_get_pix_fmt_string ( buf : * mut :: std :: os :: raw :: c_char , buf_size : :: std :: os :: raw :: c_int , pix_fmt : AVPixelFormat ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn av_read_image_line ( dst : * mut u16 , data : * mut * const u8 , linesize : * const :: std :: os :: raw :: c_int , desc : * const AVPixFmtDescriptor , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , c : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , read_pal_component : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn av_write_image_line ( src : * const u16 , data : * mut * mut u8 , linesize : * const :: std :: os :: raw :: c_int , desc : * const AVPixFmtDescriptor , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , c : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn av_pix_fmt_swap_endianness ( pix_fmt : AVPixelFormat ) -> AVPixelFormat ; } extern "C" { pub fn av_get_pix_fmt_loss ( dst_pix_fmt : AVPixelFormat , src_pix_fmt : AVPixelFormat , has_alpha : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_find_best_pix_fmt_of_2 ( dst_pix_fmt1 : AVPixelFormat , dst_pix_fmt2 : AVPixelFormat , src_pix_fmt : AVPixelFormat , has_alpha : :: std :: os :: raw :: c_int , loss_ptr : * mut :: std :: os :: raw :: c_int ) -> AVPixelFormat ; } extern "C" { pub fn av_image_fill_max_pixsteps ( max_pixsteps : * mut :: std :: os :: raw :: c_int , max_pixstep_comps : * mut :: std :: os :: raw :: c_int , pixdesc : * const AVPixFmtDescriptor ) ; } extern "C" { pub fn av_image_get_linesize ( pix_fmt : AVPixelFormat , width : :: std :: os :: raw :: c_int , plane : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_image_fill_linesizes ( linesizes : * mut :: std :: os :: raw :: c_int , pix_fmt : AVPixelFormat , width : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_image_fill_pointers ( data : * mut * mut u8 , pix_fmt : AVPixelFormat , height : :: std :: os :: raw :: c_int , ptr : * mut u8 , linesizes : * const :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_image_alloc ( pointers : * mut * mut u8 , linesizes : * mut :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , pix_fmt : AVPixelFormat , align : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_image_copy_plane ( dst : * mut u8 , dst_linesize : :: std :: os :: raw :: c_int , src : * const u8 , src_linesize : :: std :: os :: raw :: c_int , bytewidth : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn av_image_copy ( dst_data : * mut * mut u8 , dst_linesizes : * mut :: std :: os :: raw :: c_int , src_data : * mut * const u8 , src_linesizes : * const :: std :: os :: raw :: c_int , pix_fmt : AVPixelFormat , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn av_image_copy_uc_from ( dst_data : * mut * mut u8 , dst_linesizes : * const isize , src_data : * mut * const u8 , src_linesizes : * const isize , pix_fmt : AVPixelFormat , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn av_image_fill_arrays ( dst_data : * mut * mut u8 , dst_linesize : * mut :: std :: os :: raw :: c_int , src : * const u8 , pix_fmt : AVPixelFormat , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , align : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_image_get_buffer_size ( pix_fmt : AVPixelFormat , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , align : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_image_copy_to_buffer ( dst : * mut u8 , dst_size : :: std :: os :: raw :: c_int , src_data : * const * const u8 , src_linesize : * const :: std :: os :: raw :: c_int , pix_fmt : AVPixelFormat , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , align : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_image_check_size ( w : :: std :: os :: raw :: c_uint , h : :: std :: os :: raw :: c_uint , log_offset : :: std :: os :: raw :: c_int , log_ctx : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_image_check_size2 ( w : :: std :: os :: raw :: c_uint , h : :: std :: os :: raw :: c_uint , max_pixels : i64 , pix_fmt : AVPixelFormat , log_offset : :: std :: os :: raw :: c_int , log_ctx : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_image_check_sar ( w : :: std :: os :: raw :: c_uint , h : :: std :: os :: raw :: c_uint , sar : AVRational ) -> :: std :: os :: raw :: c_int ; } # [ repr ( i32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum AVSampleFormat { AV_SAMPLE_FMT_NONE = - 1 , AV_SAMPLE_FMT_U8 = 0 , AV_SAMPLE_FMT_S16 = 1 , AV_SAMPLE_FMT_S32 = 2 , AV_SAMPLE_FMT_FLT = 3 , AV_SAMPLE_FMT_DBL = 4 , AV_SAMPLE_FMT_U8P = 5 , AV_SAMPLE_FMT_S16P = 6 , AV_SAMPLE_FMT_S32P = 7 , AV_SAMPLE_FMT_FLTP = 8 , AV_SAMPLE_FMT_DBLP = 9 , AV_SAMPLE_FMT_S64 = 10 , AV_SAMPLE_FMT_S64P = 11 , AV_SAMPLE_FMT_NB = 12 , } extern "C" { pub fn av_get_sample_fmt_name ( sample_fmt : AVSampleFormat ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn av_get_sample_fmt ( name : * const :: std :: os :: raw :: c_char ) -> AVSampleFormat ; } extern "C" { pub fn av_get_alt_sample_fmt ( sample_fmt : AVSampleFormat , planar : :: std :: os :: raw :: c_int ) -> AVSampleFormat ; } extern "C" { pub fn av_get_packed_sample_fmt ( sample_fmt : AVSampleFormat ) -> AVSampleFormat ; } extern "C" { pub fn av_get_planar_sample_fmt ( sample_fmt : AVSampleFormat ) -> AVSampleFormat ; } extern "C" { pub fn av_get_sample_fmt_string ( buf : * mut :: std :: os :: raw :: c_char , buf_size : :: std :: os :: raw :: c_int , sample_fmt : AVSampleFormat ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn av_get_bytes_per_sample ( sample_fmt : AVSampleFormat ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_sample_fmt_is_planar ( sample_fmt : AVSampleFormat ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_samples_get_buffer_size ( linesize : * mut :: std :: os :: raw :: c_int , nb_channels : :: std :: os :: raw :: c_int , nb_samples : :: std :: os :: raw :: c_int , sample_fmt : AVSampleFormat , align : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_samples_fill_arrays ( audio_data : * mut * mut u8 , linesize : * mut :: std :: os :: raw :: c_int , buf : * const u8 , nb_channels : :: std :: os :: raw :: c_int , nb_samples : :: std :: os :: raw :: c_int , sample_fmt : AVSampleFormat , align : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_samples_alloc ( audio_data : * mut * mut u8 , linesize : * mut :: std :: os :: raw :: c_int , nb_channels : :: std :: os :: raw :: c_int , nb_samples : :: std :: os :: raw :: c_int , sample_fmt : AVSampleFormat , align : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_samples_alloc_array_and_samples ( audio_data : * mut * mut * mut u8 , linesize : * mut :: std :: os :: raw :: c_int , nb_channels : :: std :: os :: raw :: c_int , nb_samples : :: std :: os :: raw :: c_int , sample_fmt : AVSampleFormat , align : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_samples_copy ( dst : * mut * mut u8 , src : * const * const u8 , dst_offset : :: std :: os :: raw :: c_int , src_offset : :: std :: os :: raw :: c_int , nb_samples : :: std :: os :: raw :: c_int , nb_channels : :: std :: os :: raw :: c_int , sample_fmt : AVSampleFormat ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_samples_set_silence ( audio_data : * mut * mut u8 , offset : :: std :: os :: raw :: c_int , nb_samples : :: std :: os :: raw :: c_int , nb_channels : :: std :: os :: raw :: c_int , sample_fmt : AVSampleFormat ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct AVBuffer ( [ u8 ; 0 ] ) ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVBufferRef { pub buffer : * mut AVBuffer , pub data : * mut u8 , pub size : :: std :: os :: raw :: c_int } # [ test ] fn bindgen_test_layout_AVBufferRef ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVBufferRef > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( AVBufferRef ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVBufferRef > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVBufferRef ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVBufferRef ) ) . buffer as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVBufferRef ) , "::" , stringify ! ( buffer ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVBufferRef ) ) . data as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AVBufferRef ) , "::" , stringify ! ( data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVBufferRef ) ) . size as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( AVBufferRef ) , "::" , stringify ! ( size ) ) ) ; } impl Clone for AVBufferRef { fn clone ( & self ) -> Self { * self } } extern "C" { pub fn av_buffer_alloc ( size : :: std :: os :: raw :: c_int ) -> * mut AVBufferRef ; } extern "C" { pub fn av_buffer_allocz ( size : :: std :: os :: raw :: c_int ) -> * mut AVBufferRef ; } extern "C" { pub fn av_buffer_create ( data : * mut u8 , size : :: std :: os :: raw :: c_int , free : :: std :: option :: Option < unsafe extern "C" fn ( opaque : * mut :: std :: os :: raw :: c_void , data : * mut u8 ) > , opaque : * mut :: std :: os :: raw :: c_void , flags : :: std :: os :: raw :: c_int ) -> * mut AVBufferRef ; } extern "C" { pub fn av_buffer_default_free ( opaque : * mut :: std :: os :: raw :: c_void , data : * mut u8 ) ; } extern "C" { pub fn av_buffer_ref ( buf : * mut AVBufferRef ) -> * mut AVBufferRef ; } extern "C" { pub fn av_buffer_unref ( buf : * mut * mut AVBufferRef ) ; } extern "C" { pub fn av_buffer_is_writable ( buf : * const AVBufferRef ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_buffer_get_opaque ( buf : * const AVBufferRef ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn av_buffer_get_ref_count ( buf : * const AVBufferRef ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_buffer_make_writable ( buf : * mut * mut AVBufferRef ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_buffer_realloc ( buf : * mut * mut AVBufferRef , size : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct AVBufferPool ( [ u8 ; 0 ] ) ; extern "C" { pub fn av_buffer_pool_init ( size : :: std :: os :: raw :: c_int , alloc : :: std :: option :: Option < unsafe extern "C" fn ( size : :: std :: os :: raw :: c_int ) -> * mut AVBufferRef > ) -> * mut AVBufferPool ; } extern "C" { pub fn av_buffer_pool_init2 ( size : :: std :: os :: raw :: c_int , opaque : * mut :: std :: os :: raw :: c_void , alloc : :: std :: option :: Option < unsafe extern "C" fn ( opaque : * mut :: std :: os :: raw :: c_void , size : :: std :: os :: raw :: c_int ) -> * mut AVBufferRef > , pool_free : :: std :: option :: Option < unsafe extern "C" fn ( opaque : * mut :: std :: os :: raw :: c_void ) > ) -> * mut AVBufferPool ; } extern "C" { pub fn av_buffer_pool_uninit ( pool : * mut * mut AVBufferPool ) ; } extern "C" { pub fn av_buffer_pool_get ( pool : * mut AVBufferPool ) -> * mut AVBufferRef ; } extern "C" { pub fn av_get_cpu_flags ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_force_cpu_flags ( flags : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn av_set_cpu_flags_mask ( mask : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn av_parse_cpu_flags ( s : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_parse_cpu_caps ( flags : * mut :: std :: os :: raw :: c_uint , s : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_cpu_count ( ) -> :: std :: os :: raw :: c_int ; } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum AVMatrixEncoding { AV_MATRIX_ENCODING_NONE = 0 , AV_MATRIX_ENCODING_DOLBY = 1 , AV_MATRIX_ENCODING_DPLII = 2 , AV_MATRIX_ENCODING_DPLIIX = 3 , AV_MATRIX_ENCODING_DPLIIZ = 4 , AV_MATRIX_ENCODING_DOLBYEX = 5 , AV_MATRIX_ENCODING_DOLBYHEADPHONE = 6 , AV_MATRIX_ENCODING_NB = 7 , } extern "C" { pub fn av_get_channel_layout ( name : * const :: std :: os :: raw :: c_char ) -> u64 ; } extern "C" { pub fn av_get_extended_channel_layout ( name : * const :: std :: os :: raw :: c_char , channel_layout : * mut u64 , nb_channels : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_get_channel_layout_string ( buf : * mut :: std :: os :: raw :: c_char , buf_size : :: std :: os :: raw :: c_int , nb_channels : :: std :: os :: raw :: c_int , channel_layout : u64 ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct AVBPrint ( [ u8 ; 0 ] ) ; extern "C" { pub fn av_bprint_channel_layout ( bp : * mut AVBPrint , nb_channels : :: std :: os :: raw :: c_int , channel_layout : u64 ) ; } extern "C" { pub fn av_get_channel_layout_nb_channels ( channel_layout : u64 ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_get_default_channel_layout ( nb_channels : :: std :: os :: raw :: c_int ) -> i64 ; } extern "C" { pub fn av_get_channel_layout_channel_index ( channel_layout : u64 , channel : u64 ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_channel_layout_extract_channel ( channel_layout : u64 , index : :: std :: os :: raw :: c_int ) -> u64 ; } extern "C" { pub fn av_get_channel_name ( channel : u64 ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn av_get_channel_description ( channel : u64 ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn av_get_standard_channel_layout ( index : :: std :: os :: raw :: c_uint , layout : * mut u64 , name : * mut * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVDictionaryEntry { pub key : * mut :: std :: os :: raw :: c_char , pub value : * mut :: std :: os :: raw :: c_char } # [ test ] fn bindgen_test_layout_AVDictionaryEntry ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVDictionaryEntry > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( AVDictionaryEntry ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVDictionaryEntry > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVDictionaryEntry ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVDictionaryEntry ) ) . key as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVDictionaryEntry ) , "::" , stringify ! ( key ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVDictionaryEntry ) ) . value as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AVDictionaryEntry ) , "::" , stringify ! ( value ) ) ) ; } impl Clone for AVDictionaryEntry { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct AVDictionary ( [ u8 ; 0 ] ) ; extern "C" { pub fn av_dict_get ( m : * const AVDictionary , key : * const :: std :: os :: raw :: c_char , prev : * const AVDictionaryEntry , flags : :: std :: os :: raw :: c_int ) -> * mut AVDictionaryEntry ; } extern "C" { pub fn av_dict_count ( m : * const AVDictionary ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_dict_set ( pm : * mut * mut AVDictionary , key : * const :: std :: os :: raw :: c_char , value : * const :: std :: os :: raw :: c_char , flags : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_dict_set_int ( pm : * mut * mut AVDictionary , key : * const :: std :: os :: raw :: c_char , value : i64 , flags : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_dict_parse_string ( pm : * mut * mut AVDictionary , str : * const :: std :: os :: raw :: c_char , key_val_sep : * const :: std :: os :: raw :: c_char , pairs_sep : * const :: std :: os :: raw :: c_char , flags : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_dict_copy ( dst : * mut * mut AVDictionary , src : * const AVDictionary , flags : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_dict_free ( m : * mut * mut AVDictionary ) ; } extern "C" { pub fn av_dict_get_string ( m : * const AVDictionary , buffer : * mut * mut :: std :: os :: raw :: c_char , key_val_sep : :: std :: os :: raw :: c_char , pairs_sep : :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum AVFrameSideDataType { AV_FRAME_DATA_PANSCAN = 0 , AV_FRAME_DATA_A53_CC = 1 , AV_FRAME_DATA_STEREO3D = 2 , AV_FRAME_DATA_MATRIXENCODING = 3 , AV_FRAME_DATA_DOWNMIX_INFO = 4 , AV_FRAME_DATA_REPLAYGAIN = 5 , AV_FRAME_DATA_DISPLAYMATRIX = 6 , AV_FRAME_DATA_AFD = 7 , AV_FRAME_DATA_MOTION_VECTORS = 8 , AV_FRAME_DATA_SKIP_SAMPLES = 9 , AV_FRAME_DATA_AUDIO_SERVICE_TYPE = 10 , AV_FRAME_DATA_MASTERING_DISPLAY_METADATA = 11 , AV_FRAME_DATA_GOP_TIMECODE = 12 , AV_FRAME_DATA_SPHERICAL = 13 , } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum AVActiveFormatDescription { AV_AFD_SAME = 8 , AV_AFD_4_3 = 9 , AV_AFD_16_9 = 10 , AV_AFD_14_9 = 11 , AV_AFD_4_3_SP_14_9 = 13 , AV_AFD_16_9_SP_14_9 = 14 , AV_AFD_SP_4_3 = 15 , } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVFrameSideData { pub type_ : AVFrameSideDataType , pub data : * mut u8 , pub size : :: std :: os :: raw :: c_int , pub metadata : * mut AVDictionary , pub buf : * mut AVBufferRef } # [ test ] fn bindgen_test_layout_AVFrameSideData ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVFrameSideData > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( AVFrameSideData ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVFrameSideData > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVFrameSideData ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrameSideData ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrameSideData ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrameSideData ) ) . data as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrameSideData ) , "::" , stringify ! ( data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrameSideData ) ) . size as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrameSideData ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrameSideData ) ) . metadata as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrameSideData ) , "::" , stringify ! ( metadata ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrameSideData ) ) . buf as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrameSideData ) , "::" , stringify ! ( buf ) ) ) ; } impl Clone for AVFrameSideData { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVFrame { pub data : [ * mut u8 ; 8usize ] , pub linesize : [ :: std :: os :: raw :: c_int ; 8usize ] , pub extended_data : * mut * mut u8 , pub width : :: std :: os :: raw :: c_int , pub height : :: std :: os :: raw :: c_int , pub nb_samples : :: std :: os :: raw :: c_int , pub format : :: std :: os :: raw :: c_int , pub key_frame : :: std :: os :: raw :: c_int , pub pict_type : AVPictureType , pub sample_aspect_ratio : AVRational , pub pts : i64 , pub pkt_pts : i64 , pub pkt_dts : i64 , pub coded_picture_number : :: std :: os :: raw :: c_int , pub display_picture_number : :: std :: os :: raw :: c_int , pub quality : :: std :: os :: raw :: c_int , pub opaque : * mut :: std :: os :: raw :: c_void , pub error : [ u64 ; 8usize ] , pub repeat_pict : :: std :: os :: raw :: c_int , pub interlaced_frame : :: std :: os :: raw :: c_int , pub top_field_first : :: std :: os :: raw :: c_int , pub palette_has_changed : :: std :: os :: raw :: c_int , pub reordered_opaque : i64 , pub sample_rate : :: std :: os :: raw :: c_int , pub channel_layout : u64 , pub buf : [ * mut AVBufferRef ; 8usize ] , pub extended_buf : * mut * mut AVBufferRef , pub nb_extended_buf : :: std :: os :: raw :: c_int , pub side_data : * mut * mut AVFrameSideData , pub nb_side_data : :: std :: os :: raw :: c_int , pub flags : :: std :: os :: raw :: c_int , pub color_range : AVColorRange , pub color_primaries : AVColorPrimaries , pub color_trc : AVColorTransferCharacteristic , pub colorspace : AVColorSpace , pub chroma_location : AVChromaLocation , pub best_effort_timestamp : i64 , pub pkt_pos : i64 , pub pkt_duration : i64 , pub metadata : * mut AVDictionary , pub decode_error_flags : :: std :: os :: raw :: c_int , pub channels : :: std :: os :: raw :: c_int , pub pkt_size : :: std :: os :: raw :: c_int , pub qscale_table : * mut i8 , pub qstride : :: std :: os :: raw :: c_int , pub qscale_type : :: std :: os :: raw :: c_int , pub qp_table_buf : * mut AVBufferRef , pub hw_frames_ctx : * mut AVBufferRef , pub opaque_ref : * mut AVBufferRef } # [ test ] fn bindgen_test_layout_AVFrame ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVFrame > ( ) , 496usize , concat ! ( "Size of: " , stringify ! ( AVFrame ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVFrame > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVFrame ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . data as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . linesize as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( linesize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . extended_data as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( extended_data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . width as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( width ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . height as * const _ as usize } , 108usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( height ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . nb_samples as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( nb_samples ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . format as * const _ as usize } , 116usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( format ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . key_frame as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( key_frame ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . pict_type as * const _ as usize } , 124usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( pict_type ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . sample_aspect_ratio as * const _ as usize } , 128usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( sample_aspect_ratio ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . pts as * const _ as usize } , 136usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( pts ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . pkt_pts as * const _ as usize } , 144usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( pkt_pts ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . pkt_dts as * const _ as usize } , 152usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( pkt_dts ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . coded_picture_number as * const _ as usize } , 160usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( coded_picture_number ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . display_picture_number as * const _ as usize } , 164usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( display_picture_number ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . quality as * const _ as usize } , 168usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( quality ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . opaque as * const _ as usize } , 176usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( opaque ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . error as * const _ as usize } , 184usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( error ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . repeat_pict as * const _ as usize } , 248usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( repeat_pict ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . interlaced_frame as * const _ as usize } , 252usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( interlaced_frame ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . top_field_first as * const _ as usize } , 256usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( top_field_first ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . palette_has_changed as * const _ as usize } , 260usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( palette_has_changed ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . reordered_opaque as * const _ as usize } , 264usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( reordered_opaque ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . sample_rate as * const _ as usize } , 272usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( sample_rate ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . channel_layout as * const _ as usize } , 280usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( channel_layout ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . buf as * const _ as usize } , 288usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( buf ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . extended_buf as * const _ as usize } , 352usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( extended_buf ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . nb_extended_buf as * const _ as usize } , 360usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( nb_extended_buf ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . side_data as * const _ as usize } , 368usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( side_data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . nb_side_data as * const _ as usize } , 376usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( nb_side_data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . flags as * const _ as usize } , 380usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . color_range as * const _ as usize } , 384usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( color_range ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . color_primaries as * const _ as usize } , 388usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( color_primaries ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . color_trc as * const _ as usize } , 392usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( color_trc ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . colorspace as * const _ as usize } , 396usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( colorspace ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . chroma_location as * const _ as usize } , 400usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( chroma_location ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . best_effort_timestamp as * const _ as usize } , 408usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( best_effort_timestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . pkt_pos as * const _ as usize } , 416usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( pkt_pos ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . pkt_duration as * const _ as usize } , 424usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( pkt_duration ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . metadata as * const _ as usize } , 432usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( metadata ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . decode_error_flags as * const _ as usize } , 440usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( decode_error_flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . channels as * const _ as usize } , 444usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( channels ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . pkt_size as * const _ as usize } , 448usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( pkt_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . qscale_table as * const _ as usize } , 456usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( qscale_table ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . qstride as * const _ as usize } , 464usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( qstride ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . qscale_type as * const _ as usize } , 468usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( qscale_type ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . qp_table_buf as * const _ as usize } , 472usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( qp_table_buf ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . hw_frames_ctx as * const _ as usize } , 480usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( hw_frames_ctx ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrame ) ) . opaque_ref as * const _ as usize } , 488usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrame ) , "::" , stringify ! ( opaque_ref ) ) ) ; } impl Clone for AVFrame { fn clone ( & self ) -> Self { * self } } extern "C" { pub fn av_frame_get_best_effort_timestamp ( frame : * const AVFrame ) -> i64 ; } extern "C" { pub fn av_frame_set_best_effort_timestamp ( frame : * mut AVFrame , val : i64 ) ; } extern "C" { pub fn av_frame_get_pkt_duration ( frame : * const AVFrame ) -> i64 ; } extern "C" { pub fn av_frame_set_pkt_duration ( frame : * mut AVFrame , val : i64 ) ; } extern "C" { pub fn av_frame_get_pkt_pos ( frame : * const AVFrame ) -> i64 ; } extern "C" { pub fn av_frame_set_pkt_pos ( frame : * mut AVFrame , val : i64 ) ; } extern "C" { pub fn av_frame_get_channel_layout ( frame : * const AVFrame ) -> i64 ; } extern "C" { pub fn av_frame_set_channel_layout ( frame : * mut AVFrame , val : i64 ) ; } extern "C" { pub fn av_frame_get_channels ( frame : * const AVFrame ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_frame_set_channels ( frame : * mut AVFrame , val : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn av_frame_get_sample_rate ( frame : * const AVFrame ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_frame_set_sample_rate ( frame : * mut AVFrame , val : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn av_frame_get_metadata ( frame : * const AVFrame ) -> * mut AVDictionary ; } extern "C" { pub fn av_frame_set_metadata ( frame : * mut AVFrame , val : * mut AVDictionary ) ; } extern "C" { pub fn av_frame_get_decode_error_flags ( frame : * const AVFrame ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_frame_set_decode_error_flags ( frame : * mut AVFrame , val : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn av_frame_get_pkt_size ( frame : * const AVFrame ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_frame_set_pkt_size ( frame : * mut AVFrame , val : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn avpriv_frame_get_metadatap ( frame : * mut AVFrame ) -> * mut * mut AVDictionary ; } extern "C" { pub fn av_frame_get_qp_table ( f : * mut AVFrame , stride : * mut :: std :: os :: raw :: c_int , type_ : * mut :: std :: os :: raw :: c_int ) -> * mut i8 ; } extern "C" { pub fn av_frame_set_qp_table ( f : * mut AVFrame , buf : * mut AVBufferRef , stride : :: std :: os :: raw :: c_int , type_ : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_frame_get_colorspace ( frame : * const AVFrame ) -> AVColorSpace ; } extern "C" { pub fn av_frame_set_colorspace ( frame : * mut AVFrame , val : AVColorSpace ) ; } extern "C" { pub fn av_frame_get_color_range ( frame : * const AVFrame ) -> AVColorRange ; } extern "C" { pub fn av_frame_set_color_range ( frame : * mut AVFrame , val : AVColorRange ) ; } extern "C" { pub fn av_get_colorspace_name ( val : AVColorSpace ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn av_frame_alloc ( ) -> * mut AVFrame ; } extern "C" { pub fn av_frame_free ( frame : * mut * mut AVFrame ) ; } extern "C" { pub fn av_frame_ref ( dst : * mut AVFrame , src : * const AVFrame ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_frame_clone ( src : * const AVFrame ) -> * mut AVFrame ; } extern "C" { pub fn av_frame_unref ( frame : * mut AVFrame ) ; } extern "C" { pub fn av_frame_move_ref ( dst : * mut AVFrame , src : * mut AVFrame ) ; } extern "C" { pub fn av_frame_get_buffer ( frame : * mut AVFrame , align : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_frame_is_writable ( frame : * mut AVFrame ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_frame_make_writable ( frame : * mut AVFrame ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_frame_copy ( dst : * mut AVFrame , src : * const AVFrame ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_frame_copy_props ( dst : * mut AVFrame , src : * const AVFrame ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_frame_get_plane_buffer ( frame : * mut AVFrame , plane : :: std :: os :: raw :: c_int ) -> * mut AVBufferRef ; } extern "C" { pub fn av_frame_new_side_data ( frame : * mut AVFrame , type_ : AVFrameSideDataType , size : :: std :: os :: raw :: c_int ) -> * mut AVFrameSideData ; } extern "C" { pub fn av_frame_get_side_data ( frame : * const AVFrame , type_ : AVFrameSideDataType ) -> * mut AVFrameSideData ; } extern "C" { pub fn av_frame_remove_side_data ( frame : * mut AVFrame , type_ : AVFrameSideDataType ) ; } extern "C" { pub fn av_frame_side_data_name ( type_ : AVFrameSideDataType ) -> * const :: std :: os :: raw :: c_char ; } pub const AVCodecID_AV_CODEC_ID_PCM_S16LE : AVCodecID = AVCodecID :: AV_CODEC_ID_FIRST_AUDIO ; pub const AVCodecID_AV_CODEC_ID_VIMA : AVCodecID = AVCodecID :: AV_CODEC_ID_ADPCM_VIMA ; pub const AVCodecID_AV_CODEC_ID_DVD_SUBTITLE : AVCodecID = AVCodecID :: AV_CODEC_ID_FIRST_SUBTITLE ; pub const AVCodecID_AV_CODEC_ID_TTF : AVCodecID = AVCodecID :: AV_CODEC_ID_FIRST_UNKNOWN ; # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum AVCodecID { AV_CODEC_ID_NONE = 0 , AV_CODEC_ID_MPEG1VIDEO = 1 , AV_CODEC_ID_MPEG2VIDEO = 2 , AV_CODEC_ID_MPEG2VIDEO_XVMC = 3 , AV_CODEC_ID_H261 = 4 , AV_CODEC_ID_H263 = 5 , AV_CODEC_ID_RV10 = 6 , AV_CODEC_ID_RV20 = 7 , AV_CODEC_ID_MJPEG = 8 , AV_CODEC_ID_MJPEGB = 9 , AV_CODEC_ID_LJPEG = 10 , AV_CODEC_ID_SP5X = 11 , AV_CODEC_ID_JPEGLS = 12 , AV_CODEC_ID_MPEG4 = 13 , AV_CODEC_ID_RAWVIDEO = 14 , AV_CODEC_ID_MSMPEG4V1 = 15 , AV_CODEC_ID_MSMPEG4V2 = 16 , AV_CODEC_ID_MSMPEG4V3 = 17 , AV_CODEC_ID_WMV1 = 18 , AV_CODEC_ID_WMV2 = 19 , AV_CODEC_ID_H263P = 20 , AV_CODEC_ID_H263I = 21 , AV_CODEC_ID_FLV1 = 22 , AV_CODEC_ID_SVQ1 = 23 , AV_CODEC_ID_SVQ3 = 24 , AV_CODEC_ID_DVVIDEO = 25 , AV_CODEC_ID_HUFFYUV = 26 , AV_CODEC_ID_CYUV = 27 , AV_CODEC_ID_H264 = 28 , AV_CODEC_ID_INDEO3 = 29 , AV_CODEC_ID_VP3 = 30 , AV_CODEC_ID_THEORA = 31 , AV_CODEC_ID_ASV1 = 32 , AV_CODEC_ID_ASV2 = 33 , AV_CODEC_ID_FFV1 = 34 , AV_CODEC_ID_4XM = 35 , AV_CODEC_ID_VCR1 = 36 , AV_CODEC_ID_CLJR = 37 , AV_CODEC_ID_MDEC = 38 , AV_CODEC_ID_ROQ = 39 , AV_CODEC_ID_INTERPLAY_VIDEO = 40 , AV_CODEC_ID_XAN_WC3 = 41 , AV_CODEC_ID_XAN_WC4 = 42 , AV_CODEC_ID_RPZA = 43 , AV_CODEC_ID_CINEPAK = 44 , AV_CODEC_ID_WS_VQA = 45 , AV_CODEC_ID_MSRLE = 46 , AV_CODEC_ID_MSVIDEO1 = 47 , AV_CODEC_ID_IDCIN = 48 , AV_CODEC_ID_8BPS = 49 , AV_CODEC_ID_SMC = 50 , AV_CODEC_ID_FLIC = 51 , AV_CODEC_ID_TRUEMOTION1 = 52 , AV_CODEC_ID_VMDVIDEO = 53 , AV_CODEC_ID_MSZH = 54 , AV_CODEC_ID_ZLIB = 55 , AV_CODEC_ID_QTRLE = 56 , AV_CODEC_ID_TSCC = 57 , AV_CODEC_ID_ULTI = 58 , AV_CODEC_ID_QDRAW = 59 , AV_CODEC_ID_VIXL = 60 , AV_CODEC_ID_QPEG = 61 , AV_CODEC_ID_PNG = 62 , AV_CODEC_ID_PPM = 63 , AV_CODEC_ID_PBM = 64 , AV_CODEC_ID_PGM = 65 , AV_CODEC_ID_PGMYUV = 66 , AV_CODEC_ID_PAM = 67 , AV_CODEC_ID_FFVHUFF = 68 , AV_CODEC_ID_RV30 = 69 , AV_CODEC_ID_RV40 = 70 , AV_CODEC_ID_VC1 = 71 , AV_CODEC_ID_WMV3 = 72 , AV_CODEC_ID_LOCO = 73 , AV_CODEC_ID_WNV1 = 74 , AV_CODEC_ID_AASC = 75 , AV_CODEC_ID_INDEO2 = 76 , AV_CODEC_ID_FRAPS = 77 , AV_CODEC_ID_TRUEMOTION2 = 78 , AV_CODEC_ID_BMP = 79 , AV_CODEC_ID_CSCD = 80 , AV_CODEC_ID_MMVIDEO = 81 , AV_CODEC_ID_ZMBV = 82 , AV_CODEC_ID_AVS = 83 , AV_CODEC_ID_SMACKVIDEO = 84 , AV_CODEC_ID_NUV = 85 , AV_CODEC_ID_KMVC = 86 , AV_CODEC_ID_FLASHSV = 87 , AV_CODEC_ID_CAVS = 88 , AV_CODEC_ID_JPEG2000 = 89 , AV_CODEC_ID_VMNC = 90 , AV_CODEC_ID_VP5 = 91 , AV_CODEC_ID_VP6 = 92 , AV_CODEC_ID_VP6F = 93 , AV_CODEC_ID_TARGA = 94 , AV_CODEC_ID_DSICINVIDEO = 95 , AV_CODEC_ID_TIERTEXSEQVIDEO = 96 , AV_CODEC_ID_TIFF = 97 , AV_CODEC_ID_GIF = 98 , AV_CODEC_ID_DXA = 99 , AV_CODEC_ID_DNXHD = 100 , AV_CODEC_ID_THP = 101 , AV_CODEC_ID_SGI = 102 , AV_CODEC_ID_C93 = 103 , AV_CODEC_ID_BETHSOFTVID = 104 , AV_CODEC_ID_PTX = 105 , AV_CODEC_ID_TXD = 106 , AV_CODEC_ID_VP6A = 107 , AV_CODEC_ID_AMV = 108 , AV_CODEC_ID_VB = 109 , AV_CODEC_ID_PCX = 110 , AV_CODEC_ID_SUNRAST = 111 , AV_CODEC_ID_INDEO4 = 112 , AV_CODEC_ID_INDEO5 = 113 , AV_CODEC_ID_MIMIC = 114 , AV_CODEC_ID_RL2 = 115 , AV_CODEC_ID_ESCAPE124 = 116 , AV_CODEC_ID_DIRAC = 117 , AV_CODEC_ID_BFI = 118 , AV_CODEC_ID_CMV = 119 , AV_CODEC_ID_MOTIONPIXELS = 120 , AV_CODEC_ID_TGV = 121 , AV_CODEC_ID_TGQ = 122 , AV_CODEC_ID_TQI = 123 , AV_CODEC_ID_AURA = 124 , AV_CODEC_ID_AURA2 = 125 , AV_CODEC_ID_V210X = 126 , AV_CODEC_ID_TMV = 127 , AV_CODEC_ID_V210 = 128 , AV_CODEC_ID_DPX = 129 , AV_CODEC_ID_MAD = 130 , AV_CODEC_ID_FRWU = 131 , AV_CODEC_ID_FLASHSV2 = 132 , AV_CODEC_ID_CDGRAPHICS = 133 , AV_CODEC_ID_R210 = 134 , AV_CODEC_ID_ANM = 135 , AV_CODEC_ID_BINKVIDEO = 136 , AV_CODEC_ID_IFF_ILBM = 137 , AV_CODEC_ID_KGV1 = 138 , AV_CODEC_ID_YOP = 139 , AV_CODEC_ID_VP8 = 140 , AV_CODEC_ID_PICTOR = 141 , AV_CODEC_ID_ANSI = 142 , AV_CODEC_ID_A64_MULTI = 143 , AV_CODEC_ID_A64_MULTI5 = 144 , AV_CODEC_ID_R10K = 145 , AV_CODEC_ID_MXPEG = 146 , AV_CODEC_ID_LAGARITH = 147 , AV_CODEC_ID_PRORES = 148 , AV_CODEC_ID_JV = 149 , AV_CODEC_ID_DFA = 150 , AV_CODEC_ID_WMV3IMAGE = 151 , AV_CODEC_ID_VC1IMAGE = 152 , AV_CODEC_ID_UTVIDEO = 153 , AV_CODEC_ID_BMV_VIDEO = 154 , AV_CODEC_ID_VBLE = 155 , AV_CODEC_ID_DXTORY = 156 , AV_CODEC_ID_V410 = 157 , AV_CODEC_ID_XWD = 158 , AV_CODEC_ID_CDXL = 159 , AV_CODEC_ID_XBM = 160 , AV_CODEC_ID_ZEROCODEC = 161 , AV_CODEC_ID_MSS1 = 162 , AV_CODEC_ID_MSA1 = 163 , AV_CODEC_ID_TSCC2 = 164 , AV_CODEC_ID_MTS2 = 165 , AV_CODEC_ID_CLLC = 166 , AV_CODEC_ID_MSS2 = 167 , AV_CODEC_ID_VP9 = 168 , AV_CODEC_ID_AIC = 169 , AV_CODEC_ID_ESCAPE130 = 170 , AV_CODEC_ID_G2M = 171 , AV_CODEC_ID_WEBP = 172 , AV_CODEC_ID_HNM4_VIDEO = 173 , AV_CODEC_ID_HEVC = 174 , AV_CODEC_ID_FIC = 175 , AV_CODEC_ID_ALIAS_PIX = 176 , AV_CODEC_ID_BRENDER_PIX = 177 , AV_CODEC_ID_PAF_VIDEO = 178 , AV_CODEC_ID_EXR = 179 , AV_CODEC_ID_VP7 = 180 , AV_CODEC_ID_SANM = 181 , AV_CODEC_ID_SGIRLE = 182 , AV_CODEC_ID_MVC1 = 183 , AV_CODEC_ID_MVC2 = 184 , AV_CODEC_ID_HQX = 185 , AV_CODEC_ID_TDSC = 186 , AV_CODEC_ID_HQ_HQA = 187 , AV_CODEC_ID_HAP = 188 , AV_CODEC_ID_DDS = 189 , AV_CODEC_ID_DXV = 190 , AV_CODEC_ID_SCREENPRESSO = 191 , AV_CODEC_ID_RSCC = 192 , AV_CODEC_ID_Y41P = 32768 , AV_CODEC_ID_AVRP = 32769 , AV_CODEC_ID_012V = 32770 , AV_CODEC_ID_AVUI = 32771 , AV_CODEC_ID_AYUV = 32772 , AV_CODEC_ID_TARGA_Y216 = 32773 , AV_CODEC_ID_V308 = 32774 , AV_CODEC_ID_V408 = 32775 , AV_CODEC_ID_YUV4 = 32776 , AV_CODEC_ID_AVRN = 32777 , AV_CODEC_ID_CPIA = 32778 , AV_CODEC_ID_XFACE = 32779 , AV_CODEC_ID_SNOW = 32780 , AV_CODEC_ID_SMVJPEG = 32781 , AV_CODEC_ID_APNG = 32782 , AV_CODEC_ID_DAALA = 32783 , AV_CODEC_ID_CFHD = 32784 , AV_CODEC_ID_TRUEMOTION2RT = 32785 , AV_CODEC_ID_M101 = 32786 , AV_CODEC_ID_MAGICYUV = 32787 , AV_CODEC_ID_SHEERVIDEO = 32788 , AV_CODEC_ID_YLC = 32789 , AV_CODEC_ID_PSD = 32790 , AV_CODEC_ID_PIXLET = 32791 , AV_CODEC_ID_SPEEDHQ = 32792 , AV_CODEC_ID_FMVC = 32793 , AV_CODEC_ID_SCPR = 32794 , AV_CODEC_ID_CLEARVIDEO = 32795 , AV_CODEC_ID_XPM = 32796 , AV_CODEC_ID_AV1 = 32797 , AV_CODEC_ID_FIRST_AUDIO = 65536 , AV_CODEC_ID_PCM_S16BE = 65537 , AV_CODEC_ID_PCM_U16LE = 65538 , AV_CODEC_ID_PCM_U16BE = 65539 , AV_CODEC_ID_PCM_S8 = 65540 , AV_CODEC_ID_PCM_U8 = 65541 , AV_CODEC_ID_PCM_MULAW = 65542 , AV_CODEC_ID_PCM_ALAW = 65543 , AV_CODEC_ID_PCM_S32LE = 65544 , AV_CODEC_ID_PCM_S32BE = 65545 , AV_CODEC_ID_PCM_U32LE = 65546 , AV_CODEC_ID_PCM_U32BE = 65547 , AV_CODEC_ID_PCM_S24LE = 65548 , AV_CODEC_ID_PCM_S24BE = 65549 , AV_CODEC_ID_PCM_U24LE = 65550 , AV_CODEC_ID_PCM_U24BE = 65551 , AV_CODEC_ID_PCM_S24DAUD = 65552 , AV_CODEC_ID_PCM_ZORK = 65553 , AV_CODEC_ID_PCM_S16LE_PLANAR = 65554 , AV_CODEC_ID_PCM_DVD = 65555 , AV_CODEC_ID_PCM_F32BE = 65556 , AV_CODEC_ID_PCM_F32LE = 65557 , AV_CODEC_ID_PCM_F64BE = 65558 , AV_CODEC_ID_PCM_F64LE = 65559 , AV_CODEC_ID_PCM_BLURAY = 65560 , AV_CODEC_ID_PCM_LXF = 65561 , AV_CODEC_ID_S302M = 65562 , AV_CODEC_ID_PCM_S8_PLANAR = 65563 , AV_CODEC_ID_PCM_S24LE_PLANAR = 65564 , AV_CODEC_ID_PCM_S32LE_PLANAR = 65565 , AV_CODEC_ID_PCM_S16BE_PLANAR = 65566 , AV_CODEC_ID_PCM_S64LE = 67584 , AV_CODEC_ID_PCM_S64BE = 67585 , AV_CODEC_ID_PCM_F16LE = 67586 , AV_CODEC_ID_PCM_F24LE = 67587 , AV_CODEC_ID_ADPCM_IMA_QT = 69632 , AV_CODEC_ID_ADPCM_IMA_WAV = 69633 , AV_CODEC_ID_ADPCM_IMA_DK3 = 69634 , AV_CODEC_ID_ADPCM_IMA_DK4 = 69635 , AV_CODEC_ID_ADPCM_IMA_WS = 69636 , AV_CODEC_ID_ADPCM_IMA_SMJPEG = 69637 , AV_CODEC_ID_ADPCM_MS = 69638 , AV_CODEC_ID_ADPCM_4XM = 69639 , AV_CODEC_ID_ADPCM_XA = 69640 , AV_CODEC_ID_ADPCM_ADX = 69641 , AV_CODEC_ID_ADPCM_EA = 69642 , AV_CODEC_ID_ADPCM_G726 = 69643 , AV_CODEC_ID_ADPCM_CT = 69644 , AV_CODEC_ID_ADPCM_SWF = 69645 , AV_CODEC_ID_ADPCM_YAMAHA = 69646 , AV_CODEC_ID_ADPCM_SBPRO_4 = 69647 , AV_CODEC_ID_ADPCM_SBPRO_3 = 69648 , AV_CODEC_ID_ADPCM_SBPRO_2 = 69649 , AV_CODEC_ID_ADPCM_THP = 69650 , AV_CODEC_ID_ADPCM_IMA_AMV = 69651 , AV_CODEC_ID_ADPCM_EA_R1 = 69652 , AV_CODEC_ID_ADPCM_EA_R3 = 69653 , AV_CODEC_ID_ADPCM_EA_R2 = 69654 , AV_CODEC_ID_ADPCM_IMA_EA_SEAD = 69655 , AV_CODEC_ID_ADPCM_IMA_EA_EACS = 69656 , AV_CODEC_ID_ADPCM_EA_XAS = 69657 , AV_CODEC_ID_ADPCM_EA_MAXIS_XA = 69658 , AV_CODEC_ID_ADPCM_IMA_ISS = 69659 , AV_CODEC_ID_ADPCM_G722 = 69660 , AV_CODEC_ID_ADPCM_IMA_APC = 69661 , AV_CODEC_ID_ADPCM_VIMA = 69662 , AV_CODEC_ID_ADPCM_AFC = 71680 , AV_CODEC_ID_ADPCM_IMA_OKI = 71681 , AV_CODEC_ID_ADPCM_DTK = 71682 , AV_CODEC_ID_ADPCM_IMA_RAD = 71683 , AV_CODEC_ID_ADPCM_G726LE = 71684 , AV_CODEC_ID_ADPCM_THP_LE = 71685 , AV_CODEC_ID_ADPCM_PSX = 71686 , AV_CODEC_ID_ADPCM_AICA = 71687 , AV_CODEC_ID_ADPCM_IMA_DAT4 = 71688 , AV_CODEC_ID_ADPCM_MTAF = 71689 , AV_CODEC_ID_AMR_NB = 73728 , AV_CODEC_ID_AMR_WB = 73729 , AV_CODEC_ID_RA_144 = 77824 , AV_CODEC_ID_RA_288 = 77825 , AV_CODEC_ID_ROQ_DPCM = 81920 , AV_CODEC_ID_INTERPLAY_DPCM = 81921 , AV_CODEC_ID_XAN_DPCM = 81922 , AV_CODEC_ID_SOL_DPCM = 81923 , AV_CODEC_ID_SDX2_DPCM = 83968 , AV_CODEC_ID_MP2 = 86016 , AV_CODEC_ID_MP3 = 86017 , AV_CODEC_ID_AAC = 86018 , AV_CODEC_ID_AC3 = 86019 , AV_CODEC_ID_DTS = 86020 , AV_CODEC_ID_VORBIS = 86021 , AV_CODEC_ID_DVAUDIO = 86022 , AV_CODEC_ID_WMAV1 = 86023 , AV_CODEC_ID_WMAV2 = 86024 , AV_CODEC_ID_MACE3 = 86025 , AV_CODEC_ID_MACE6 = 86026 , AV_CODEC_ID_VMDAUDIO = 86027 , AV_CODEC_ID_FLAC = 86028 , AV_CODEC_ID_MP3ADU = 86029 , AV_CODEC_ID_MP3ON4 = 86030 , AV_CODEC_ID_SHORTEN = 86031 , AV_CODEC_ID_ALAC = 86032 , AV_CODEC_ID_WESTWOOD_SND1 = 86033 , AV_CODEC_ID_GSM = 86034 , AV_CODEC_ID_QDM2 = 86035 , AV_CODEC_ID_COOK = 86036 , AV_CODEC_ID_TRUESPEECH = 86037 , AV_CODEC_ID_TTA = 86038 , AV_CODEC_ID_SMACKAUDIO = 86039 , AV_CODEC_ID_QCELP = 86040 , AV_CODEC_ID_WAVPACK = 86041 , AV_CODEC_ID_DSICINAUDIO = 86042 , AV_CODEC_ID_IMC = 86043 , AV_CODEC_ID_MUSEPACK7 = 86044 , AV_CODEC_ID_MLP = 86045 , AV_CODEC_ID_GSM_MS = 86046 , AV_CODEC_ID_ATRAC3 = 86047 , AV_CODEC_ID_VOXWARE = 86048 , AV_CODEC_ID_APE = 86049 , AV_CODEC_ID_NELLYMOSER = 86050 , AV_CODEC_ID_MUSEPACK8 = 86051 , AV_CODEC_ID_SPEEX = 86052 , AV_CODEC_ID_WMAVOICE = 86053 , AV_CODEC_ID_WMAPRO = 86054 , AV_CODEC_ID_WMALOSSLESS = 86055 , AV_CODEC_ID_ATRAC3P = 86056 , AV_CODEC_ID_EAC3 = 86057 , AV_CODEC_ID_SIPR = 86058 , AV_CODEC_ID_MP1 = 86059 , AV_CODEC_ID_TWINVQ = 86060 , AV_CODEC_ID_TRUEHD = 86061 , AV_CODEC_ID_MP4ALS = 86062 , AV_CODEC_ID_ATRAC1 = 86063 , AV_CODEC_ID_BINKAUDIO_RDFT = 86064 , AV_CODEC_ID_BINKAUDIO_DCT = 86065 , AV_CODEC_ID_AAC_LATM = 86066 , AV_CODEC_ID_QDMC = 86067 , AV_CODEC_ID_CELT = 86068 , AV_CODEC_ID_G723_1 = 86069 , AV_CODEC_ID_G729 = 86070 , AV_CODEC_ID_8SVX_EXP = 86071 , AV_CODEC_ID_8SVX_FIB = 86072 , AV_CODEC_ID_BMV_AUDIO = 86073 , AV_CODEC_ID_RALF = 86074 , AV_CODEC_ID_IAC = 86075 , AV_CODEC_ID_ILBC = 86076 , AV_CODEC_ID_OPUS = 86077 , AV_CODEC_ID_COMFORT_NOISE = 86078 , AV_CODEC_ID_TAK = 86079 , AV_CODEC_ID_METASOUND = 86080 , AV_CODEC_ID_PAF_AUDIO = 86081 , AV_CODEC_ID_ON2AVC = 86082 , AV_CODEC_ID_DSS_SP = 86083 , AV_CODEC_ID_FFWAVESYNTH = 88064 , AV_CODEC_ID_SONIC = 88065 , AV_CODEC_ID_SONIC_LS = 88066 , AV_CODEC_ID_EVRC = 88067 , AV_CODEC_ID_SMV = 88068 , AV_CODEC_ID_DSD_LSBF = 88069 , AV_CODEC_ID_DSD_MSBF = 88070 , AV_CODEC_ID_DSD_LSBF_PLANAR = 88071 , AV_CODEC_ID_DSD_MSBF_PLANAR = 88072 , AV_CODEC_ID_4GV = 88073 , AV_CODEC_ID_INTERPLAY_ACM = 88074 , AV_CODEC_ID_XMA1 = 88075 , AV_CODEC_ID_XMA2 = 88076 , AV_CODEC_ID_DST = 88077 , AV_CODEC_ID_ATRAC3AL = 88078 , AV_CODEC_ID_ATRAC3PAL = 88079 , AV_CODEC_ID_FIRST_SUBTITLE = 94208 , AV_CODEC_ID_DVB_SUBTITLE = 94209 , AV_CODEC_ID_TEXT = 94210 , AV_CODEC_ID_XSUB = 94211 , AV_CODEC_ID_SSA = 94212 , AV_CODEC_ID_MOV_TEXT = 94213 , AV_CODEC_ID_HDMV_PGS_SUBTITLE = 94214 , AV_CODEC_ID_DVB_TELETEXT = 94215 , AV_CODEC_ID_SRT = 94216 , AV_CODEC_ID_MICRODVD = 96256 , AV_CODEC_ID_EIA_608 = 96257 , AV_CODEC_ID_JACOSUB = 96258 , AV_CODEC_ID_SAMI = 96259 , AV_CODEC_ID_REALTEXT = 96260 , AV_CODEC_ID_STL = 96261 , AV_CODEC_ID_SUBVIEWER1 = 96262 , AV_CODEC_ID_SUBVIEWER = 96263 , AV_CODEC_ID_SUBRIP = 96264 , AV_CODEC_ID_WEBVTT = 96265 , AV_CODEC_ID_MPL2 = 96266 , AV_CODEC_ID_VPLAYER = 96267 , AV_CODEC_ID_PJS = 96268 , AV_CODEC_ID_ASS = 96269 , AV_CODEC_ID_HDMV_TEXT_SUBTITLE = 96270 , AV_CODEC_ID_FIRST_UNKNOWN = 98304 , AV_CODEC_ID_SCTE_35 = 98305 , AV_CODEC_ID_BINTEXT = 100352 , AV_CODEC_ID_XBIN = 100353 , AV_CODEC_ID_IDF = 100354 , AV_CODEC_ID_OTF = 100355 , AV_CODEC_ID_SMPTE_KLV = 100356 , AV_CODEC_ID_DVD_NAV = 100357 , AV_CODEC_ID_TIMED_ID3 = 100358 , AV_CODEC_ID_BIN_DATA = 100359 , AV_CODEC_ID_PROBE = 102400 , AV_CODEC_ID_MPEG2TS = 131072 , AV_CODEC_ID_MPEG4SYSTEMS = 131073 , AV_CODEC_ID_FFMETADATA = 135168 , AV_CODEC_ID_WRAPPED_AVFRAME = 135169 , } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVCodecDescriptor { pub id : AVCodecID , pub type_ : AVMediaType , pub name : * const :: std :: os :: raw :: c_char , pub long_name : * const :: std :: os :: raw :: c_char , pub props : :: std :: os :: raw :: c_int , pub mime_types : * const * const :: std :: os :: raw :: c_char , pub profiles : * const AVProfile } # [ test ] fn bindgen_test_layout_AVCodecDescriptor ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVCodecDescriptor > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( AVCodecDescriptor ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVCodecDescriptor > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVCodecDescriptor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecDescriptor ) ) . id as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecDescriptor ) , "::" , stringify ! ( id ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecDescriptor ) ) . type_ as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecDescriptor ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecDescriptor ) ) . name as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecDescriptor ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecDescriptor ) ) . long_name as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecDescriptor ) , "::" , stringify ! ( long_name ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecDescriptor ) ) . props as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecDescriptor ) , "::" , stringify ! ( props ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecDescriptor ) ) . mime_types as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecDescriptor ) , "::" , stringify ! ( mime_types ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecDescriptor ) ) . profiles as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecDescriptor ) , "::" , stringify ! ( profiles ) ) ) ; } impl Clone for AVCodecDescriptor { fn clone ( & self ) -> Self { * self } } # [ repr ( i32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum AVDiscard { AVDISCARD_NONE = - 16 , AVDISCARD_DEFAULT = 0 , AVDISCARD_NONREF = 8 , AVDISCARD_BIDIR = 16 , AVDISCARD_NONINTRA = 24 , AVDISCARD_NONKEY = 32 , AVDISCARD_ALL = 48 , } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum AVAudioServiceType { AV_AUDIO_SERVICE_TYPE_MAIN = 0 , AV_AUDIO_SERVICE_TYPE_EFFECTS = 1 , AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED = 2 , AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED = 3 , AV_AUDIO_SERVICE_TYPE_DIALOGUE = 4 , AV_AUDIO_SERVICE_TYPE_COMMENTARY = 5 , AV_AUDIO_SERVICE_TYPE_EMERGENCY = 6 , AV_AUDIO_SERVICE_TYPE_VOICE_OVER = 7 , AV_AUDIO_SERVICE_TYPE_KARAOKE = 8 , AV_AUDIO_SERVICE_TYPE_NB = 9 , } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct RcOverride { pub start_frame : :: std :: os :: raw :: c_int , pub end_frame : :: std :: os :: raw :: c_int , pub qscale : :: std :: os :: raw :: c_int , pub quality_factor : f32 } # [ test ] fn bindgen_test_layout_RcOverride ( ) { assert_eq ! ( :: std :: mem :: size_of :: < RcOverride > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( RcOverride ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < RcOverride > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( RcOverride ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const RcOverride ) ) . start_frame as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( RcOverride ) , "::" , stringify ! ( start_frame ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const RcOverride ) ) . end_frame as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( RcOverride ) , "::" , stringify ! ( end_frame ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const RcOverride ) ) . qscale as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( RcOverride ) , "::" , stringify ! ( qscale ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const RcOverride ) ) . quality_factor as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( RcOverride ) , "::" , stringify ! ( quality_factor ) ) ) ; } impl Clone for RcOverride { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVPanScan { pub id : :: std :: os :: raw :: c_int , pub width : :: std :: os :: raw :: c_int , pub height : :: std :: os :: raw :: c_int , pub position : [ [ i16 ; 2usize ] ; 3usize ] } # [ test ] fn bindgen_test_layout_AVPanScan ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVPanScan > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( AVPanScan ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVPanScan > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( AVPanScan ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVPanScan ) ) . id as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVPanScan ) , "::" , stringify ! ( id ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVPanScan ) ) . width as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( AVPanScan ) , "::" , stringify ! ( width ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVPanScan ) ) . height as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AVPanScan ) , "::" , stringify ! ( height ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVPanScan ) ) . position as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( AVPanScan ) , "::" , stringify ! ( position ) ) ) ; } impl Clone for AVPanScan { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVCPBProperties { pub max_bitrate : :: std :: os :: raw :: c_int , pub min_bitrate : :: std :: os :: raw :: c_int , pub avg_bitrate : :: std :: os :: raw :: c_int , pub buffer_size : :: std :: os :: raw :: c_int , pub vbv_delay : u64 } # [ test ] fn bindgen_test_layout_AVCPBProperties ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVCPBProperties > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( AVCPBProperties ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVCPBProperties > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVCPBProperties ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCPBProperties ) ) . max_bitrate as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVCPBProperties ) , "::" , stringify ! ( max_bitrate ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCPBProperties ) ) . min_bitrate as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( AVCPBProperties ) , "::" , stringify ! ( min_bitrate ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCPBProperties ) ) . avg_bitrate as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AVCPBProperties ) , "::" , stringify ! ( avg_bitrate ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCPBProperties ) ) . buffer_size as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( AVCPBProperties ) , "::" , stringify ! ( buffer_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCPBProperties ) ) . vbv_delay as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( AVCPBProperties ) , "::" , stringify ! ( vbv_delay ) ) ) ; } impl Clone for AVCPBProperties { fn clone ( & self ) -> Self { * self } } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum AVPacketSideDataType { AV_PKT_DATA_PALETTE = 0 , AV_PKT_DATA_NEW_EXTRADATA = 1 , AV_PKT_DATA_PARAM_CHANGE = 2 , AV_PKT_DATA_H263_MB_INFO = 3 , AV_PKT_DATA_REPLAYGAIN = 4 , AV_PKT_DATA_DISPLAYMATRIX = 5 , AV_PKT_DATA_STEREO3D = 6 , AV_PKT_DATA_AUDIO_SERVICE_TYPE = 7 , AV_PKT_DATA_QUALITY_STATS = 8 , AV_PKT_DATA_FALLBACK_TRACK = 9 , AV_PKT_DATA_CPB_PROPERTIES = 10 , AV_PKT_DATA_SKIP_SAMPLES = 70 , AV_PKT_DATA_JP_DUALMONO = 71 , AV_PKT_DATA_STRINGS_METADATA = 72 , AV_PKT_DATA_SUBTITLE_POSITION = 73 , AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL = 74 , AV_PKT_DATA_WEBVTT_IDENTIFIER = 75 , AV_PKT_DATA_WEBVTT_SETTINGS = 76 , AV_PKT_DATA_METADATA_UPDATE = 77 , AV_PKT_DATA_MPEGTS_STREAM_ID = 78 , AV_PKT_DATA_MASTERING_DISPLAY_METADATA = 79 , AV_PKT_DATA_SPHERICAL = 80 , } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVPacketSideData { pub data : * mut u8 , pub size : :: std :: os :: raw :: c_int , pub type_ : AVPacketSideDataType } # [ test ] fn bindgen_test_layout_AVPacketSideData ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVPacketSideData > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( AVPacketSideData ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVPacketSideData > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVPacketSideData ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVPacketSideData ) ) . data as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVPacketSideData ) , "::" , stringify ! ( data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVPacketSideData ) ) . size as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AVPacketSideData ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVPacketSideData ) ) . type_ as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( AVPacketSideData ) , "::" , stringify ! ( type_ ) ) ) ; } impl Clone for AVPacketSideData { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVPacket { pub buf : * mut AVBufferRef , pub pts : i64 , pub dts : i64 , pub data : * mut u8 , pub size : :: std :: os :: raw :: c_int , pub stream_index : :: std :: os :: raw :: c_int , pub flags : :: std :: os :: raw :: c_int , pub side_data : * mut AVPacketSideData , pub side_data_elems : :: std :: os :: raw :: c_int , pub duration : i64 , pub pos : i64 , pub convergence_duration : i64 } # [ test ] fn bindgen_test_layout_AVPacket ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVPacket > ( ) , 88usize , concat ! ( "Size of: " , stringify ! ( AVPacket ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVPacket > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVPacket ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVPacket ) ) . buf as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVPacket ) , "::" , stringify ! ( buf ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVPacket ) ) . pts as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AVPacket ) , "::" , stringify ! ( pts ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVPacket ) ) . dts as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( AVPacket ) , "::" , stringify ! ( dts ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVPacket ) ) . data as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( AVPacket ) , "::" , stringify ! ( data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVPacket ) ) . size as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( AVPacket ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVPacket ) ) . stream_index as * const _ as usize } , 36usize , concat ! ( "Alignment of field: " , stringify ! ( AVPacket ) , "::" , stringify ! ( stream_index ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVPacket ) ) . flags as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( AVPacket ) , "::" , stringify ! ( flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVPacket ) ) . side_data as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( AVPacket ) , "::" , stringify ! ( side_data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVPacket ) ) . side_data_elems as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( AVPacket ) , "::" , stringify ! ( side_data_elems ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVPacket ) ) . duration as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( AVPacket ) , "::" , stringify ! ( duration ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVPacket ) ) . pos as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( AVPacket ) , "::" , stringify ! ( pos ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVPacket ) ) . convergence_duration as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( AVPacket ) , "::" , stringify ! ( convergence_duration ) ) ) ; } impl Clone for AVPacket { fn clone ( & self ) -> Self { * self } } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum AVSideDataParamChangeFlags { AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT = 1 , AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT = 2 , AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE = 4 , AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS = 8 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct AVCodecInternal ( [ u8 ; 0 ] ) ; # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum AVFieldOrder { AV_FIELD_UNKNOWN = 0 , AV_FIELD_PROGRESSIVE = 1 , AV_FIELD_TT = 2 , AV_FIELD_BB = 3 , AV_FIELD_TB = 4 , AV_FIELD_BT = 5 , } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVCodecContext { pub av_class : * const AVClass , pub log_level_offset : :: std :: os :: raw :: c_int , pub codec_type : AVMediaType , pub codec : * const AVCodec , pub codec_name : [ :: std :: os :: raw :: c_char ; 32usize ] , pub codec_id : AVCodecID , pub codec_tag : :: std :: os :: raw :: c_uint , pub stream_codec_tag : :: std :: os :: raw :: c_uint , pub priv_data : * mut :: std :: os :: raw :: c_void , pub internal : * mut AVCodecInternal , pub opaque : * mut :: std :: os :: raw :: c_void , pub bit_rate : i64 , pub bit_rate_tolerance : :: std :: os :: raw :: c_int , pub global_quality : :: std :: os :: raw :: c_int , pub compression_level : :: std :: os :: raw :: c_int , pub flags : :: std :: os :: raw :: c_int , pub flags2 : :: std :: os :: raw :: c_int , pub extradata : * mut u8 , pub extradata_size : :: std :: os :: raw :: c_int , pub time_base : AVRational , pub ticks_per_frame : :: std :: os :: raw :: c_int , pub delay : :: std :: os :: raw :: c_int , pub width : :: std :: os :: raw :: c_int , pub height : :: std :: os :: raw :: c_int , pub coded_width : :: std :: os :: raw :: c_int , pub coded_height : :: std :: os :: raw :: c_int , pub gop_size : :: std :: os :: raw :: c_int , pub pix_fmt : AVPixelFormat , pub me_method : :: std :: os :: raw :: c_int , pub draw_horiz_band : :: std :: option :: Option < unsafe extern "C" fn ( s : * mut AVCodecContext , src : * const AVFrame , offset : * mut :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , type_ : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int ) > , pub get_format : :: std :: option :: Option < unsafe extern "C" fn ( s : * mut AVCodecContext , fmt : * const AVPixelFormat ) -> AVPixelFormat > , pub max_b_frames : :: std :: os :: raw :: c_int , pub b_quant_factor : f32 , pub rc_strategy : :: std :: os :: raw :: c_int , pub b_frame_strategy : :: std :: os :: raw :: c_int , pub b_quant_offset : f32 , pub has_b_frames : :: std :: os :: raw :: c_int , pub mpeg_quant : :: std :: os :: raw :: c_int , pub i_quant_factor : f32 , pub i_quant_offset : f32 , pub lumi_masking : f32 , pub temporal_cplx_masking : f32 , pub spatial_cplx_masking : f32 , pub p_masking : f32 , pub dark_masking : f32 , pub slice_count : :: std :: os :: raw :: c_int , pub prediction_method : :: std :: os :: raw :: c_int , pub slice_offset : * mut :: std :: os :: raw :: c_int , pub sample_aspect_ratio : AVRational , pub me_cmp : :: std :: os :: raw :: c_int , pub me_sub_cmp : :: std :: os :: raw :: c_int , pub mb_cmp : :: std :: os :: raw :: c_int , pub ildct_cmp : :: std :: os :: raw :: c_int , pub dia_size : :: std :: os :: raw :: c_int , pub last_predictor_count : :: std :: os :: raw :: c_int , pub pre_me : :: std :: os :: raw :: c_int , pub me_pre_cmp : :: std :: os :: raw :: c_int , pub pre_dia_size : :: std :: os :: raw :: c_int , pub me_subpel_quality : :: std :: os :: raw :: c_int , pub dtg_active_format : :: std :: os :: raw :: c_int , pub me_range : :: std :: os :: raw :: c_int , pub intra_quant_bias : :: std :: os :: raw :: c_int , pub inter_quant_bias : :: std :: os :: raw :: c_int , pub slice_flags : :: std :: os :: raw :: c_int , pub xvmc_acceleration : :: std :: os :: raw :: c_int , pub mb_decision : :: std :: os :: raw :: c_int , pub intra_matrix : * mut u16 , pub inter_matrix : * mut u16 , pub scenechange_threshold : :: std :: os :: raw :: c_int , pub noise_reduction : :: std :: os :: raw :: c_int , pub me_threshold : :: std :: os :: raw :: c_int , pub mb_threshold : :: std :: os :: raw :: c_int , pub intra_dc_precision : :: std :: os :: raw :: c_int , pub skip_top : :: std :: os :: raw :: c_int , pub skip_bottom : :: std :: os :: raw :: c_int , pub border_masking : f32 , pub mb_lmin : :: std :: os :: raw :: c_int , pub mb_lmax : :: std :: os :: raw :: c_int , pub me_penalty_compensation : :: std :: os :: raw :: c_int , pub bidir_refine : :: std :: os :: raw :: c_int , pub brd_scale : :: std :: os :: raw :: c_int , pub keyint_min : :: std :: os :: raw :: c_int , pub refs : :: std :: os :: raw :: c_int , pub chromaoffset : :: std :: os :: raw :: c_int , pub scenechange_factor : :: std :: os :: raw :: c_int , pub mv0_threshold : :: std :: os :: raw :: c_int , pub b_sensitivity : :: std :: os :: raw :: c_int , pub color_primaries : AVColorPrimaries , pub color_trc : AVColorTransferCharacteristic , pub colorspace : AVColorSpace , pub color_range : AVColorRange , pub chroma_sample_location : AVChromaLocation , pub slices : :: std :: os :: raw :: c_int , pub field_order : AVFieldOrder , pub sample_rate : :: std :: os :: raw :: c_int , pub channels : :: std :: os :: raw :: c_int , pub sample_fmt : AVSampleFormat , pub frame_size : :: std :: os :: raw :: c_int , pub frame_number : :: std :: os :: raw :: c_int , pub block_align : :: std :: os :: raw :: c_int , pub cutoff : :: std :: os :: raw :: c_int , pub channel_layout : u64 , pub request_channel_layout : u64 , pub audio_service_type : AVAudioServiceType , pub request_sample_fmt : AVSampleFormat , pub get_buffer2 : :: std :: option :: Option < unsafe extern "C" fn ( s : * mut AVCodecContext , frame : * mut AVFrame , flags : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > , pub refcounted_frames : :: std :: os :: raw :: c_int , pub qcompress : f32 , pub qblur : f32 , pub qmin : :: std :: os :: raw :: c_int , pub qmax : :: std :: os :: raw :: c_int , pub max_qdiff : :: std :: os :: raw :: c_int , pub rc_qsquish : f32 , pub rc_qmod_amp : f32 , pub rc_qmod_freq : :: std :: os :: raw :: c_int , pub rc_buffer_size : :: std :: os :: raw :: c_int , pub rc_override_count : :: std :: os :: raw :: c_int , pub rc_override : * mut RcOverride , pub rc_eq : * const :: std :: os :: raw :: c_char , pub rc_max_rate : i64 , pub rc_min_rate : i64 , pub rc_buffer_aggressivity : f32 , pub rc_initial_cplx : f32 , pub rc_max_available_vbv_use : f32 , pub rc_min_vbv_overflow_use : f32 , pub rc_initial_buffer_occupancy : :: std :: os :: raw :: c_int , pub coder_type : :: std :: os :: raw :: c_int , pub context_model : :: std :: os :: raw :: c_int , pub lmin : :: std :: os :: raw :: c_int , pub lmax : :: std :: os :: raw :: c_int , pub frame_skip_threshold : :: std :: os :: raw :: c_int , pub frame_skip_factor : :: std :: os :: raw :: c_int , pub frame_skip_exp : :: std :: os :: raw :: c_int , pub frame_skip_cmp : :: std :: os :: raw :: c_int , pub trellis : :: std :: os :: raw :: c_int , pub min_prediction_order : :: std :: os :: raw :: c_int , pub max_prediction_order : :: std :: os :: raw :: c_int , pub timecode_frame_start : i64 , pub rtp_callback : :: std :: option :: Option < unsafe extern "C" fn ( avctx : * mut AVCodecContext , data : * mut :: std :: os :: raw :: c_void , size : :: std :: os :: raw :: c_int , mb_nb : :: std :: os :: raw :: c_int ) > , pub rtp_payload_size : :: std :: os :: raw :: c_int , pub mv_bits : :: std :: os :: raw :: c_int , pub header_bits : :: std :: os :: raw :: c_int , pub i_tex_bits : :: std :: os :: raw :: c_int , pub p_tex_bits : :: std :: os :: raw :: c_int , pub i_count : :: std :: os :: raw :: c_int , pub p_count : :: std :: os :: raw :: c_int , pub skip_count : :: std :: os :: raw :: c_int , pub misc_bits : :: std :: os :: raw :: c_int , pub frame_bits : :: std :: os :: raw :: c_int , pub stats_out : * mut :: std :: os :: raw :: c_char , pub stats_in : * mut :: std :: os :: raw :: c_char , pub workaround_bugs : :: std :: os :: raw :: c_int , pub strict_std_compliance : :: std :: os :: raw :: c_int , pub error_concealment : :: std :: os :: raw :: c_int , pub debug : :: std :: os :: raw :: c_int , pub debug_mv : :: std :: os :: raw :: c_int , pub err_recognition : :: std :: os :: raw :: c_int , pub reordered_opaque : i64 , pub hwaccel : * mut AVHWAccel , pub hwaccel_context : * mut :: std :: os :: raw :: c_void , pub error : [ u64 ; 8usize ] , pub dct_algo : :: std :: os :: raw :: c_int , pub idct_algo : :: std :: os :: raw :: c_int , pub bits_per_coded_sample : :: std :: os :: raw :: c_int , pub bits_per_raw_sample : :: std :: os :: raw :: c_int , pub lowres : :: std :: os :: raw :: c_int , pub coded_frame : * mut AVFrame , pub thread_count : :: std :: os :: raw :: c_int , pub thread_type : :: std :: os :: raw :: c_int , pub active_thread_type : :: std :: os :: raw :: c_int , pub thread_safe_callbacks : :: std :: os :: raw :: c_int , pub execute : :: std :: option :: Option < unsafe extern "C" fn ( c : * mut AVCodecContext , func : :: std :: option :: Option < unsafe extern "C" fn ( c2 : * mut AVCodecContext , arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > , arg2 : * mut :: std :: os :: raw :: c_void , ret : * mut :: std :: os :: raw :: c_int , count : :: std :: os :: raw :: c_int , size : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > , pub execute2 : :: std :: option :: Option < unsafe extern "C" fn ( c : * mut AVCodecContext , func : :: std :: option :: Option < unsafe extern "C" fn ( c2 : * mut AVCodecContext , arg : * mut :: std :: os :: raw :: c_void , jobnr : :: std :: os :: raw :: c_int , threadnr : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > , arg2 : * mut :: std :: os :: raw :: c_void , ret : * mut :: std :: os :: raw :: c_int , count : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > , pub nsse_weight : :: std :: os :: raw :: c_int , pub profile : :: std :: os :: raw :: c_int , pub level : :: std :: os :: raw :: c_int , pub skip_loop_filter : AVDiscard , pub skip_idct : AVDiscard , pub skip_frame : AVDiscard , pub subtitle_header : * mut u8 , pub subtitle_header_size : :: std :: os :: raw :: c_int , pub error_rate : :: std :: os :: raw :: c_int , pub vbv_delay : u64 , pub side_data_only_packets : :: std :: os :: raw :: c_int , pub initial_padding : :: std :: os :: raw :: c_int , pub framerate : AVRational , pub sw_pix_fmt : AVPixelFormat , pub pkt_timebase : AVRational , pub codec_descriptor : * const AVCodecDescriptor , pub pts_correction_num_faulty_pts : i64 , pub pts_correction_num_faulty_dts : i64 , pub pts_correction_last_pts : i64 , pub pts_correction_last_dts : i64 , pub sub_charenc : * mut :: std :: os :: raw :: c_char , pub sub_charenc_mode : :: std :: os :: raw :: c_int , pub skip_alpha : :: std :: os :: raw :: c_int , pub seek_preroll : :: std :: os :: raw :: c_int , pub chroma_intra_matrix : * mut u16 , pub dump_separator : * mut u8 , pub codec_whitelist : * mut :: std :: os :: raw :: c_char , pub properties : :: std :: os :: raw :: c_uint , pub coded_side_data : * mut AVPacketSideData , pub nb_coded_side_data : :: std :: os :: raw :: c_int , pub hw_frames_ctx : * mut AVBufferRef , pub sub_text_format : :: std :: os :: raw :: c_int , pub trailing_padding : :: std :: os :: raw :: c_int , pub max_pixels : i64 , pub hw_device_ctx : * mut AVBufferRef , pub hwaccel_flags : :: std :: os :: raw :: c_int } # [ test ] fn bindgen_test_layout_AVCodecContext ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVCodecContext > ( ) , 1160usize , concat ! ( "Size of: " , stringify ! ( AVCodecContext ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVCodecContext > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVCodecContext ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . av_class as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( av_class ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . log_level_offset as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( log_level_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . codec_type as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( codec_type ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . codec as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( codec ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . codec_name as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( codec_name ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . codec_id as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( codec_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . codec_tag as * const _ as usize } , 60usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( codec_tag ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . stream_codec_tag as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( stream_codec_tag ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . priv_data as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( priv_data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . internal as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( internal ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . opaque as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( opaque ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . bit_rate as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( bit_rate ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . bit_rate_tolerance as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( bit_rate_tolerance ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . global_quality as * const _ as usize } , 108usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( global_quality ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . compression_level as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( compression_level ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . flags as * const _ as usize } , 116usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . flags2 as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( flags2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . extradata as * const _ as usize } , 128usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( extradata ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . extradata_size as * const _ as usize } , 136usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( extradata_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . time_base as * const _ as usize } , 140usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( time_base ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . ticks_per_frame as * const _ as usize } , 148usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( ticks_per_frame ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . delay as * const _ as usize } , 152usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( delay ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . width as * const _ as usize } , 156usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( width ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . height as * const _ as usize } , 160usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( height ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . coded_width as * const _ as usize } , 164usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( coded_width ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . coded_height as * const _ as usize } , 168usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( coded_height ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . gop_size as * const _ as usize } , 172usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( gop_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . pix_fmt as * const _ as usize } , 176usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( pix_fmt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . me_method as * const _ as usize } , 180usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( me_method ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . draw_horiz_band as * const _ as usize } , 184usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( draw_horiz_band ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . get_format as * const _ as usize } , 192usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( get_format ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . max_b_frames as * const _ as usize } , 200usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( max_b_frames ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . b_quant_factor as * const _ as usize } , 204usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( b_quant_factor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . rc_strategy as * const _ as usize } , 208usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( rc_strategy ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . b_frame_strategy as * const _ as usize } , 212usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( b_frame_strategy ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . b_quant_offset as * const _ as usize } , 216usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( b_quant_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . has_b_frames as * const _ as usize } , 220usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( has_b_frames ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . mpeg_quant as * const _ as usize } , 224usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( mpeg_quant ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . i_quant_factor as * const _ as usize } , 228usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( i_quant_factor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . i_quant_offset as * const _ as usize } , 232usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( i_quant_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . lumi_masking as * const _ as usize } , 236usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( lumi_masking ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . temporal_cplx_masking as * const _ as usize } , 240usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( temporal_cplx_masking ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . spatial_cplx_masking as * const _ as usize } , 244usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( spatial_cplx_masking ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . p_masking as * const _ as usize } , 248usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( p_masking ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . dark_masking as * const _ as usize } , 252usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( dark_masking ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . slice_count as * const _ as usize } , 256usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( slice_count ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . prediction_method as * const _ as usize } , 260usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( prediction_method ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . slice_offset as * const _ as usize } , 264usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( slice_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . sample_aspect_ratio as * const _ as usize } , 272usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( sample_aspect_ratio ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . me_cmp as * const _ as usize } , 280usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( me_cmp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . me_sub_cmp as * const _ as usize } , 284usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( me_sub_cmp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . mb_cmp as * const _ as usize } , 288usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( mb_cmp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . ildct_cmp as * const _ as usize } , 292usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( ildct_cmp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . dia_size as * const _ as usize } , 296usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( dia_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . last_predictor_count as * const _ as usize } , 300usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( last_predictor_count ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . pre_me as * const _ as usize } , 304usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( pre_me ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . me_pre_cmp as * const _ as usize } , 308usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( me_pre_cmp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . pre_dia_size as * const _ as usize } , 312usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( pre_dia_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . me_subpel_quality as * const _ as usize } , 316usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( me_subpel_quality ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . dtg_active_format as * const _ as usize } , 320usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( dtg_active_format ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . me_range as * const _ as usize } , 324usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( me_range ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . intra_quant_bias as * const _ as usize } , 328usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( intra_quant_bias ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . inter_quant_bias as * const _ as usize } , 332usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( inter_quant_bias ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . slice_flags as * const _ as usize } , 336usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( slice_flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . xvmc_acceleration as * const _ as usize } , 340usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( xvmc_acceleration ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . mb_decision as * const _ as usize } , 344usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( mb_decision ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . intra_matrix as * const _ as usize } , 352usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( intra_matrix ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . inter_matrix as * const _ as usize } , 360usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( inter_matrix ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . scenechange_threshold as * const _ as usize } , 368usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( scenechange_threshold ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . noise_reduction as * const _ as usize } , 372usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( noise_reduction ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . me_threshold as * const _ as usize } , 376usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( me_threshold ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . mb_threshold as * const _ as usize } , 380usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( mb_threshold ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . intra_dc_precision as * const _ as usize } , 384usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( intra_dc_precision ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . skip_top as * const _ as usize } , 388usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( skip_top ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . skip_bottom as * const _ as usize } , 392usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( skip_bottom ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . border_masking as * const _ as usize } , 396usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( border_masking ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . mb_lmin as * const _ as usize } , 400usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( mb_lmin ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . mb_lmax as * const _ as usize } , 404usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( mb_lmax ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . me_penalty_compensation as * const _ as usize } , 408usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( me_penalty_compensation ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . bidir_refine as * const _ as usize } , 412usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( bidir_refine ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . brd_scale as * const _ as usize } , 416usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( brd_scale ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . keyint_min as * const _ as usize } , 420usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( keyint_min ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . refs as * const _ as usize } , 424usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( refs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . chromaoffset as * const _ as usize } , 428usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( chromaoffset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . scenechange_factor as * const _ as usize } , 432usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( scenechange_factor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . mv0_threshold as * const _ as usize } , 436usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( mv0_threshold ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . b_sensitivity as * const _ as usize } , 440usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( b_sensitivity ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . color_primaries as * const _ as usize } , 444usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( color_primaries ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . color_trc as * const _ as usize } , 448usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( color_trc ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . colorspace as * const _ as usize } , 452usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( colorspace ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . color_range as * const _ as usize } , 456usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( color_range ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . chroma_sample_location as * const _ as usize } , 460usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( chroma_sample_location ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . slices as * const _ as usize } , 464usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( slices ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . field_order as * const _ as usize } , 468usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( field_order ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . sample_rate as * const _ as usize } , 472usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( sample_rate ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . channels as * const _ as usize } , 476usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( channels ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . sample_fmt as * const _ as usize } , 480usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( sample_fmt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . frame_size as * const _ as usize } , 484usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( frame_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . frame_number as * const _ as usize } , 488usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( frame_number ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . block_align as * const _ as usize } , 492usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( block_align ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . cutoff as * const _ as usize } , 496usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( cutoff ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . channel_layout as * const _ as usize } , 504usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( channel_layout ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . request_channel_layout as * const _ as usize } , 512usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( request_channel_layout ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . audio_service_type as * const _ as usize } , 520usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( audio_service_type ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . request_sample_fmt as * const _ as usize } , 524usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( request_sample_fmt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . get_buffer2 as * const _ as usize } , 528usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( get_buffer2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . refcounted_frames as * const _ as usize } , 536usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( refcounted_frames ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . qcompress as * const _ as usize } , 540usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( qcompress ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . qblur as * const _ as usize } , 544usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( qblur ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . qmin as * const _ as usize } , 548usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( qmin ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . qmax as * const _ as usize } , 552usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( qmax ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . max_qdiff as * const _ as usize } , 556usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( max_qdiff ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . rc_qsquish as * const _ as usize } , 560usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( rc_qsquish ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . rc_qmod_amp as * const _ as usize } , 564usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( rc_qmod_amp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . rc_qmod_freq as * const _ as usize } , 568usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( rc_qmod_freq ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . rc_buffer_size as * const _ as usize } , 572usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( rc_buffer_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . rc_override_count as * const _ as usize } , 576usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( rc_override_count ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . rc_override as * const _ as usize } , 584usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( rc_override ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . rc_eq as * const _ as usize } , 592usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( rc_eq ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . rc_max_rate as * const _ as usize } , 600usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( rc_max_rate ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . rc_min_rate as * const _ as usize } , 608usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( rc_min_rate ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . rc_buffer_aggressivity as * const _ as usize } , 616usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( rc_buffer_aggressivity ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . rc_initial_cplx as * const _ as usize } , 620usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( rc_initial_cplx ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . rc_max_available_vbv_use as * const _ as usize } , 624usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( rc_max_available_vbv_use ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . rc_min_vbv_overflow_use as * const _ as usize } , 628usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( rc_min_vbv_overflow_use ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . rc_initial_buffer_occupancy as * const _ as usize } , 632usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( rc_initial_buffer_occupancy ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . coder_type as * const _ as usize } , 636usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( coder_type ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . context_model as * const _ as usize } , 640usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( context_model ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . lmin as * const _ as usize } , 644usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( lmin ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . lmax as * const _ as usize } , 648usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( lmax ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . frame_skip_threshold as * const _ as usize } , 652usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( frame_skip_threshold ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . frame_skip_factor as * const _ as usize } , 656usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( frame_skip_factor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . frame_skip_exp as * const _ as usize } , 660usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( frame_skip_exp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . frame_skip_cmp as * const _ as usize } , 664usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( frame_skip_cmp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . trellis as * const _ as usize } , 668usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( trellis ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . min_prediction_order as * const _ as usize } , 672usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( min_prediction_order ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . max_prediction_order as * const _ as usize } , 676usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( max_prediction_order ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . timecode_frame_start as * const _ as usize } , 680usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( timecode_frame_start ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . rtp_callback as * const _ as usize } , 688usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( rtp_callback ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . rtp_payload_size as * const _ as usize } , 696usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( rtp_payload_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . mv_bits as * const _ as usize } , 700usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( mv_bits ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . header_bits as * const _ as usize } , 704usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( header_bits ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . i_tex_bits as * const _ as usize } , 708usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( i_tex_bits ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . p_tex_bits as * const _ as usize } , 712usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( p_tex_bits ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . i_count as * const _ as usize } , 716usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( i_count ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . p_count as * const _ as usize } , 720usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( p_count ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . skip_count as * const _ as usize } , 724usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( skip_count ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . misc_bits as * const _ as usize } , 728usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( misc_bits ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . frame_bits as * const _ as usize } , 732usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( frame_bits ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . stats_out as * const _ as usize } , 736usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( stats_out ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . stats_in as * const _ as usize } , 744usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( stats_in ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . workaround_bugs as * const _ as usize } , 752usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( workaround_bugs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . strict_std_compliance as * const _ as usize } , 756usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( strict_std_compliance ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . error_concealment as * const _ as usize } , 760usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( error_concealment ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . debug as * const _ as usize } , 764usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( debug ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . debug_mv as * const _ as usize } , 768usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( debug_mv ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . err_recognition as * const _ as usize } , 772usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( err_recognition ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . reordered_opaque as * const _ as usize } , 776usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( reordered_opaque ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . hwaccel as * const _ as usize } , 784usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( hwaccel ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . hwaccel_context as * const _ as usize } , 792usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( hwaccel_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . error as * const _ as usize } , 800usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( error ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . dct_algo as * const _ as usize } , 864usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( dct_algo ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . idct_algo as * const _ as usize } , 868usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( idct_algo ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . bits_per_coded_sample as * const _ as usize } , 872usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( bits_per_coded_sample ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . bits_per_raw_sample as * const _ as usize } , 876usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( bits_per_raw_sample ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . lowres as * const _ as usize } , 880usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( lowres ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . coded_frame as * const _ as usize } , 888usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( coded_frame ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . thread_count as * const _ as usize } , 896usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( thread_count ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . thread_type as * const _ as usize } , 900usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( thread_type ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . active_thread_type as * const _ as usize } , 904usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( active_thread_type ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . thread_safe_callbacks as * const _ as usize } , 908usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( thread_safe_callbacks ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . execute as * const _ as usize } , 912usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( execute ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . execute2 as * const _ as usize } , 920usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( execute2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . nsse_weight as * const _ as usize } , 928usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( nsse_weight ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . profile as * const _ as usize } , 932usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( profile ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . level as * const _ as usize } , 936usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( level ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . skip_loop_filter as * const _ as usize } , 940usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( skip_loop_filter ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . skip_idct as * const _ as usize } , 944usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( skip_idct ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . skip_frame as * const _ as usize } , 948usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( skip_frame ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . subtitle_header as * const _ as usize } , 952usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( subtitle_header ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . subtitle_header_size as * const _ as usize } , 960usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( subtitle_header_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . error_rate as * const _ as usize } , 964usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( error_rate ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . vbv_delay as * const _ as usize } , 968usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( vbv_delay ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . side_data_only_packets as * const _ as usize } , 976usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( side_data_only_packets ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . initial_padding as * const _ as usize } , 980usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( initial_padding ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . framerate as * const _ as usize } , 984usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( framerate ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . sw_pix_fmt as * const _ as usize } , 992usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( sw_pix_fmt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . pkt_timebase as * const _ as usize } , 996usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( pkt_timebase ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . codec_descriptor as * const _ as usize } , 1008usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( codec_descriptor ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . pts_correction_num_faulty_pts as * const _ as usize } , 1016usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( pts_correction_num_faulty_pts ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . pts_correction_num_faulty_dts as * const _ as usize } , 1024usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( pts_correction_num_faulty_dts ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . pts_correction_last_pts as * const _ as usize } , 1032usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( pts_correction_last_pts ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . pts_correction_last_dts as * const _ as usize } , 1040usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( pts_correction_last_dts ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . sub_charenc as * const _ as usize } , 1048usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( sub_charenc ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . sub_charenc_mode as * const _ as usize } , 1056usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( sub_charenc_mode ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . skip_alpha as * const _ as usize } , 1060usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( skip_alpha ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . seek_preroll as * const _ as usize } , 1064usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( seek_preroll ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . chroma_intra_matrix as * const _ as usize } , 1072usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( chroma_intra_matrix ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . dump_separator as * const _ as usize } , 1080usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( dump_separator ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . codec_whitelist as * const _ as usize } , 1088usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( codec_whitelist ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . properties as * const _ as usize } , 1096usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( properties ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . coded_side_data as * const _ as usize } , 1104usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( coded_side_data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . nb_coded_side_data as * const _ as usize } , 1112usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( nb_coded_side_data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . hw_frames_ctx as * const _ as usize } , 1120usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( hw_frames_ctx ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . sub_text_format as * const _ as usize } , 1128usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( sub_text_format ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . trailing_padding as * const _ as usize } , 1132usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( trailing_padding ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . max_pixels as * const _ as usize } , 1136usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( max_pixels ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . hw_device_ctx as * const _ as usize } , 1144usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( hw_device_ctx ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecContext ) ) . hwaccel_flags as * const _ as usize } , 1152usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecContext ) , "::" , stringify ! ( hwaccel_flags ) ) ) ; } impl Clone for AVCodecContext { fn clone ( & self ) -> Self { * self } } extern "C" { pub fn av_codec_get_pkt_timebase ( avctx : * const AVCodecContext ) -> AVRational ; } extern "C" { pub fn av_codec_set_pkt_timebase ( avctx : * mut AVCodecContext , val : AVRational ) ; } extern "C" { pub fn av_codec_get_codec_descriptor ( avctx : * const AVCodecContext ) -> * const AVCodecDescriptor ; } extern "C" { pub fn av_codec_set_codec_descriptor ( avctx : * mut AVCodecContext , desc : * const AVCodecDescriptor ) ; } extern "C" { pub fn av_codec_get_codec_properties ( avctx : * const AVCodecContext ) -> :: std :: os :: raw :: c_uint ; } extern "C" { pub fn av_codec_get_lowres ( avctx : * const AVCodecContext ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_codec_set_lowres ( avctx : * mut AVCodecContext , val : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn av_codec_get_seek_preroll ( avctx : * const AVCodecContext ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_codec_set_seek_preroll ( avctx : * mut AVCodecContext , val : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn av_codec_get_chroma_intra_matrix ( avctx : * const AVCodecContext ) -> * mut u16 ; } extern "C" { pub fn av_codec_set_chroma_intra_matrix ( avctx : * mut AVCodecContext , val : * mut u16 ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVProfile { pub profile : :: std :: os :: raw :: c_int , pub name : * const :: std :: os :: raw :: c_char } # [ test ] fn bindgen_test_layout_AVProfile ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVProfile > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( AVProfile ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVProfile > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVProfile ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVProfile ) ) . profile as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVProfile ) , "::" , stringify ! ( profile ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVProfile ) ) . name as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AVProfile ) , "::" , stringify ! ( name ) ) ) ; } impl Clone for AVProfile { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct AVCodecDefault ( [ u8 ; 0 ] ) ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVSubtitle { pub format : u16 , pub start_display_time : u32 , pub end_display_time : u32 , pub num_rects : :: std :: os :: raw :: c_uint , pub rects : * mut * mut AVSubtitleRect , pub pts : i64 } # [ test ] fn bindgen_test_layout_AVSubtitle ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVSubtitle > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( AVSubtitle ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVSubtitle > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVSubtitle ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVSubtitle ) ) . format as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVSubtitle ) , "::" , stringify ! ( format ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVSubtitle ) ) . start_display_time as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( AVSubtitle ) , "::" , stringify ! ( start_display_time ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVSubtitle ) ) . end_display_time as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AVSubtitle ) , "::" , stringify ! ( end_display_time ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVSubtitle ) ) . num_rects as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( AVSubtitle ) , "::" , stringify ! ( num_rects ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVSubtitle ) ) . rects as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( AVSubtitle ) , "::" , stringify ! ( rects ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVSubtitle ) ) . pts as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( AVSubtitle ) , "::" , stringify ! ( pts ) ) ) ; } impl Clone for AVSubtitle { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVCodec { pub name : * const :: std :: os :: raw :: c_char , pub long_name : * const :: std :: os :: raw :: c_char , pub type_ : AVMediaType , pub id : AVCodecID , pub capabilities : :: std :: os :: raw :: c_int , pub supported_framerates : * const AVRational , pub pix_fmts : * const AVPixelFormat , pub supported_samplerates : * const :: std :: os :: raw :: c_int , pub sample_fmts : * const AVSampleFormat , pub channel_layouts : * const u64 , pub max_lowres : u8 , pub priv_class : * const AVClass , pub profiles : * const AVProfile , pub priv_data_size : :: std :: os :: raw :: c_int , pub next : * mut AVCodec , pub init_thread_copy : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut AVCodecContext ) -> :: std :: os :: raw :: c_int > , pub update_thread_context : :: std :: option :: Option < unsafe extern "C" fn ( dst : * mut AVCodecContext , src : * const AVCodecContext ) -> :: std :: os :: raw :: c_int > , pub defaults : * const AVCodecDefault , pub init_static_data : :: std :: option :: Option < unsafe extern "C" fn ( codec : * mut AVCodec ) > , pub init : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut AVCodecContext ) -> :: std :: os :: raw :: c_int > , pub encode_sub : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut AVCodecContext , buf : * mut u8 , buf_size : :: std :: os :: raw :: c_int , sub : * const AVSubtitle ) -> :: std :: os :: raw :: c_int > , pub encode2 : :: std :: option :: Option < unsafe extern "C" fn ( avctx : * mut AVCodecContext , avpkt : * mut AVPacket , frame : * const AVFrame , got_packet_ptr : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > , pub decode : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut AVCodecContext , outdata : * mut :: std :: os :: raw :: c_void , outdata_size : * mut :: std :: os :: raw :: c_int , avpkt : * mut AVPacket ) -> :: std :: os :: raw :: c_int > , pub close : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut AVCodecContext ) -> :: std :: os :: raw :: c_int > , pub send_frame : :: std :: option :: Option < unsafe extern "C" fn ( avctx : * mut AVCodecContext , frame : * const AVFrame ) -> :: std :: os :: raw :: c_int > , pub send_packet : :: std :: option :: Option < unsafe extern "C" fn ( avctx : * mut AVCodecContext , avpkt : * const AVPacket ) -> :: std :: os :: raw :: c_int > , pub receive_frame : :: std :: option :: Option < unsafe extern "C" fn ( avctx : * mut AVCodecContext , frame : * mut AVFrame ) -> :: std :: os :: raw :: c_int > , pub receive_packet : :: std :: option :: Option < unsafe extern "C" fn ( avctx : * mut AVCodecContext , avpkt : * mut AVPacket ) -> :: std :: os :: raw :: c_int > , pub flush : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut AVCodecContext ) > , pub caps_internal : :: std :: os :: raw :: c_int } # [ test ] fn bindgen_test_layout_AVCodec ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVCodec > ( ) , 232usize , concat ! ( "Size of: " , stringify ! ( AVCodec ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVCodec > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVCodec ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodec ) ) . name as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodec ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodec ) ) . long_name as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodec ) , "::" , stringify ! ( long_name ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodec ) ) . type_ as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodec ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodec ) ) . id as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodec ) , "::" , stringify ! ( id ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodec ) ) . capabilities as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodec ) , "::" , stringify ! ( capabilities ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodec ) ) . supported_framerates as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodec ) , "::" , stringify ! ( supported_framerates ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodec ) ) . pix_fmts as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodec ) , "::" , stringify ! ( pix_fmts ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodec ) ) . supported_samplerates as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodec ) , "::" , stringify ! ( supported_samplerates ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodec ) ) . sample_fmts as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodec ) , "::" , stringify ! ( sample_fmts ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodec ) ) . channel_layouts as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodec ) , "::" , stringify ! ( channel_layouts ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodec ) ) . max_lowres as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodec ) , "::" , stringify ! ( max_lowres ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodec ) ) . priv_class as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodec ) , "::" , stringify ! ( priv_class ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodec ) ) . profiles as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodec ) , "::" , stringify ! ( profiles ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodec ) ) . priv_data_size as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodec ) , "::" , stringify ! ( priv_data_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodec ) ) . next as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodec ) , "::" , stringify ! ( next ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodec ) ) . init_thread_copy as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodec ) , "::" , stringify ! ( init_thread_copy ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodec ) ) . update_thread_context as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodec ) , "::" , stringify ! ( update_thread_context ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodec ) ) . defaults as * const _ as usize } , 128usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodec ) , "::" , stringify ! ( defaults ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodec ) ) . init_static_data as * const _ as usize } , 136usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodec ) , "::" , stringify ! ( init_static_data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodec ) ) . init as * const _ as usize } , 144usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodec ) , "::" , stringify ! ( init ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodec ) ) . encode_sub as * const _ as usize } , 152usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodec ) , "::" , stringify ! ( encode_sub ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodec ) ) . encode2 as * const _ as usize } , 160usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodec ) , "::" , stringify ! ( encode2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodec ) ) . decode as * const _ as usize } , 168usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodec ) , "::" , stringify ! ( decode ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodec ) ) . close as * const _ as usize } , 176usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodec ) , "::" , stringify ! ( close ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodec ) ) . send_frame as * const _ as usize } , 184usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodec ) , "::" , stringify ! ( send_frame ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodec ) ) . send_packet as * const _ as usize } , 192usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodec ) , "::" , stringify ! ( send_packet ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodec ) ) . receive_frame as * const _ as usize } , 200usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodec ) , "::" , stringify ! ( receive_frame ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodec ) ) . receive_packet as * const _ as usize } , 208usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodec ) , "::" , stringify ! ( receive_packet ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodec ) ) . flush as * const _ as usize } , 216usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodec ) , "::" , stringify ! ( flush ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodec ) ) . caps_internal as * const _ as usize } , 224usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodec ) , "::" , stringify ! ( caps_internal ) ) ) ; } impl Clone for AVCodec { fn clone ( & self ) -> Self { * self } } extern "C" { pub fn av_codec_get_max_lowres ( codec : * const AVCodec ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MpegEncContext ( [ u8 ; 0 ] ) ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVHWAccel { pub name : * const :: std :: os :: raw :: c_char , pub type_ : AVMediaType , pub id : AVCodecID , pub pix_fmt : AVPixelFormat , pub capabilities : :: std :: os :: raw :: c_int , pub next : * mut AVHWAccel , pub alloc_frame : :: std :: option :: Option < unsafe extern "C" fn ( avctx : * mut AVCodecContext , frame : * mut AVFrame ) -> :: std :: os :: raw :: c_int > , pub start_frame : :: std :: option :: Option < unsafe extern "C" fn ( avctx : * mut AVCodecContext , buf : * const u8 , buf_size : u32 ) -> :: std :: os :: raw :: c_int > , pub decode_slice : :: std :: option :: Option < unsafe extern "C" fn ( avctx : * mut AVCodecContext , buf : * const u8 , buf_size : u32 ) -> :: std :: os :: raw :: c_int > , pub end_frame : :: std :: option :: Option < unsafe extern "C" fn ( avctx : * mut AVCodecContext ) -> :: std :: os :: raw :: c_int > , pub frame_priv_data_size : :: std :: os :: raw :: c_int , pub decode_mb : :: std :: option :: Option < unsafe extern "C" fn ( s : * mut MpegEncContext ) > , pub init : :: std :: option :: Option < unsafe extern "C" fn ( avctx : * mut AVCodecContext ) -> :: std :: os :: raw :: c_int > , pub uninit : :: std :: option :: Option < unsafe extern "C" fn ( avctx : * mut AVCodecContext ) -> :: std :: os :: raw :: c_int > , pub priv_data_size : :: std :: os :: raw :: c_int , pub caps_internal : :: std :: os :: raw :: c_int } # [ test ] fn bindgen_test_layout_AVHWAccel ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVHWAccel > ( ) , 104usize , concat ! ( "Size of: " , stringify ! ( AVHWAccel ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVHWAccel > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVHWAccel ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVHWAccel ) ) . name as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVHWAccel ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVHWAccel ) ) . type_ as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AVHWAccel ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVHWAccel ) ) . id as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( AVHWAccel ) , "::" , stringify ! ( id ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVHWAccel ) ) . pix_fmt as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( AVHWAccel ) , "::" , stringify ! ( pix_fmt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVHWAccel ) ) . capabilities as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( AVHWAccel ) , "::" , stringify ! ( capabilities ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVHWAccel ) ) . next as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( AVHWAccel ) , "::" , stringify ! ( next ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVHWAccel ) ) . alloc_frame as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( AVHWAccel ) , "::" , stringify ! ( alloc_frame ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVHWAccel ) ) . start_frame as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( AVHWAccel ) , "::" , stringify ! ( start_frame ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVHWAccel ) ) . decode_slice as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( AVHWAccel ) , "::" , stringify ! ( decode_slice ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVHWAccel ) ) . end_frame as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( AVHWAccel ) , "::" , stringify ! ( end_frame ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVHWAccel ) ) . frame_priv_data_size as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( AVHWAccel ) , "::" , stringify ! ( frame_priv_data_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVHWAccel ) ) . decode_mb as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( AVHWAccel ) , "::" , stringify ! ( decode_mb ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVHWAccel ) ) . init as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( AVHWAccel ) , "::" , stringify ! ( init ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVHWAccel ) ) . uninit as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( AVHWAccel ) , "::" , stringify ! ( uninit ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVHWAccel ) ) . priv_data_size as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( AVHWAccel ) , "::" , stringify ! ( priv_data_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVHWAccel ) ) . caps_internal as * const _ as usize } , 100usize , concat ! ( "Alignment of field: " , stringify ! ( AVHWAccel ) , "::" , stringify ! ( caps_internal ) ) ) ; } impl Clone for AVHWAccel { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVPicture { pub data : [ * mut u8 ; 8usize ] , pub linesize : [ :: std :: os :: raw :: c_int ; 8usize ] } # [ test ] fn bindgen_test_layout_AVPicture ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVPicture > ( ) , 96usize , concat ! ( "Size of: " , stringify ! ( AVPicture ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVPicture > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVPicture ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVPicture ) ) . data as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVPicture ) , "::" , stringify ! ( data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVPicture ) ) . linesize as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( AVPicture ) , "::" , stringify ! ( linesize ) ) ) ; } impl Clone for AVPicture { fn clone ( & self ) -> Self { * self } } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum AVSubtitleType { SUBTITLE_NONE = 0 , SUBTITLE_BITMAP = 1 , SUBTITLE_TEXT = 2 , SUBTITLE_ASS = 3 , } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVSubtitleRect { pub x : :: std :: os :: raw :: c_int , pub y : :: std :: os :: raw :: c_int , pub w : :: std :: os :: raw :: c_int , pub h : :: std :: os :: raw :: c_int , pub nb_colors : :: std :: os :: raw :: c_int , pub pict : AVPicture , pub data : [ * mut u8 ; 4usize ] , pub linesize : [ :: std :: os :: raw :: c_int ; 4usize ] , pub type_ : AVSubtitleType , pub text : * mut :: std :: os :: raw :: c_char , pub ass : * mut :: std :: os :: raw :: c_char , pub flags : :: std :: os :: raw :: c_int } # [ test ] fn bindgen_test_layout_AVSubtitleRect ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVSubtitleRect > ( ) , 200usize , concat ! ( "Size of: " , stringify ! ( AVSubtitleRect ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVSubtitleRect > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVSubtitleRect ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVSubtitleRect ) ) . x as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVSubtitleRect ) , "::" , stringify ! ( x ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVSubtitleRect ) ) . y as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( AVSubtitleRect ) , "::" , stringify ! ( y ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVSubtitleRect ) ) . w as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AVSubtitleRect ) , "::" , stringify ! ( w ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVSubtitleRect ) ) . h as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( AVSubtitleRect ) , "::" , stringify ! ( h ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVSubtitleRect ) ) . nb_colors as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( AVSubtitleRect ) , "::" , stringify ! ( nb_colors ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVSubtitleRect ) ) . pict as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( AVSubtitleRect ) , "::" , stringify ! ( pict ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVSubtitleRect ) ) . data as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( AVSubtitleRect ) , "::" , stringify ! ( data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVSubtitleRect ) ) . linesize as * const _ as usize } , 152usize , concat ! ( "Alignment of field: " , stringify ! ( AVSubtitleRect ) , "::" , stringify ! ( linesize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVSubtitleRect ) ) . type_ as * const _ as usize } , 168usize , concat ! ( "Alignment of field: " , stringify ! ( AVSubtitleRect ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVSubtitleRect ) ) . text as * const _ as usize } , 176usize , concat ! ( "Alignment of field: " , stringify ! ( AVSubtitleRect ) , "::" , stringify ! ( text ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVSubtitleRect ) ) . ass as * const _ as usize } , 184usize , concat ! ( "Alignment of field: " , stringify ! ( AVSubtitleRect ) , "::" , stringify ! ( ass ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVSubtitleRect ) ) . flags as * const _ as usize } , 192usize , concat ! ( "Alignment of field: " , stringify ! ( AVSubtitleRect ) , "::" , stringify ! ( flags ) ) ) ; } impl Clone for AVSubtitleRect { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVCodecParameters { pub codec_type : AVMediaType , pub codec_id : AVCodecID , pub codec_tag : u32 , pub extradata : * mut u8 , pub extradata_size : :: std :: os :: raw :: c_int , pub format : :: std :: os :: raw :: c_int , pub bit_rate : i64 , pub bits_per_coded_sample : :: std :: os :: raw :: c_int , pub bits_per_raw_sample : :: std :: os :: raw :: c_int , pub profile : :: std :: os :: raw :: c_int , pub level : :: std :: os :: raw :: c_int , pub width : :: std :: os :: raw :: c_int , pub height : :: std :: os :: raw :: c_int , pub sample_aspect_ratio : AVRational , pub field_order : AVFieldOrder , pub color_range : AVColorRange , pub color_primaries : AVColorPrimaries , pub color_trc : AVColorTransferCharacteristic , pub color_space : AVColorSpace , pub chroma_location : AVChromaLocation , pub video_delay : :: std :: os :: raw :: c_int , pub channel_layout : u64 , pub channels : :: std :: os :: raw :: c_int , pub sample_rate : :: std :: os :: raw :: c_int , pub block_align : :: std :: os :: raw :: c_int , pub frame_size : :: std :: os :: raw :: c_int , pub initial_padding : :: std :: os :: raw :: c_int , pub trailing_padding : :: std :: os :: raw :: c_int , pub seek_preroll : :: std :: os :: raw :: c_int } # [ test ] fn bindgen_test_layout_AVCodecParameters ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVCodecParameters > ( ) , 144usize , concat ! ( "Size of: " , stringify ! ( AVCodecParameters ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVCodecParameters > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVCodecParameters ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParameters ) ) . codec_type as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParameters ) , "::" , stringify ! ( codec_type ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParameters ) ) . codec_id as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParameters ) , "::" , stringify ! ( codec_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParameters ) ) . codec_tag as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParameters ) , "::" , stringify ! ( codec_tag ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParameters ) ) . extradata as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParameters ) , "::" , stringify ! ( extradata ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParameters ) ) . extradata_size as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParameters ) , "::" , stringify ! ( extradata_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParameters ) ) . format as * const _ as usize } , 28usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParameters ) , "::" , stringify ! ( format ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParameters ) ) . bit_rate as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParameters ) , "::" , stringify ! ( bit_rate ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParameters ) ) . bits_per_coded_sample as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParameters ) , "::" , stringify ! ( bits_per_coded_sample ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParameters ) ) . bits_per_raw_sample as * const _ as usize } , 44usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParameters ) , "::" , stringify ! ( bits_per_raw_sample ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParameters ) ) . profile as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParameters ) , "::" , stringify ! ( profile ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParameters ) ) . level as * const _ as usize } , 52usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParameters ) , "::" , stringify ! ( level ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParameters ) ) . width as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParameters ) , "::" , stringify ! ( width ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParameters ) ) . height as * const _ as usize } , 60usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParameters ) , "::" , stringify ! ( height ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParameters ) ) . sample_aspect_ratio as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParameters ) , "::" , stringify ! ( sample_aspect_ratio ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParameters ) ) . field_order as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParameters ) , "::" , stringify ! ( field_order ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParameters ) ) . color_range as * const _ as usize } , 76usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParameters ) , "::" , stringify ! ( color_range ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParameters ) ) . color_primaries as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParameters ) , "::" , stringify ! ( color_primaries ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParameters ) ) . color_trc as * const _ as usize } , 84usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParameters ) , "::" , stringify ! ( color_trc ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParameters ) ) . color_space as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParameters ) , "::" , stringify ! ( color_space ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParameters ) ) . chroma_location as * const _ as usize } , 92usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParameters ) , "::" , stringify ! ( chroma_location ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParameters ) ) . video_delay as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParameters ) , "::" , stringify ! ( video_delay ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParameters ) ) . channel_layout as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParameters ) , "::" , stringify ! ( channel_layout ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParameters ) ) . channels as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParameters ) , "::" , stringify ! ( channels ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParameters ) ) . sample_rate as * const _ as usize } , 116usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParameters ) , "::" , stringify ! ( sample_rate ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParameters ) ) . block_align as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParameters ) , "::" , stringify ! ( block_align ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParameters ) ) . frame_size as * const _ as usize } , 124usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParameters ) , "::" , stringify ! ( frame_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParameters ) ) . initial_padding as * const _ as usize } , 128usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParameters ) , "::" , stringify ! ( initial_padding ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParameters ) ) . trailing_padding as * const _ as usize } , 132usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParameters ) , "::" , stringify ! ( trailing_padding ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParameters ) ) . seek_preroll as * const _ as usize } , 136usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParameters ) , "::" , stringify ! ( seek_preroll ) ) ) ; } impl Clone for AVCodecParameters { fn clone ( & self ) -> Self { * self } } extern "C" { pub fn av_codec_next ( c : * const AVCodec ) -> * mut AVCodec ; } extern "C" { pub fn avcodec_version ( ) -> :: std :: os :: raw :: c_uint ; } extern "C" { pub fn avcodec_configuration ( ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn avcodec_license ( ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn avcodec_register ( codec : * mut AVCodec ) ; } extern "C" { pub fn avcodec_register_all ( ) ; } extern "C" { pub fn avcodec_alloc_context3 ( codec : * const AVCodec ) -> * mut AVCodecContext ; } extern "C" { pub fn avcodec_free_context ( avctx : * mut * mut AVCodecContext ) ; } extern "C" { pub fn avcodec_get_context_defaults3 ( s : * mut AVCodecContext , codec : * const AVCodec ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avcodec_get_class ( ) -> * const AVClass ; } extern "C" { pub fn avcodec_get_frame_class ( ) -> * const AVClass ; } extern "C" { pub fn avcodec_get_subtitle_rect_class ( ) -> * const AVClass ; } extern "C" { pub fn avcodec_copy_context ( dest : * mut AVCodecContext , src : * const AVCodecContext ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avcodec_parameters_alloc ( ) -> * mut AVCodecParameters ; } extern "C" { pub fn avcodec_parameters_free ( par : * mut * mut AVCodecParameters ) ; } extern "C" { pub fn avcodec_parameters_copy ( dst : * mut AVCodecParameters , src : * const AVCodecParameters ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avcodec_parameters_from_context ( par : * mut AVCodecParameters , codec : * const AVCodecContext ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avcodec_parameters_to_context ( codec : * mut AVCodecContext , par : * const AVCodecParameters ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avcodec_open2 ( avctx : * mut AVCodecContext , codec : * const AVCodec , options : * mut * mut AVDictionary ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avcodec_close ( avctx : * mut AVCodecContext ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avsubtitle_free ( sub : * mut AVSubtitle ) ; } extern "C" { pub fn av_packet_alloc ( ) -> * mut AVPacket ; } extern "C" { pub fn av_packet_clone ( src : * const AVPacket ) -> * mut AVPacket ; } extern "C" { pub fn av_packet_free ( pkt : * mut * mut AVPacket ) ; } extern "C" { pub fn av_init_packet ( pkt : * mut AVPacket ) ; } extern "C" { pub fn av_new_packet ( pkt : * mut AVPacket , size : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_shrink_packet ( pkt : * mut AVPacket , size : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn av_grow_packet ( pkt : * mut AVPacket , grow_by : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_packet_from_data ( pkt : * mut AVPacket , data : * mut u8 , size : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_dup_packet ( pkt : * mut AVPacket ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_copy_packet ( dst : * mut AVPacket , src : * const AVPacket ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_copy_packet_side_data ( dst : * mut AVPacket , src : * const AVPacket ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_free_packet ( pkt : * mut AVPacket ) ; } extern "C" { pub fn av_packet_new_side_data ( pkt : * mut AVPacket , type_ : AVPacketSideDataType , size : :: std :: os :: raw :: c_int ) -> * mut u8 ; } extern "C" { pub fn av_packet_add_side_data ( pkt : * mut AVPacket , type_ : AVPacketSideDataType , data : * mut u8 , size : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_packet_shrink_side_data ( pkt : * mut AVPacket , type_ : AVPacketSideDataType , size : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_packet_get_side_data ( pkt : * const AVPacket , type_ : AVPacketSideDataType , size : * mut :: std :: os :: raw :: c_int ) -> * mut u8 ; } extern "C" { pub fn av_packet_merge_side_data ( pkt : * mut AVPacket ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_packet_split_side_data ( pkt : * mut AVPacket ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_packet_side_data_name ( type_ : AVPacketSideDataType ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn av_packet_pack_dictionary ( dict : * mut AVDictionary , size : * mut :: std :: os :: raw :: c_int ) -> * mut u8 ; } extern "C" { pub fn av_packet_unpack_dictionary ( data : * const u8 , size : :: std :: os :: raw :: c_int , dict : * mut * mut AVDictionary ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_packet_free_side_data ( pkt : * mut AVPacket ) ; } extern "C" { pub fn av_packet_ref ( dst : * mut AVPacket , src : * const AVPacket ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_packet_unref ( pkt : * mut AVPacket ) ; } extern "C" { pub fn av_packet_move_ref ( dst : * mut AVPacket , src : * mut AVPacket ) ; } extern "C" { pub fn av_packet_copy_props ( dst : * mut AVPacket , src : * const AVPacket ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_packet_rescale_ts ( pkt : * mut AVPacket , tb_src : AVRational , tb_dst : AVRational ) ; } extern "C" { pub fn avcodec_find_decoder ( id : AVCodecID ) -> * mut AVCodec ; } extern "C" { pub fn avcodec_find_decoder_by_name ( name : * const :: std :: os :: raw :: c_char ) -> * mut AVCodec ; } extern "C" { pub fn avcodec_default_get_buffer2 ( s : * mut AVCodecContext , frame : * mut AVFrame , flags : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avcodec_get_edge_width ( ) -> :: std :: os :: raw :: c_uint ; } extern "C" { pub fn avcodec_align_dimensions ( s : * mut AVCodecContext , width : * mut :: std :: os :: raw :: c_int , height : * mut :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn avcodec_align_dimensions2 ( s : * mut AVCodecContext , width : * mut :: std :: os :: raw :: c_int , height : * mut :: std :: os :: raw :: c_int , linesize_align : * mut :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn avcodec_enum_to_chroma_pos ( xpos : * mut :: std :: os :: raw :: c_int , ypos : * mut :: std :: os :: raw :: c_int , pos : AVChromaLocation ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avcodec_chroma_pos_to_enum ( xpos : :: std :: os :: raw :: c_int , ypos : :: std :: os :: raw :: c_int ) -> AVChromaLocation ; } extern "C" { pub fn avcodec_decode_audio4 ( avctx : * mut AVCodecContext , frame : * mut AVFrame , got_frame_ptr : * mut :: std :: os :: raw :: c_int , avpkt : * const AVPacket ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avcodec_decode_video2 ( avctx : * mut AVCodecContext , picture : * mut AVFrame , got_picture_ptr : * mut :: std :: os :: raw :: c_int , avpkt : * const AVPacket ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avcodec_decode_subtitle2 ( avctx : * mut AVCodecContext , sub : * mut AVSubtitle , got_sub_ptr : * mut :: std :: os :: raw :: c_int , avpkt : * mut AVPacket ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avcodec_send_packet ( avctx : * mut AVCodecContext , avpkt : * const AVPacket ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avcodec_receive_frame ( avctx : * mut AVCodecContext , frame : * mut AVFrame ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avcodec_send_frame ( avctx : * mut AVCodecContext , frame : * const AVFrame ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avcodec_receive_packet ( avctx : * mut AVCodecContext , avpkt : * mut AVPacket ) -> :: std :: os :: raw :: c_int ; } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum AVPictureStructure { AV_PICTURE_STRUCTURE_UNKNOWN = 0 , AV_PICTURE_STRUCTURE_TOP_FIELD = 1 , AV_PICTURE_STRUCTURE_BOTTOM_FIELD = 2 , AV_PICTURE_STRUCTURE_FRAME = 3 , } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVCodecParserContext { pub priv_data : * mut :: std :: os :: raw :: c_void , pub parser : * mut AVCodecParser , pub frame_offset : i64 , pub cur_offset : i64 , pub next_frame_offset : i64 , pub pict_type : :: std :: os :: raw :: c_int , pub repeat_pict : :: std :: os :: raw :: c_int , pub pts : i64 , pub dts : i64 , pub last_pts : i64 , pub last_dts : i64 , pub fetch_timestamp : :: std :: os :: raw :: c_int , pub cur_frame_start_index : :: std :: os :: raw :: c_int , pub cur_frame_offset : [ i64 ; 4usize ] , pub cur_frame_pts : [ i64 ; 4usize ] , pub cur_frame_dts : [ i64 ; 4usize ] , pub flags : :: std :: os :: raw :: c_int , pub offset : i64 , pub cur_frame_end : [ i64 ; 4usize ] , pub key_frame : :: std :: os :: raw :: c_int , pub convergence_duration : i64 , pub dts_sync_point : :: std :: os :: raw :: c_int , pub dts_ref_dts_delta : :: std :: os :: raw :: c_int , pub pts_dts_delta : :: std :: os :: raw :: c_int , pub cur_frame_pos : [ i64 ; 4usize ] , pub pos : i64 , pub last_pos : i64 , pub duration : :: std :: os :: raw :: c_int , pub field_order : AVFieldOrder , pub picture_structure : AVPictureStructure , pub output_picture_number : :: std :: os :: raw :: c_int , pub width : :: std :: os :: raw :: c_int , pub height : :: std :: os :: raw :: c_int , pub coded_width : :: std :: os :: raw :: c_int , pub coded_height : :: std :: os :: raw :: c_int , pub format : :: std :: os :: raw :: c_int } # [ test ] fn bindgen_test_layout_AVCodecParserContext ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVCodecParserContext > ( ) , 352usize , concat ! ( "Size of: " , stringify ! ( AVCodecParserContext ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVCodecParserContext > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVCodecParserContext ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . priv_data as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( priv_data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . parser as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( parser ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . frame_offset as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( frame_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . cur_offset as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( cur_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . next_frame_offset as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( next_frame_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . pict_type as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( pict_type ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . repeat_pict as * const _ as usize } , 44usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( repeat_pict ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . pts as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( pts ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . dts as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( dts ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . last_pts as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( last_pts ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . last_dts as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( last_dts ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . fetch_timestamp as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( fetch_timestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . cur_frame_start_index as * const _ as usize } , 84usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( cur_frame_start_index ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . cur_frame_offset as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( cur_frame_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . cur_frame_pts as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( cur_frame_pts ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . cur_frame_dts as * const _ as usize } , 152usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( cur_frame_dts ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . flags as * const _ as usize } , 184usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . offset as * const _ as usize } , 192usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . cur_frame_end as * const _ as usize } , 200usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( cur_frame_end ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . key_frame as * const _ as usize } , 232usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( key_frame ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . convergence_duration as * const _ as usize } , 240usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( convergence_duration ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . dts_sync_point as * const _ as usize } , 248usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( dts_sync_point ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . dts_ref_dts_delta as * const _ as usize } , 252usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( dts_ref_dts_delta ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . pts_dts_delta as * const _ as usize } , 256usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( pts_dts_delta ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . cur_frame_pos as * const _ as usize } , 264usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( cur_frame_pos ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . pos as * const _ as usize } , 296usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( pos ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . last_pos as * const _ as usize } , 304usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( last_pos ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . duration as * const _ as usize } , 312usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( duration ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . field_order as * const _ as usize } , 316usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( field_order ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . picture_structure as * const _ as usize } , 320usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( picture_structure ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . output_picture_number as * const _ as usize } , 324usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( output_picture_number ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . width as * const _ as usize } , 328usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( width ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . height as * const _ as usize } , 332usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( height ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . coded_width as * const _ as usize } , 336usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( coded_width ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . coded_height as * const _ as usize } , 340usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( coded_height ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParserContext ) ) . format as * const _ as usize } , 344usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParserContext ) , "::" , stringify ! ( format ) ) ) ; } impl Clone for AVCodecParserContext { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVCodecParser { pub codec_ids : [ :: std :: os :: raw :: c_int ; 5usize ] , pub priv_data_size : :: std :: os :: raw :: c_int , pub parser_init : :: std :: option :: Option < unsafe extern "C" fn ( s : * mut AVCodecParserContext ) -> :: std :: os :: raw :: c_int > , pub parser_parse : :: std :: option :: Option < unsafe extern "C" fn ( s : * mut AVCodecParserContext , avctx : * mut AVCodecContext , poutbuf : * mut * const u8 , poutbuf_size : * mut :: std :: os :: raw :: c_int , buf : * const u8 , buf_size : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > , pub parser_close : :: std :: option :: Option < unsafe extern "C" fn ( s : * mut AVCodecParserContext ) > , pub split : :: std :: option :: Option < unsafe extern "C" fn ( avctx : * mut AVCodecContext , buf : * const u8 , buf_size : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > , pub next : * mut AVCodecParser } # [ test ] fn bindgen_test_layout_AVCodecParser ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVCodecParser > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( AVCodecParser ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVCodecParser > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVCodecParser ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParser ) ) . codec_ids as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParser ) , "::" , stringify ! ( codec_ids ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParser ) ) . priv_data_size as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParser ) , "::" , stringify ! ( priv_data_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParser ) ) . parser_init as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParser ) , "::" , stringify ! ( parser_init ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParser ) ) . parser_parse as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParser ) , "::" , stringify ! ( parser_parse ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParser ) ) . parser_close as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParser ) , "::" , stringify ! ( parser_close ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParser ) ) . split as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParser ) , "::" , stringify ! ( split ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVCodecParser ) ) . next as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( AVCodecParser ) , "::" , stringify ! ( next ) ) ) ; } impl Clone for AVCodecParser { fn clone ( & self ) -> Self { * self } } extern "C" { pub fn av_parser_next ( c : * const AVCodecParser ) -> * mut AVCodecParser ; } extern "C" { pub fn av_register_codec_parser ( parser : * mut AVCodecParser ) ; } extern "C" { pub fn av_parser_init ( codec_id : :: std :: os :: raw :: c_int ) -> * mut AVCodecParserContext ; } extern "C" { pub fn av_parser_parse2 ( s : * mut AVCodecParserContext , avctx : * mut AVCodecContext , poutbuf : * mut * mut u8 , poutbuf_size : * mut :: std :: os :: raw :: c_int , buf : * const u8 , buf_size : :: std :: os :: raw :: c_int , pts : i64 , dts : i64 , pos : i64 ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_parser_change ( s : * mut AVCodecParserContext , avctx : * mut AVCodecContext , poutbuf : * mut * mut u8 , poutbuf_size : * mut :: std :: os :: raw :: c_int , buf : * const u8 , buf_size : :: std :: os :: raw :: c_int , keyframe : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_parser_close ( s : * mut AVCodecParserContext ) ; } extern "C" { pub fn avcodec_find_encoder ( id : AVCodecID ) -> * mut AVCodec ; } extern "C" { pub fn avcodec_find_encoder_by_name ( name : * const :: std :: os :: raw :: c_char ) -> * mut AVCodec ; } extern "C" { pub fn avcodec_encode_audio2 ( avctx : * mut AVCodecContext , avpkt : * mut AVPacket , frame : * const AVFrame , got_packet_ptr : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avcodec_encode_video2 ( avctx : * mut AVCodecContext , avpkt : * mut AVPacket , frame : * const AVFrame , got_packet_ptr : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avcodec_encode_subtitle ( avctx : * mut AVCodecContext , buf : * mut u8 , buf_size : :: std :: os :: raw :: c_int , sub : * const AVSubtitle ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ReSampleContext ( [ u8 ; 0 ] ) ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct AVResampleContext ( [ u8 ; 0 ] ) ; extern "C" { pub fn av_audio_resample_init ( output_channels : :: std :: os :: raw :: c_int , input_channels : :: std :: os :: raw :: c_int , output_rate : :: std :: os :: raw :: c_int , input_rate : :: std :: os :: raw :: c_int , sample_fmt_out : AVSampleFormat , sample_fmt_in : AVSampleFormat , filter_length : :: std :: os :: raw :: c_int , log2_phase_count : :: std :: os :: raw :: c_int , linear : :: std :: os :: raw :: c_int , cutoff : f64 ) -> * mut ReSampleContext ; } extern "C" { pub fn av_resample_init ( out_rate : :: std :: os :: raw :: c_int , in_rate : :: std :: os :: raw :: c_int , filter_length : :: std :: os :: raw :: c_int , log2_phase_count : :: std :: os :: raw :: c_int , linear : :: std :: os :: raw :: c_int , cutoff : f64 ) -> * mut AVResampleContext ; } extern "C" { pub fn av_resample ( c : * mut AVResampleContext , dst : * mut :: std :: os :: raw :: c_short , src : * mut :: std :: os :: raw :: c_short , consumed : * mut :: std :: os :: raw :: c_int , src_size : :: std :: os :: raw :: c_int , dst_size : :: std :: os :: raw :: c_int , update_ctx : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_resample_compensate ( c : * mut AVResampleContext , sample_delta : :: std :: os :: raw :: c_int , compensation_distance : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn av_resample_close ( c : * mut AVResampleContext ) ; } extern "C" { pub fn avpicture_alloc ( picture : * mut AVPicture , pix_fmt : AVPixelFormat , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avpicture_free ( picture : * mut AVPicture ) ; } extern "C" { pub fn avpicture_fill ( picture : * mut AVPicture , ptr : * const u8 , pix_fmt : AVPixelFormat , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avpicture_layout ( src : * const AVPicture , pix_fmt : AVPixelFormat , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , dest : * mut :: std :: os :: raw :: c_uchar , dest_size : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avpicture_get_size ( pix_fmt : AVPixelFormat , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_picture_copy ( dst : * mut AVPicture , src : * const AVPicture , pix_fmt : AVPixelFormat , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn av_picture_crop ( dst : * mut AVPicture , src : * const AVPicture , pix_fmt : AVPixelFormat , top_band : :: std :: os :: raw :: c_int , left_band : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_picture_pad ( dst : * mut AVPicture , src : * const AVPicture , height : :: std :: os :: raw :: c_int , width : :: std :: os :: raw :: c_int , pix_fmt : AVPixelFormat , padtop : :: std :: os :: raw :: c_int , padbottom : :: std :: os :: raw :: c_int , padleft : :: std :: os :: raw :: c_int , padright : :: std :: os :: raw :: c_int , color : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avcodec_get_chroma_sub_sample ( pix_fmt : AVPixelFormat , h_shift : * mut :: std :: os :: raw :: c_int , v_shift : * mut :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn avcodec_pix_fmt_to_codec_tag ( pix_fmt : AVPixelFormat ) -> :: std :: os :: raw :: c_uint ; } extern "C" { pub fn avcodec_get_pix_fmt_loss ( dst_pix_fmt : AVPixelFormat , src_pix_fmt : AVPixelFormat , has_alpha : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avcodec_find_best_pix_fmt_of_list ( pix_fmt_list : * const AVPixelFormat , src_pix_fmt : AVPixelFormat , has_alpha : :: std :: os :: raw :: c_int , loss_ptr : * mut :: std :: os :: raw :: c_int ) -> AVPixelFormat ; } extern "C" { pub fn avcodec_find_best_pix_fmt_of_2 ( dst_pix_fmt1 : AVPixelFormat , dst_pix_fmt2 : AVPixelFormat , src_pix_fmt : AVPixelFormat , has_alpha : :: std :: os :: raw :: c_int , loss_ptr : * mut :: std :: os :: raw :: c_int ) -> AVPixelFormat ; } extern "C" { pub fn avcodec_find_best_pix_fmt2 ( dst_pix_fmt1 : AVPixelFormat , dst_pix_fmt2 : AVPixelFormat , src_pix_fmt : AVPixelFormat , has_alpha : :: std :: os :: raw :: c_int , loss_ptr : * mut :: std :: os :: raw :: c_int ) -> AVPixelFormat ; } extern "C" { pub fn avcodec_default_get_format ( s : * mut AVCodecContext , fmt : * const AVPixelFormat ) -> AVPixelFormat ; } extern "C" { pub fn avcodec_set_dimensions ( s : * mut AVCodecContext , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn av_get_codec_tag_string ( buf : * mut :: std :: os :: raw :: c_char , buf_size : usize , codec_tag : :: std :: os :: raw :: c_uint ) -> usize ; } extern "C" { pub fn avcodec_string ( buf : * mut :: std :: os :: raw :: c_char , buf_size : :: std :: os :: raw :: c_int , enc : * mut AVCodecContext , encode : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn av_get_profile_name ( codec : * const AVCodec , profile : :: std :: os :: raw :: c_int ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn avcodec_profile_name ( codec_id : AVCodecID , profile : :: std :: os :: raw :: c_int ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn avcodec_default_execute ( c : * mut AVCodecContext , func : :: std :: option :: Option < unsafe extern "C" fn ( c2 : * mut AVCodecContext , arg2 : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > , arg : * mut :: std :: os :: raw :: c_void , ret : * mut :: std :: os :: raw :: c_int , count : :: std :: os :: raw :: c_int , size : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avcodec_default_execute2 ( c : * mut AVCodecContext , func : :: std :: option :: Option < unsafe extern "C" fn ( c2 : * mut AVCodecContext , arg2 : * mut :: std :: os :: raw :: c_void , arg1 : :: std :: os :: raw :: c_int , arg2 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > , arg : * mut :: std :: os :: raw :: c_void , ret : * mut :: std :: os :: raw :: c_int , count : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avcodec_fill_audio_frame ( frame : * mut AVFrame , nb_channels : :: std :: os :: raw :: c_int , sample_fmt : AVSampleFormat , buf : * const u8 , buf_size : :: std :: os :: raw :: c_int , align : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avcodec_flush_buffers ( avctx : * mut AVCodecContext ) ; } extern "C" { pub fn av_get_bits_per_sample ( codec_id : AVCodecID ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_get_pcm_codec ( fmt : AVSampleFormat , be : :: std :: os :: raw :: c_int ) -> AVCodecID ; } extern "C" { pub fn av_get_exact_bits_per_sample ( codec_id : AVCodecID ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_get_audio_frame_duration ( avctx : * mut AVCodecContext , frame_bytes : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_get_audio_frame_duration2 ( par : * mut AVCodecParameters , frame_bytes : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVBitStreamFilterContext { pub priv_data : * mut :: std :: os :: raw :: c_void , pub filter : * const AVBitStreamFilter , pub parser : * mut AVCodecParserContext , pub next : * mut AVBitStreamFilterContext , pub args : * mut :: std :: os :: raw :: c_char } # [ test ] fn bindgen_test_layout_AVBitStreamFilterContext ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVBitStreamFilterContext > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( AVBitStreamFilterContext ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVBitStreamFilterContext > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVBitStreamFilterContext ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVBitStreamFilterContext ) ) . priv_data as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVBitStreamFilterContext ) , "::" , stringify ! ( priv_data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVBitStreamFilterContext ) ) . filter as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AVBitStreamFilterContext ) , "::" , stringify ! ( filter ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVBitStreamFilterContext ) ) . parser as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( AVBitStreamFilterContext ) , "::" , stringify ! ( parser ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVBitStreamFilterContext ) ) . next as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( AVBitStreamFilterContext ) , "::" , stringify ! ( next ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVBitStreamFilterContext ) ) . args as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( AVBitStreamFilterContext ) , "::" , stringify ! ( args ) ) ) ; } impl Clone for AVBitStreamFilterContext { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct AVBSFInternal ( [ u8 ; 0 ] ) ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVBSFContext { pub av_class : * const AVClass , pub filter : * const AVBitStreamFilter , pub internal : * mut AVBSFInternal , pub priv_data : * mut :: std :: os :: raw :: c_void , pub par_in : * mut AVCodecParameters , pub par_out : * mut AVCodecParameters , pub time_base_in : AVRational , pub time_base_out : AVRational } # [ test ] fn bindgen_test_layout_AVBSFContext ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVBSFContext > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( AVBSFContext ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVBSFContext > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVBSFContext ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVBSFContext ) ) . av_class as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVBSFContext ) , "::" , stringify ! ( av_class ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVBSFContext ) ) . filter as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AVBSFContext ) , "::" , stringify ! ( filter ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVBSFContext ) ) . internal as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( AVBSFContext ) , "::" , stringify ! ( internal ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVBSFContext ) ) . priv_data as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( AVBSFContext ) , "::" , stringify ! ( priv_data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVBSFContext ) ) . par_in as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( AVBSFContext ) , "::" , stringify ! ( par_in ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVBSFContext ) ) . par_out as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( AVBSFContext ) , "::" , stringify ! ( par_out ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVBSFContext ) ) . time_base_in as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( AVBSFContext ) , "::" , stringify ! ( time_base_in ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVBSFContext ) ) . time_base_out as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( AVBSFContext ) , "::" , stringify ! ( time_base_out ) ) ) ; } impl Clone for AVBSFContext { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVBitStreamFilter { pub name : * const :: std :: os :: raw :: c_char , pub codec_ids : * const AVCodecID , pub priv_class : * const AVClass , pub priv_data_size : :: std :: os :: raw :: c_int , pub init : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut AVBSFContext ) -> :: std :: os :: raw :: c_int > , pub filter : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut AVBSFContext , pkt : * mut AVPacket ) -> :: std :: os :: raw :: c_int > , pub close : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut AVBSFContext ) > } # [ test ] fn bindgen_test_layout_AVBitStreamFilter ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVBitStreamFilter > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( AVBitStreamFilter ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVBitStreamFilter > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVBitStreamFilter ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVBitStreamFilter ) ) . name as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVBitStreamFilter ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVBitStreamFilter ) ) . codec_ids as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AVBitStreamFilter ) , "::" , stringify ! ( codec_ids ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVBitStreamFilter ) ) . priv_class as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( AVBitStreamFilter ) , "::" , stringify ! ( priv_class ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVBitStreamFilter ) ) . priv_data_size as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( AVBitStreamFilter ) , "::" , stringify ! ( priv_data_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVBitStreamFilter ) ) . init as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( AVBitStreamFilter ) , "::" , stringify ! ( init ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVBitStreamFilter ) ) . filter as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( AVBitStreamFilter ) , "::" , stringify ! ( filter ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVBitStreamFilter ) ) . close as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( AVBitStreamFilter ) , "::" , stringify ! ( close ) ) ) ; } impl Clone for AVBitStreamFilter { fn clone ( & self ) -> Self { * self } } extern "C" { pub fn av_register_bitstream_filter ( bsf : * mut AVBitStreamFilter ) ; } extern "C" { pub fn av_bitstream_filter_init ( name : * const :: std :: os :: raw :: c_char ) -> * mut AVBitStreamFilterContext ; } extern "C" { pub fn av_bitstream_filter_filter ( bsfc : * mut AVBitStreamFilterContext , avctx : * mut AVCodecContext , args : * const :: std :: os :: raw :: c_char , poutbuf : * mut * mut u8 , poutbuf_size : * mut :: std :: os :: raw :: c_int , buf : * const u8 , buf_size : :: std :: os :: raw :: c_int , keyframe : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_bitstream_filter_close ( bsf : * mut AVBitStreamFilterContext ) ; } extern "C" { pub fn av_bitstream_filter_next ( f : * const AVBitStreamFilter ) -> * mut AVBitStreamFilter ; } extern "C" { pub fn av_bsf_get_by_name ( name : * const :: std :: os :: raw :: c_char ) -> * const AVBitStreamFilter ; } extern "C" { pub fn av_bsf_next ( opaque : * mut * mut :: std :: os :: raw :: c_void ) -> * const AVBitStreamFilter ; } extern "C" { pub fn av_bsf_alloc ( filter : * const AVBitStreamFilter , ctx : * mut * mut AVBSFContext ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_bsf_init ( ctx : * mut AVBSFContext ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_bsf_send_packet ( ctx : * mut AVBSFContext , pkt : * mut AVPacket ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_bsf_receive_packet ( ctx : * mut AVBSFContext , pkt : * mut AVPacket ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_bsf_free ( ctx : * mut * mut AVBSFContext ) ; } extern "C" { pub fn av_bsf_get_class ( ) -> * const AVClass ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct AVBSFList ( [ u8 ; 0 ] ) ; extern "C" { pub fn av_bsf_list_alloc ( ) -> * mut AVBSFList ; } extern "C" { pub fn av_bsf_list_free ( lst : * mut * mut AVBSFList ) ; } extern "C" { pub fn av_bsf_list_append ( lst : * mut AVBSFList , bsf : * mut AVBSFContext ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_bsf_list_append2 ( lst : * mut AVBSFList , bsf_name : * const :: std :: os :: raw :: c_char , options : * mut * mut AVDictionary ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_bsf_list_finalize ( lst : * mut * mut AVBSFList , bsf : * mut * mut AVBSFContext ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_bsf_list_parse_str ( str : * const :: std :: os :: raw :: c_char , bsf : * mut * mut AVBSFContext ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_bsf_get_null_filter ( bsf : * mut * mut AVBSFContext ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_fast_padded_malloc ( ptr : * mut :: std :: os :: raw :: c_void , size : * mut :: std :: os :: raw :: c_uint , min_size : usize ) ; } extern "C" { pub fn av_fast_padded_mallocz ( ptr : * mut :: std :: os :: raw :: c_void , size : * mut :: std :: os :: raw :: c_uint , min_size : usize ) ; } extern "C" { pub fn av_xiphlacing ( s : * mut :: std :: os :: raw :: c_uchar , v : :: std :: os :: raw :: c_uint ) -> :: std :: os :: raw :: c_uint ; } extern "C" { pub fn av_log_missing_feature ( avc : * mut :: std :: os :: raw :: c_void , feature : * const :: std :: os :: raw :: c_char , want_sample : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn av_log_ask_for_sample ( avc : * mut :: std :: os :: raw :: c_void , msg : * const :: std :: os :: raw :: c_char , ... ) ; } extern "C" { pub fn av_register_hwaccel ( hwaccel : * mut AVHWAccel ) ; } extern "C" { pub fn av_hwaccel_next ( hwaccel : * const AVHWAccel ) -> * mut AVHWAccel ; } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum AVLockOp { AV_LOCK_CREATE = 0 , AV_LOCK_OBTAIN = 1 , AV_LOCK_RELEASE = 2 , AV_LOCK_DESTROY = 3 , } extern "C" { pub fn av_lockmgr_register ( cb : :: std :: option :: Option < unsafe extern "C" fn ( mutex : * mut * mut :: std :: os :: raw :: c_void , op : AVLockOp ) -> :: std :: os :: raw :: c_int > ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avcodec_get_type ( codec_id : AVCodecID ) -> AVMediaType ; } extern "C" { pub fn avcodec_get_name ( id : AVCodecID ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn avcodec_is_open ( s : * mut AVCodecContext ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_codec_is_encoder ( codec : * const AVCodec ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_codec_is_decoder ( codec : * const AVCodec ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avcodec_descriptor_get ( id : AVCodecID ) -> * const AVCodecDescriptor ; } extern "C" { pub fn avcodec_descriptor_next ( prev : * const AVCodecDescriptor ) -> * const AVCodecDescriptor ; } extern "C" { pub fn avcodec_descriptor_get_by_name ( name : * const :: std :: os :: raw :: c_char ) -> * const AVCodecDescriptor ; } extern "C" { pub fn av_cpb_properties_alloc ( size : * mut usize ) -> * mut AVCPBProperties ; } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVIOInterruptCB { pub callback : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > , pub opaque : * mut :: std :: os :: raw :: c_void } # [ test ] fn bindgen_test_layout_AVIOInterruptCB ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVIOInterruptCB > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( AVIOInterruptCB ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVIOInterruptCB > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVIOInterruptCB ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOInterruptCB ) ) . callback as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOInterruptCB ) , "::" , stringify ! ( callback ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOInterruptCB ) ) . opaque as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOInterruptCB ) , "::" , stringify ! ( opaque ) ) ) ; } impl Clone for AVIOInterruptCB { fn clone ( & self ) -> Self { * self } } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum AVIODirEntryType { AVIO_ENTRY_UNKNOWN = 0 , AVIO_ENTRY_BLOCK_DEVICE = 1 , AVIO_ENTRY_CHARACTER_DEVICE = 2 , AVIO_ENTRY_DIRECTORY = 3 , AVIO_ENTRY_NAMED_PIPE = 4 , AVIO_ENTRY_SYMBOLIC_LINK = 5 , AVIO_ENTRY_SOCKET = 6 , AVIO_ENTRY_FILE = 7 , AVIO_ENTRY_SERVER = 8 , AVIO_ENTRY_SHARE = 9 , AVIO_ENTRY_WORKGROUP = 10 , } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVIODirEntry { pub name : * mut :: std :: os :: raw :: c_char , pub type_ : :: std :: os :: raw :: c_int , pub utf8 : :: std :: os :: raw :: c_int , pub size : i64 , pub modification_timestamp : i64 , pub access_timestamp : i64 , pub status_change_timestamp : i64 , pub user_id : i64 , pub group_id : i64 , pub filemode : i64 } # [ test ] fn bindgen_test_layout_AVIODirEntry ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVIODirEntry > ( ) , 72usize , concat ! ( "Size of: " , stringify ! ( AVIODirEntry ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVIODirEntry > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVIODirEntry ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIODirEntry ) ) . name as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVIODirEntry ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIODirEntry ) ) . type_ as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AVIODirEntry ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIODirEntry ) ) . utf8 as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( AVIODirEntry ) , "::" , stringify ! ( utf8 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIODirEntry ) ) . size as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( AVIODirEntry ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIODirEntry ) ) . modification_timestamp as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( AVIODirEntry ) , "::" , stringify ! ( modification_timestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIODirEntry ) ) . access_timestamp as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( AVIODirEntry ) , "::" , stringify ! ( access_timestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIODirEntry ) ) . status_change_timestamp as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( AVIODirEntry ) , "::" , stringify ! ( status_change_timestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIODirEntry ) ) . user_id as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( AVIODirEntry ) , "::" , stringify ! ( user_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIODirEntry ) ) . group_id as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( AVIODirEntry ) , "::" , stringify ! ( group_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIODirEntry ) ) . filemode as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( AVIODirEntry ) , "::" , stringify ! ( filemode ) ) ) ; } impl Clone for AVIODirEntry { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVIODirContext { pub url_context : * mut URLContext } # [ test ] fn bindgen_test_layout_AVIODirContext ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVIODirContext > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( AVIODirContext ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVIODirContext > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVIODirContext ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIODirContext ) ) . url_context as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVIODirContext ) , "::" , stringify ! ( url_context ) ) ) ; } impl Clone for AVIODirContext { fn clone ( & self ) -> Self { * self } } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum AVIODataMarkerType { AVIO_DATA_MARKER_HEADER = 0 , AVIO_DATA_MARKER_SYNC_POINT = 1 , AVIO_DATA_MARKER_BOUNDARY_POINT = 2 , AVIO_DATA_MARKER_UNKNOWN = 3 , AVIO_DATA_MARKER_TRAILER = 4 , } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVIOContext { pub av_class : * const AVClass , pub buffer : * mut :: std :: os :: raw :: c_uchar , pub buffer_size : :: std :: os :: raw :: c_int , pub buf_ptr : * mut :: std :: os :: raw :: c_uchar , pub buf_end : * mut :: std :: os :: raw :: c_uchar , pub opaque : * mut :: std :: os :: raw :: c_void , pub read_packet : :: std :: option :: Option < unsafe extern "C" fn ( opaque : * mut :: std :: os :: raw :: c_void , buf : * mut u8 , buf_size : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > , pub write_packet : :: std :: option :: Option < unsafe extern "C" fn ( opaque : * mut :: std :: os :: raw :: c_void , buf : * mut u8 , buf_size : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > , pub seek : :: std :: option :: Option < unsafe extern "C" fn ( opaque : * mut :: std :: os :: raw :: c_void , offset : i64 , whence : :: std :: os :: raw :: c_int ) -> i64 > , pub pos : i64 , pub must_flush : :: std :: os :: raw :: c_int , pub eof_reached : :: std :: os :: raw :: c_int , pub write_flag : :: std :: os :: raw :: c_int , pub max_packet_size : :: std :: os :: raw :: c_int , pub checksum : :: std :: os :: raw :: c_ulong , pub checksum_ptr : * mut :: std :: os :: raw :: c_uchar , pub update_checksum : :: std :: option :: Option < unsafe extern "C" fn ( checksum : :: std :: os :: raw :: c_ulong , buf : * const u8 , size : :: std :: os :: raw :: c_uint ) -> :: std :: os :: raw :: c_ulong > , pub error : :: std :: os :: raw :: c_int , pub read_pause : :: std :: option :: Option < unsafe extern "C" fn ( opaque : * mut :: std :: os :: raw :: c_void , pause : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > , pub read_seek : :: std :: option :: Option < unsafe extern "C" fn ( opaque : * mut :: std :: os :: raw :: c_void , stream_index : :: std :: os :: raw :: c_int , timestamp : i64 , flags : :: std :: os :: raw :: c_int ) -> i64 > , pub seekable : :: std :: os :: raw :: c_int , pub maxsize : i64 , pub direct : :: std :: os :: raw :: c_int , pub bytes_read : i64 , pub seek_count : :: std :: os :: raw :: c_int , pub writeout_count : :: std :: os :: raw :: c_int , pub orig_buffer_size : :: std :: os :: raw :: c_int , pub short_seek_threshold : :: std :: os :: raw :: c_int , pub protocol_whitelist : * const :: std :: os :: raw :: c_char , pub protocol_blacklist : * const :: std :: os :: raw :: c_char , pub write_data_type : :: std :: option :: Option < unsafe extern "C" fn ( opaque : * mut :: std :: os :: raw :: c_void , buf : * mut u8 , buf_size : :: std :: os :: raw :: c_int , type_ : AVIODataMarkerType , time : i64 ) -> :: std :: os :: raw :: c_int > , pub ignore_boundary_point : :: std :: os :: raw :: c_int , pub current_type : AVIODataMarkerType , pub last_time : i64 , pub short_seek_get : :: std :: option :: Option < unsafe extern "C" fn ( opaque : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > } # [ test ] fn bindgen_test_layout_AVIOContext ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVIOContext > ( ) , 240usize , concat ! ( "Size of: " , stringify ! ( AVIOContext ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVIOContext > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVIOContext ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . av_class as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( av_class ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . buffer as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( buffer ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . buffer_size as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( buffer_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . buf_ptr as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( buf_ptr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . buf_end as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( buf_end ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . opaque as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( opaque ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . read_packet as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( read_packet ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . write_packet as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( write_packet ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . seek as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( seek ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . pos as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( pos ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . must_flush as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( must_flush ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . eof_reached as * const _ as usize } , 84usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( eof_reached ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . write_flag as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( write_flag ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . max_packet_size as * const _ as usize } , 92usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( max_packet_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . checksum as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( checksum ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . checksum_ptr as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( checksum_ptr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . update_checksum as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( update_checksum ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . error as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( error ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . read_pause as * const _ as usize } , 128usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( read_pause ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . read_seek as * const _ as usize } , 136usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( read_seek ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . seekable as * const _ as usize } , 144usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( seekable ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . maxsize as * const _ as usize } , 152usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( maxsize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . direct as * const _ as usize } , 160usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( direct ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . bytes_read as * const _ as usize } , 168usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( bytes_read ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . seek_count as * const _ as usize } , 176usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( seek_count ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . writeout_count as * const _ as usize } , 180usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( writeout_count ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . orig_buffer_size as * const _ as usize } , 184usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( orig_buffer_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . short_seek_threshold as * const _ as usize } , 188usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( short_seek_threshold ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . protocol_whitelist as * const _ as usize } , 192usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( protocol_whitelist ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . protocol_blacklist as * const _ as usize } , 200usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( protocol_blacklist ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . write_data_type as * const _ as usize } , 208usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( write_data_type ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . ignore_boundary_point as * const _ as usize } , 216usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( ignore_boundary_point ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . current_type as * const _ as usize } , 220usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( current_type ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . last_time as * const _ as usize } , 224usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( last_time ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIOContext ) ) . short_seek_get as * const _ as usize } , 232usize , concat ! ( "Alignment of field: " , stringify ! ( AVIOContext ) , "::" , stringify ! ( short_seek_get ) ) ) ; } impl Clone for AVIOContext { fn clone ( & self ) -> Self { * self } } extern "C" { pub fn avio_find_protocol_name ( url : * const :: std :: os :: raw :: c_char ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn avio_check ( url : * const :: std :: os :: raw :: c_char , flags : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avpriv_io_move ( url_src : * const :: std :: os :: raw :: c_char , url_dst : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avpriv_io_delete ( url : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avio_open_dir ( s : * mut * mut AVIODirContext , url : * const :: std :: os :: raw :: c_char , options : * mut * mut AVDictionary ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avio_read_dir ( s : * mut AVIODirContext , next : * mut * mut AVIODirEntry ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avio_close_dir ( s : * mut * mut AVIODirContext ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avio_free_directory_entry ( entry : * mut * mut AVIODirEntry ) ; } extern "C" { pub fn avio_alloc_context ( buffer : * mut :: std :: os :: raw :: c_uchar , buffer_size : :: std :: os :: raw :: c_int , write_flag : :: std :: os :: raw :: c_int , opaque : * mut :: std :: os :: raw :: c_void , read_packet : :: std :: option :: Option < unsafe extern "C" fn ( opaque : * mut :: std :: os :: raw :: c_void , buf : * mut u8 , buf_size : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > , write_packet : :: std :: option :: Option < unsafe extern "C" fn ( opaque : * mut :: std :: os :: raw :: c_void , buf : * mut u8 , buf_size : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > , seek : :: std :: option :: Option < unsafe extern "C" fn ( opaque : * mut :: std :: os :: raw :: c_void , offset : i64 , whence : :: std :: os :: raw :: c_int ) -> i64 > ) -> * mut AVIOContext ; } extern "C" { pub fn avio_w8 ( s : * mut AVIOContext , b : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn avio_write ( s : * mut AVIOContext , buf : * const :: std :: os :: raw :: c_uchar , size : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn avio_wl64 ( s : * mut AVIOContext , val : u64 ) ; } extern "C" { pub fn avio_wb64 ( s : * mut AVIOContext , val : u64 ) ; } extern "C" { pub fn avio_wl32 ( s : * mut AVIOContext , val : :: std :: os :: raw :: c_uint ) ; } extern "C" { pub fn avio_wb32 ( s : * mut AVIOContext , val : :: std :: os :: raw :: c_uint ) ; } extern "C" { pub fn avio_wl24 ( s : * mut AVIOContext , val : :: std :: os :: raw :: c_uint ) ; } extern "C" { pub fn avio_wb24 ( s : * mut AVIOContext , val : :: std :: os :: raw :: c_uint ) ; } extern "C" { pub fn avio_wl16 ( s : * mut AVIOContext , val : :: std :: os :: raw :: c_uint ) ; } extern "C" { pub fn avio_wb16 ( s : * mut AVIOContext , val : :: std :: os :: raw :: c_uint ) ; } extern "C" { pub fn avio_put_str ( s : * mut AVIOContext , str : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avio_put_str16le ( s : * mut AVIOContext , str : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avio_put_str16be ( s : * mut AVIOContext , str : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avio_write_marker ( s : * mut AVIOContext , time : i64 , type_ : AVIODataMarkerType ) ; } extern "C" { pub fn avio_seek ( s : * mut AVIOContext , offset : i64 , whence : :: std :: os :: raw :: c_int ) -> i64 ; } extern "C" { pub fn avio_skip ( s : * mut AVIOContext , offset : i64 ) -> i64 ; } extern "C" { pub fn avio_size ( s : * mut AVIOContext ) -> i64 ; } extern "C" { pub fn avio_feof ( s : * mut AVIOContext ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avio_printf ( s : * mut AVIOContext , fmt : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avio_flush ( s : * mut AVIOContext ) ; } extern "C" { pub fn avio_read ( s : * mut AVIOContext , buf : * mut :: std :: os :: raw :: c_uchar , size : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avio_r8 ( s : * mut AVIOContext ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avio_rl16 ( s : * mut AVIOContext ) -> :: std :: os :: raw :: c_uint ; } extern "C" { pub fn avio_rl24 ( s : * mut AVIOContext ) -> :: std :: os :: raw :: c_uint ; } extern "C" { pub fn avio_rl32 ( s : * mut AVIOContext ) -> :: std :: os :: raw :: c_uint ; } extern "C" { pub fn avio_rl64 ( s : * mut AVIOContext ) -> u64 ; } extern "C" { pub fn avio_rb16 ( s : * mut AVIOContext ) -> :: std :: os :: raw :: c_uint ; } extern "C" { pub fn avio_rb24 ( s : * mut AVIOContext ) -> :: std :: os :: raw :: c_uint ; } extern "C" { pub fn avio_rb32 ( s : * mut AVIOContext ) -> :: std :: os :: raw :: c_uint ; } extern "C" { pub fn avio_rb64 ( s : * mut AVIOContext ) -> u64 ; } extern "C" { pub fn avio_get_str ( pb : * mut AVIOContext , maxlen : :: std :: os :: raw :: c_int , buf : * mut :: std :: os :: raw :: c_char , buflen : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avio_get_str16le ( pb : * mut AVIOContext , maxlen : :: std :: os :: raw :: c_int , buf : * mut :: std :: os :: raw :: c_char , buflen : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avio_get_str16be ( pb : * mut AVIOContext , maxlen : :: std :: os :: raw :: c_int , buf : * mut :: std :: os :: raw :: c_char , buflen : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avio_open ( s : * mut * mut AVIOContext , url : * const :: std :: os :: raw :: c_char , flags : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avio_open2 ( s : * mut * mut AVIOContext , url : * const :: std :: os :: raw :: c_char , flags : :: std :: os :: raw :: c_int , int_cb : * const AVIOInterruptCB , options : * mut * mut AVDictionary ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avio_close ( s : * mut AVIOContext ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avio_closep ( s : * mut * mut AVIOContext ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avio_open_dyn_buf ( s : * mut * mut AVIOContext ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avio_get_dyn_buf ( s : * mut AVIOContext , pbuffer : * mut * mut u8 ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avio_close_dyn_buf ( s : * mut AVIOContext , pbuffer : * mut * mut u8 ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avio_enum_protocols ( opaque : * mut * mut :: std :: os :: raw :: c_void , output : :: std :: os :: raw :: c_int ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn avio_pause ( h : * mut AVIOContext , pause : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avio_seek_time ( h : * mut AVIOContext , stream_index : :: std :: os :: raw :: c_int , timestamp : i64 , flags : :: std :: os :: raw :: c_int ) -> i64 ; } extern "C" { pub fn avio_read_to_bprint ( h : * mut AVIOContext , pb : * mut AVBPrint , max_size : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avio_accept ( s : * mut AVIOContext , c : * mut * mut AVIOContext ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avio_handshake ( c : * mut AVIOContext ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] pub struct AVFormatContext { pub av_class : * const AVClass , pub iformat : * mut AVInputFormat , pub oformat : * mut AVOutputFormat , pub priv_data : * mut :: std :: os :: raw :: c_void , pub pb : * mut AVIOContext , pub ctx_flags : :: std :: os :: raw :: c_int , pub nb_streams : :: std :: os :: raw :: c_uint , pub streams : * mut * mut AVStream , pub filename : [ :: std :: os :: raw :: c_char ; 1024usize ] , pub start_time : i64 , pub duration : i64 , pub bit_rate : i64 , pub packet_size : :: std :: os :: raw :: c_uint , pub max_delay : :: std :: os :: raw :: c_int , pub flags : :: std :: os :: raw :: c_int , pub probesize : i64 , pub max_analyze_duration : i64 , pub key : * const u8 , pub keylen : :: std :: os :: raw :: c_int , pub nb_programs : :: std :: os :: raw :: c_uint , pub programs : * mut * mut AVProgram , pub video_codec_id : AVCodecID , pub audio_codec_id : AVCodecID , pub subtitle_codec_id : AVCodecID , pub max_index_size : :: std :: os :: raw :: c_uint , pub max_picture_buffer : :: std :: os :: raw :: c_uint , pub nb_chapters : :: std :: os :: raw :: c_uint , pub chapters : * mut * mut AVChapter , pub metadata : * mut AVDictionary , pub start_time_realtime : i64 , pub fps_probe_size : :: std :: os :: raw :: c_int , pub error_recognition : :: std :: os :: raw :: c_int , pub interrupt_callback : AVIOInterruptCB , pub debug : :: std :: os :: raw :: c_int , pub max_interleave_delta : i64 , pub strict_std_compliance : :: std :: os :: raw :: c_int , pub event_flags : :: std :: os :: raw :: c_int , pub max_ts_probe : :: std :: os :: raw :: c_int , pub avoid_negative_ts : :: std :: os :: raw :: c_int , pub ts_id : :: std :: os :: raw :: c_int , pub audio_preload : :: std :: os :: raw :: c_int , pub max_chunk_duration : :: std :: os :: raw :: c_int , pub max_chunk_size : :: std :: os :: raw :: c_int , pub use_wallclock_as_timestamps : :: std :: os :: raw :: c_int , pub avio_flags : :: std :: os :: raw :: c_int , pub duration_estimation_method : AVDurationEstimationMethod , pub skip_initial_bytes : i64 , pub correct_ts_overflow : :: std :: os :: raw :: c_uint , pub seek2any : :: std :: os :: raw :: c_int , pub flush_packets : :: std :: os :: raw :: c_int , pub probe_score : :: std :: os :: raw :: c_int , pub format_probesize : :: std :: os :: raw :: c_int , pub codec_whitelist : * mut :: std :: os :: raw :: c_char , pub format_whitelist : * mut :: std :: os :: raw :: c_char , pub internal : * mut AVFormatInternal , pub io_repositioned : :: std :: os :: raw :: c_int , pub video_codec : * mut AVCodec , pub audio_codec : * mut AVCodec , pub subtitle_codec : * mut AVCodec , pub data_codec : * mut AVCodec , pub metadata_header_padding : :: std :: os :: raw :: c_int , pub opaque : * mut :: std :: os :: raw :: c_void , pub control_message_cb : av_format_control_message , pub output_ts_offset : i64 , pub dump_separator : * mut u8 , pub data_codec_id : AVCodecID , pub open_cb : :: std :: option :: Option < unsafe extern "C" fn ( s : * mut AVFormatContext , p : * mut * mut AVIOContext , url : * const :: std :: os :: raw :: c_char , flags : :: std :: os :: raw :: c_int , int_cb : * const AVIOInterruptCB , options : * mut * mut AVDictionary ) -> :: std :: os :: raw :: c_int > , pub protocol_whitelist : * mut :: std :: os :: raw :: c_char , pub io_open : :: std :: option :: Option < unsafe extern "C" fn ( s : * mut AVFormatContext , pb : * mut * mut AVIOContext , url : * const :: std :: os :: raw :: c_char , flags : :: std :: os :: raw :: c_int , options : * mut * mut AVDictionary ) -> :: std :: os :: raw :: c_int > , pub io_close : :: std :: option :: Option < unsafe extern "C" fn ( s : * mut AVFormatContext , pb : * mut AVIOContext ) > , pub protocol_blacklist : * mut :: std :: os :: raw :: c_char , pub max_streams : :: std :: os :: raw :: c_int } # [ test ] fn bindgen_test_layout_AVFormatContext ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVFormatContext > ( ) , 1488usize , concat ! ( "Size of: " , stringify ! ( AVFormatContext ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVFormatContext > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVFormatContext ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . av_class as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( av_class ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . iformat as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( iformat ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . oformat as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( oformat ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . priv_data as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( priv_data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . pb as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( pb ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . ctx_flags as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( ctx_flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . nb_streams as * const _ as usize } , 44usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( nb_streams ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . streams as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( streams ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . filename as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( filename ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . start_time as * const _ as usize } , 1080usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( start_time ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . duration as * const _ as usize } , 1088usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( duration ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . bit_rate as * const _ as usize } , 1096usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( bit_rate ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . packet_size as * const _ as usize } , 1104usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( packet_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . max_delay as * const _ as usize } , 1108usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( max_delay ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . flags as * const _ as usize } , 1112usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . probesize as * const _ as usize } , 1120usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( probesize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . max_analyze_duration as * const _ as usize } , 1128usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( max_analyze_duration ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . key as * const _ as usize } , 1136usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( key ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . keylen as * const _ as usize } , 1144usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( keylen ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . nb_programs as * const _ as usize } , 1148usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( nb_programs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . programs as * const _ as usize } , 1152usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( programs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . video_codec_id as * const _ as usize } , 1160usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( video_codec_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . audio_codec_id as * const _ as usize } , 1164usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( audio_codec_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . subtitle_codec_id as * const _ as usize } , 1168usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( subtitle_codec_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . max_index_size as * const _ as usize } , 1172usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( max_index_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . max_picture_buffer as * const _ as usize } , 1176usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( max_picture_buffer ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . nb_chapters as * const _ as usize } , 1180usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( nb_chapters ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . chapters as * const _ as usize } , 1184usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( chapters ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . metadata as * const _ as usize } , 1192usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( metadata ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . start_time_realtime as * const _ as usize } , 1200usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( start_time_realtime ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . fps_probe_size as * const _ as usize } , 1208usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( fps_probe_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . error_recognition as * const _ as usize } , 1212usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( error_recognition ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . interrupt_callback as * const _ as usize } , 1216usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( interrupt_callback ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . debug as * const _ as usize } , 1232usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( debug ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . max_interleave_delta as * const _ as usize } , 1240usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( max_interleave_delta ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . strict_std_compliance as * const _ as usize } , 1248usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( strict_std_compliance ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . event_flags as * const _ as usize } , 1252usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( event_flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . max_ts_probe as * const _ as usize } , 1256usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( max_ts_probe ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . avoid_negative_ts as * const _ as usize } , 1260usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( avoid_negative_ts ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . ts_id as * const _ as usize } , 1264usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( ts_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . audio_preload as * const _ as usize } , 1268usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( audio_preload ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . max_chunk_duration as * const _ as usize } , 1272usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( max_chunk_duration ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . max_chunk_size as * const _ as usize } , 1276usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( max_chunk_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . use_wallclock_as_timestamps as * const _ as usize } , 1280usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( use_wallclock_as_timestamps ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . avio_flags as * const _ as usize } , 1284usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( avio_flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . duration_estimation_method as * const _ as usize } , 1288usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( duration_estimation_method ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . skip_initial_bytes as * const _ as usize } , 1296usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( skip_initial_bytes ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . correct_ts_overflow as * const _ as usize } , 1304usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( correct_ts_overflow ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . seek2any as * const _ as usize } , 1308usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( seek2any ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . flush_packets as * const _ as usize } , 1312usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( flush_packets ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . probe_score as * const _ as usize } , 1316usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( probe_score ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . format_probesize as * const _ as usize } , 1320usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( format_probesize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . codec_whitelist as * const _ as usize } , 1328usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( codec_whitelist ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . format_whitelist as * const _ as usize } , 1336usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( format_whitelist ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . internal as * const _ as usize } , 1344usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( internal ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . io_repositioned as * const _ as usize } , 1352usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( io_repositioned ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . video_codec as * const _ as usize } , 1360usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( video_codec ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . audio_codec as * const _ as usize } , 1368usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( audio_codec ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . subtitle_codec as * const _ as usize } , 1376usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( subtitle_codec ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . data_codec as * const _ as usize } , 1384usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( data_codec ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . metadata_header_padding as * const _ as usize } , 1392usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( metadata_header_padding ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . opaque as * const _ as usize } , 1400usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( opaque ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . control_message_cb as * const _ as usize } , 1408usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( control_message_cb ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . output_ts_offset as * const _ as usize } , 1416usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( output_ts_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . dump_separator as * const _ as usize } , 1424usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( dump_separator ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . data_codec_id as * const _ as usize } , 1432usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( data_codec_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . open_cb as * const _ as usize } , 1440usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( open_cb ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . protocol_whitelist as * const _ as usize } , 1448usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( protocol_whitelist ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . io_open as * const _ as usize } , 1456usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( io_open ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . io_close as * const _ as usize } , 1464usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( io_close ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . protocol_blacklist as * const _ as usize } , 1472usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( protocol_blacklist ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFormatContext ) ) . max_streams as * const _ as usize } , 1480usize , concat ! ( "Alignment of field: " , stringify ! ( AVFormatContext ) , "::" , stringify ! ( max_streams ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct AVDeviceInfoList ( [ u8 ; 0 ] ) ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct AVDeviceCapabilitiesQuery ( [ u8 ; 0 ] ) ; extern "C" { pub fn av_get_packet ( s : * mut AVIOContext , pkt : * mut AVPacket , size : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_append_packet ( s : * mut AVIOContext , pkt : * mut AVPacket , size : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVFrac { pub val : i64 , pub num : i64 , pub den : i64 } # [ test ] fn bindgen_test_layout_AVFrac ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVFrac > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( AVFrac ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVFrac > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVFrac ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrac ) ) . val as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrac ) , "::" , stringify ! ( val ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrac ) ) . num as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrac ) , "::" , stringify ! ( num ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVFrac ) ) . den as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( AVFrac ) , "::" , stringify ! ( den ) ) ) ; } impl Clone for AVFrac { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct AVCodecTag ( [ u8 ; 0 ] ) ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVProbeData { pub filename : * const :: std :: os :: raw :: c_char , pub buf : * mut :: std :: os :: raw :: c_uchar , pub buf_size : :: std :: os :: raw :: c_int , pub mime_type : * const :: std :: os :: raw :: c_char } # [ test ] fn bindgen_test_layout_AVProbeData ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVProbeData > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( AVProbeData ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVProbeData > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVProbeData ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVProbeData ) ) . filename as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVProbeData ) , "::" , stringify ! ( filename ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVProbeData ) ) . buf as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AVProbeData ) , "::" , stringify ! ( buf ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVProbeData ) ) . buf_size as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( AVProbeData ) , "::" , stringify ! ( buf_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVProbeData ) ) . mime_type as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( AVProbeData ) , "::" , stringify ! ( mime_type ) ) ) ; } impl Clone for AVProbeData { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVOutputFormat { pub name : * const :: std :: os :: raw :: c_char , pub long_name : * const :: std :: os :: raw :: c_char , pub mime_type : * const :: std :: os :: raw :: c_char , pub extensions : * const :: std :: os :: raw :: c_char , pub audio_codec : AVCodecID , pub video_codec : AVCodecID , pub subtitle_codec : AVCodecID , pub flags : :: std :: os :: raw :: c_int , pub codec_tag : * const * const AVCodecTag , pub priv_class : * const AVClass , pub next : * mut AVOutputFormat , pub priv_data_size : :: std :: os :: raw :: c_int , pub write_header : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut AVFormatContext ) -> :: std :: os :: raw :: c_int > , pub write_packet : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut AVFormatContext , pkt : * mut AVPacket ) -> :: std :: os :: raw :: c_int > , pub write_trailer : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut AVFormatContext ) -> :: std :: os :: raw :: c_int > , pub interleave_packet : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut AVFormatContext , out : * mut AVPacket , in_ : * mut AVPacket , flush : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > , pub query_codec : :: std :: option :: Option < unsafe extern "C" fn ( id : AVCodecID , std_compliance : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > , pub get_output_timestamp : :: std :: option :: Option < unsafe extern "C" fn ( s : * mut AVFormatContext , stream : :: std :: os :: raw :: c_int , dts : * mut i64 , wall : * mut i64 ) > , pub control_message : :: std :: option :: Option < unsafe extern "C" fn ( s : * mut AVFormatContext , type_ : :: std :: os :: raw :: c_int , data : * mut :: std :: os :: raw :: c_void , data_size : usize ) -> :: std :: os :: raw :: c_int > , pub write_uncoded_frame : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut AVFormatContext , stream_index : :: std :: os :: raw :: c_int , frame : * mut * mut AVFrame , flags : :: std :: os :: raw :: c_uint ) -> :: std :: os :: raw :: c_int > , pub get_device_list : :: std :: option :: Option < unsafe extern "C" fn ( s : * mut AVFormatContext , device_list : * mut AVDeviceInfoList ) -> :: std :: os :: raw :: c_int > , pub create_device_capabilities : :: std :: option :: Option < unsafe extern "C" fn ( s : * mut AVFormatContext , caps : * mut AVDeviceCapabilitiesQuery ) -> :: std :: os :: raw :: c_int > , pub free_device_capabilities : :: std :: option :: Option < unsafe extern "C" fn ( s : * mut AVFormatContext , caps : * mut AVDeviceCapabilitiesQuery ) -> :: std :: os :: raw :: c_int > , pub data_codec : AVCodecID , pub init : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut AVFormatContext ) -> :: std :: os :: raw :: c_int > , pub deinit : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut AVFormatContext ) > , pub check_bitstream : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut AVFormatContext , pkt : * const AVPacket ) -> :: std :: os :: raw :: c_int > } # [ test ] fn bindgen_test_layout_AVOutputFormat ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVOutputFormat > ( ) , 200usize , concat ! ( "Size of: " , stringify ! ( AVOutputFormat ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVOutputFormat > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVOutputFormat ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVOutputFormat ) ) . name as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVOutputFormat ) ) . long_name as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::" , stringify ! ( long_name ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVOutputFormat ) ) . mime_type as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::" , stringify ! ( mime_type ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVOutputFormat ) ) . extensions as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::" , stringify ! ( extensions ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVOutputFormat ) ) . audio_codec as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::" , stringify ! ( audio_codec ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVOutputFormat ) ) . video_codec as * const _ as usize } , 36usize , concat ! ( "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::" , stringify ! ( video_codec ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVOutputFormat ) ) . subtitle_codec as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::" , stringify ! ( subtitle_codec ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVOutputFormat ) ) . flags as * const _ as usize } , 44usize , concat ! ( "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::" , stringify ! ( flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVOutputFormat ) ) . codec_tag as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::" , stringify ! ( codec_tag ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVOutputFormat ) ) . priv_class as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::" , stringify ! ( priv_class ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVOutputFormat ) ) . next as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::" , stringify ! ( next ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVOutputFormat ) ) . priv_data_size as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::" , stringify ! ( priv_data_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVOutputFormat ) ) . write_header as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::" , stringify ! ( write_header ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVOutputFormat ) ) . write_packet as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::" , stringify ! ( write_packet ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVOutputFormat ) ) . write_trailer as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::" , stringify ! ( write_trailer ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVOutputFormat ) ) . interleave_packet as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::" , stringify ! ( interleave_packet ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVOutputFormat ) ) . query_codec as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::" , stringify ! ( query_codec ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVOutputFormat ) ) . get_output_timestamp as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::" , stringify ! ( get_output_timestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVOutputFormat ) ) . control_message as * const _ as usize } , 128usize , concat ! ( "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::" , stringify ! ( control_message ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVOutputFormat ) ) . write_uncoded_frame as * const _ as usize } , 136usize , concat ! ( "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::" , stringify ! ( write_uncoded_frame ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVOutputFormat ) ) . get_device_list as * const _ as usize } , 144usize , concat ! ( "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::" , stringify ! ( get_device_list ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVOutputFormat ) ) . create_device_capabilities as * const _ as usize } , 152usize , concat ! ( "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::" , stringify ! ( create_device_capabilities ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVOutputFormat ) ) . free_device_capabilities as * const _ as usize } , 160usize , concat ! ( "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::" , stringify ! ( free_device_capabilities ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVOutputFormat ) ) . data_codec as * const _ as usize } , 168usize , concat ! ( "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::" , stringify ! ( data_codec ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVOutputFormat ) ) . init as * const _ as usize } , 176usize , concat ! ( "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::" , stringify ! ( init ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVOutputFormat ) ) . deinit as * const _ as usize } , 184usize , concat ! ( "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::" , stringify ! ( deinit ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVOutputFormat ) ) . check_bitstream as * const _ as usize } , 192usize , concat ! ( "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::" , stringify ! ( check_bitstream ) ) ) ; } impl Clone for AVOutputFormat { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVInputFormat { pub name : * const :: std :: os :: raw :: c_char , pub long_name : * const :: std :: os :: raw :: c_char , pub flags : :: std :: os :: raw :: c_int , pub extensions : * const :: std :: os :: raw :: c_char , pub codec_tag : * const * const AVCodecTag , pub priv_class : * const AVClass , pub mime_type : * const :: std :: os :: raw :: c_char , pub next : * mut AVInputFormat , pub raw_codec_id : :: std :: os :: raw :: c_int , pub priv_data_size : :: std :: os :: raw :: c_int , pub read_probe : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut AVProbeData ) -> :: std :: os :: raw :: c_int > , pub read_header : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut AVFormatContext ) -> :: std :: os :: raw :: c_int > , pub read_packet : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut AVFormatContext , pkt : * mut AVPacket ) -> :: std :: os :: raw :: c_int > , pub read_close : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut AVFormatContext ) -> :: std :: os :: raw :: c_int > , pub read_seek : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut AVFormatContext , stream_index : :: std :: os :: raw :: c_int , timestamp : i64 , flags : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > , pub read_timestamp : :: std :: option :: Option < unsafe extern "C" fn ( s : * mut AVFormatContext , stream_index : :: std :: os :: raw :: c_int , pos : * mut i64 , pos_limit : i64 ) -> i64 > , pub read_play : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut AVFormatContext ) -> :: std :: os :: raw :: c_int > , pub read_pause : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut AVFormatContext ) -> :: std :: os :: raw :: c_int > , pub read_seek2 : :: std :: option :: Option < unsafe extern "C" fn ( s : * mut AVFormatContext , stream_index : :: std :: os :: raw :: c_int , min_ts : i64 , ts : i64 , max_ts : i64 , flags : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > , pub get_device_list : :: std :: option :: Option < unsafe extern "C" fn ( s : * mut AVFormatContext , device_list : * mut AVDeviceInfoList ) -> :: std :: os :: raw :: c_int > , pub create_device_capabilities : :: std :: option :: Option < unsafe extern "C" fn ( s : * mut AVFormatContext , caps : * mut AVDeviceCapabilitiesQuery ) -> :: std :: os :: raw :: c_int > , pub free_device_capabilities : :: std :: option :: Option < unsafe extern "C" fn ( s : * mut AVFormatContext , caps : * mut AVDeviceCapabilitiesQuery ) -> :: std :: os :: raw :: c_int > } # [ test ] fn bindgen_test_layout_AVInputFormat ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVInputFormat > ( ) , 168usize , concat ! ( "Size of: " , stringify ! ( AVInputFormat ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVInputFormat > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVInputFormat ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVInputFormat ) ) . name as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVInputFormat ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVInputFormat ) ) . long_name as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AVInputFormat ) , "::" , stringify ! ( long_name ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVInputFormat ) ) . flags as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( AVInputFormat ) , "::" , stringify ! ( flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVInputFormat ) ) . extensions as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( AVInputFormat ) , "::" , stringify ! ( extensions ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVInputFormat ) ) . codec_tag as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( AVInputFormat ) , "::" , stringify ! ( codec_tag ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVInputFormat ) ) . priv_class as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( AVInputFormat ) , "::" , stringify ! ( priv_class ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVInputFormat ) ) . mime_type as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( AVInputFormat ) , "::" , stringify ! ( mime_type ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVInputFormat ) ) . next as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( AVInputFormat ) , "::" , stringify ! ( next ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVInputFormat ) ) . raw_codec_id as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( AVInputFormat ) , "::" , stringify ! ( raw_codec_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVInputFormat ) ) . priv_data_size as * const _ as usize } , 68usize , concat ! ( "Alignment of field: " , stringify ! ( AVInputFormat ) , "::" , stringify ! ( priv_data_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVInputFormat ) ) . read_probe as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( AVInputFormat ) , "::" , stringify ! ( read_probe ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVInputFormat ) ) . read_header as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( AVInputFormat ) , "::" , stringify ! ( read_header ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVInputFormat ) ) . read_packet as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( AVInputFormat ) , "::" , stringify ! ( read_packet ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVInputFormat ) ) . read_close as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( AVInputFormat ) , "::" , stringify ! ( read_close ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVInputFormat ) ) . read_seek as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( AVInputFormat ) , "::" , stringify ! ( read_seek ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVInputFormat ) ) . read_timestamp as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( AVInputFormat ) , "::" , stringify ! ( read_timestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVInputFormat ) ) . read_play as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( AVInputFormat ) , "::" , stringify ! ( read_play ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVInputFormat ) ) . read_pause as * const _ as usize } , 128usize , concat ! ( "Alignment of field: " , stringify ! ( AVInputFormat ) , "::" , stringify ! ( read_pause ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVInputFormat ) ) . read_seek2 as * const _ as usize } , 136usize , concat ! ( "Alignment of field: " , stringify ! ( AVInputFormat ) , "::" , stringify ! ( read_seek2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVInputFormat ) ) . get_device_list as * const _ as usize } , 144usize , concat ! ( "Alignment of field: " , stringify ! ( AVInputFormat ) , "::" , stringify ! ( get_device_list ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVInputFormat ) ) . create_device_capabilities as * const _ as usize } , 152usize , concat ! ( "Alignment of field: " , stringify ! ( AVInputFormat ) , "::" , stringify ! ( create_device_capabilities ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVInputFormat ) ) . free_device_capabilities as * const _ as usize } , 160usize , concat ! ( "Alignment of field: " , stringify ! ( AVInputFormat ) , "::" , stringify ! ( free_device_capabilities ) ) ) ; } impl Clone for AVInputFormat { fn clone ( & self ) -> Self { * self } } # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum AVStreamParseType { AVSTREAM_PARSE_NONE = 0 , AVSTREAM_PARSE_FULL = 1 , AVSTREAM_PARSE_HEADERS = 2 , AVSTREAM_PARSE_TIMESTAMPS = 3 , AVSTREAM_PARSE_FULL_ONCE = 4 , AVSTREAM_PARSE_FULL_RAW = 1463898624 , } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVIndexEntry { pub pos : i64 , pub timestamp : i64 , pub _bitfield_1 : u32 , pub min_distance : :: std :: os :: raw :: c_int } # [ test ] fn bindgen_test_layout_AVIndexEntry ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVIndexEntry > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( AVIndexEntry ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVIndexEntry > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVIndexEntry ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIndexEntry ) ) . pos as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVIndexEntry ) , "::" , stringify ! ( pos ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIndexEntry ) ) . timestamp as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AVIndexEntry ) , "::" , stringify ! ( timestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVIndexEntry ) ) . min_distance as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( AVIndexEntry ) , "::" , stringify ! ( min_distance ) ) ) ; } impl Clone for AVIndexEntry { fn clone ( & self ) -> Self { * self } } impl AVIndexEntry { # [ inline ] pub fn flags ( & self ) -> :: std :: os :: raw :: c_int { let mask = 3usize as u32 ; let field_val : u32 = unsafe { :: std :: mem :: transmute ( self . _bitfield_1 ) } ; let val = ( field_val & mask ) >> 0usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_flags ( & mut self , val : :: std :: os :: raw :: c_int ) { let mask = 3usize as u32 ; let val = val as u32 as u32 ; let mut field_val : u32 = unsafe { :: std :: mem :: transmute ( self . _bitfield_1 ) } ; field_val &= ! mask ; field_val |= ( val << 0usize ) & mask ; self . _bitfield_1 = unsafe { :: std :: mem :: transmute ( field_val ) } ; } # [ inline ] pub fn size ( & self ) -> :: std :: os :: raw :: c_int { let mask = 4294967292usize as u32 ; let field_val : u32 = unsafe { :: std :: mem :: transmute ( self . _bitfield_1 ) } ; let val = ( field_val & mask ) >> 2usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_size ( & mut self , val : :: std :: os :: raw :: c_int ) { let mask = 4294967292usize as u32 ; let val = val as u32 as u32 ; let mut field_val : u32 = unsafe { :: std :: mem :: transmute ( self . _bitfield_1 ) } ; field_val &= ! mask ; field_val |= ( val << 2usize ) & mask ; self . _bitfield_1 = unsafe { :: std :: mem :: transmute ( field_val ) } ; } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct AVStreamInternal ( [ u8 ; 0 ] ) ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVStream { pub index : :: std :: os :: raw :: c_int , pub id : :: std :: os :: raw :: c_int , pub codec : * mut AVCodecContext , pub priv_data : * mut :: std :: os :: raw :: c_void , pub pts : AVFrac , pub time_base : AVRational , pub start_time : i64 , pub duration : i64 , pub nb_frames : i64 , pub disposition : :: std :: os :: raw :: c_int , pub discard : AVDiscard , pub sample_aspect_ratio : AVRational , pub metadata : * mut AVDictionary , pub avg_frame_rate : AVRational , pub attached_pic : AVPacket , pub side_data : * mut AVPacketSideData , pub nb_side_data : :: std :: os :: raw :: c_int , pub event_flags : :: std :: os :: raw :: c_int , pub info : * mut AVStream__bindgen_ty_1 , pub pts_wrap_bits : :: std :: os :: raw :: c_int , pub first_dts : i64 , pub cur_dts : i64 , pub last_IP_pts : i64 , pub last_IP_duration : :: std :: os :: raw :: c_int , pub probe_packets : :: std :: os :: raw :: c_int , pub codec_info_nb_frames : :: std :: os :: raw :: c_int , pub need_parsing : AVStreamParseType , pub parser : * mut AVCodecParserContext , pub last_in_packet_buffer : * mut AVPacketList , pub probe_data : AVProbeData , pub pts_buffer : [ i64 ; 17usize ] , pub index_entries : * mut AVIndexEntry , pub nb_index_entries : :: std :: os :: raw :: c_int , pub index_entries_allocated_size : :: std :: os :: raw :: c_uint , pub r_frame_rate : AVRational , pub stream_identifier : :: std :: os :: raw :: c_int , pub interleaver_chunk_size : i64 , pub interleaver_chunk_duration : i64 , pub request_probe : :: std :: os :: raw :: c_int , pub skip_to_keyframe : :: std :: os :: raw :: c_int , pub skip_samples : :: std :: os :: raw :: c_int , pub start_skip_samples : i64 , pub first_discard_sample : i64 , pub last_discard_sample : i64 , pub nb_decoded_frames : :: std :: os :: raw :: c_int , pub mux_ts_offset : i64 , pub pts_wrap_reference : i64 , pub pts_wrap_behavior : :: std :: os :: raw :: c_int , pub update_initial_durations_done : :: std :: os :: raw :: c_int , pub pts_reorder_error : [ i64 ; 17usize ] , pub pts_reorder_error_count : [ u8 ; 17usize ] , pub last_dts_for_order_check : i64 , pub dts_ordered : u8 , pub dts_misordered : u8 , pub inject_global_side_data : :: std :: os :: raw :: c_int , pub recommended_encoder_configuration : * mut :: std :: os :: raw :: c_char , pub display_aspect_ratio : AVRational , pub priv_pts : * mut FFFrac , pub internal : * mut AVStreamInternal , pub codecpar : * mut AVCodecParameters } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVStream__bindgen_ty_1 { pub last_dts : i64 , pub duration_gcd : i64 , pub duration_count : :: std :: os :: raw :: c_int , pub rfps_duration_sum : i64 , pub duration_error : * mut [ [ f64 ; 399usize ] ; 2usize ] , pub codec_info_duration : i64 , pub codec_info_duration_fields : i64 , pub found_decoder : :: std :: os :: raw :: c_int , pub last_duration : i64 , pub fps_first_dts : i64 , pub fps_first_dts_idx : :: std :: os :: raw :: c_int , pub fps_last_dts : i64 , pub fps_last_dts_idx : :: std :: os :: raw :: c_int } # [ test ] fn bindgen_test_layout_AVStream__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVStream__bindgen_ty_1 > ( ) , 104usize , concat ! ( "Size of: " , stringify ! ( AVStream__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVStream__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVStream__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream__bindgen_ty_1 ) ) . last_dts as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream__bindgen_ty_1 ) , "::" , stringify ! ( last_dts ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream__bindgen_ty_1 ) ) . duration_gcd as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream__bindgen_ty_1 ) , "::" , stringify ! ( duration_gcd ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream__bindgen_ty_1 ) ) . duration_count as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream__bindgen_ty_1 ) , "::" , stringify ! ( duration_count ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream__bindgen_ty_1 ) ) . rfps_duration_sum as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream__bindgen_ty_1 ) , "::" , stringify ! ( rfps_duration_sum ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream__bindgen_ty_1 ) ) . duration_error as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream__bindgen_ty_1 ) , "::" , stringify ! ( duration_error ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream__bindgen_ty_1 ) ) . codec_info_duration as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream__bindgen_ty_1 ) , "::" , stringify ! ( codec_info_duration ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream__bindgen_ty_1 ) ) . codec_info_duration_fields as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream__bindgen_ty_1 ) , "::" , stringify ! ( codec_info_duration_fields ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream__bindgen_ty_1 ) ) . found_decoder as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream__bindgen_ty_1 ) , "::" , stringify ! ( found_decoder ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream__bindgen_ty_1 ) ) . last_duration as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream__bindgen_ty_1 ) , "::" , stringify ! ( last_duration ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream__bindgen_ty_1 ) ) . fps_first_dts as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream__bindgen_ty_1 ) , "::" , stringify ! ( fps_first_dts ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream__bindgen_ty_1 ) ) . fps_first_dts_idx as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream__bindgen_ty_1 ) , "::" , stringify ! ( fps_first_dts_idx ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream__bindgen_ty_1 ) ) . fps_last_dts as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream__bindgen_ty_1 ) , "::" , stringify ! ( fps_last_dts ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream__bindgen_ty_1 ) ) . fps_last_dts_idx as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream__bindgen_ty_1 ) , "::" , stringify ! ( fps_last_dts_idx ) ) ) ; } impl Clone for AVStream__bindgen_ty_1 { fn clone ( & self ) -> Self { * self } } # [ test ] fn bindgen_test_layout_AVStream ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVStream > ( ) , 792usize , concat ! ( "Size of: " , stringify ! ( AVStream ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVStream > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVStream ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . index as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( index ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . id as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( id ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . codec as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( codec ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . priv_data as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( priv_data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . pts as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( pts ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . time_base as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( time_base ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . start_time as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( start_time ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . duration as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( duration ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . nb_frames as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( nb_frames ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . disposition as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( disposition ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . discard as * const _ as usize } , 84usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( discard ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . sample_aspect_ratio as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( sample_aspect_ratio ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . metadata as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( metadata ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . avg_frame_rate as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( avg_frame_rate ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . attached_pic as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( attached_pic ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . side_data as * const _ as usize } , 200usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( side_data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . nb_side_data as * const _ as usize } , 208usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( nb_side_data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . event_flags as * const _ as usize } , 212usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( event_flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . info as * const _ as usize } , 216usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( info ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . pts_wrap_bits as * const _ as usize } , 224usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( pts_wrap_bits ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . first_dts as * const _ as usize } , 232usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( first_dts ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . cur_dts as * const _ as usize } , 240usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( cur_dts ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . last_IP_pts as * const _ as usize } , 248usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( last_IP_pts ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . last_IP_duration as * const _ as usize } , 256usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( last_IP_duration ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . probe_packets as * const _ as usize } , 260usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( probe_packets ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . codec_info_nb_frames as * const _ as usize } , 264usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( codec_info_nb_frames ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . need_parsing as * const _ as usize } , 268usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( need_parsing ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . parser as * const _ as usize } , 272usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( parser ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . last_in_packet_buffer as * const _ as usize } , 280usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( last_in_packet_buffer ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . probe_data as * const _ as usize } , 288usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( probe_data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . pts_buffer as * const _ as usize } , 320usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( pts_buffer ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . index_entries as * const _ as usize } , 456usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( index_entries ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . nb_index_entries as * const _ as usize } , 464usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( nb_index_entries ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . index_entries_allocated_size as * const _ as usize } , 468usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( index_entries_allocated_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . r_frame_rate as * const _ as usize } , 472usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( r_frame_rate ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . stream_identifier as * const _ as usize } , 480usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( stream_identifier ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . interleaver_chunk_size as * const _ as usize } , 488usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( interleaver_chunk_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . interleaver_chunk_duration as * const _ as usize } , 496usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( interleaver_chunk_duration ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . request_probe as * const _ as usize } , 504usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( request_probe ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . skip_to_keyframe as * const _ as usize } , 508usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( skip_to_keyframe ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . skip_samples as * const _ as usize } , 512usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( skip_samples ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . start_skip_samples as * const _ as usize } , 520usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( start_skip_samples ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . first_discard_sample as * const _ as usize } , 528usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( first_discard_sample ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . last_discard_sample as * const _ as usize } , 536usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( last_discard_sample ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . nb_decoded_frames as * const _ as usize } , 544usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( nb_decoded_frames ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . mux_ts_offset as * const _ as usize } , 552usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( mux_ts_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . pts_wrap_reference as * const _ as usize } , 560usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( pts_wrap_reference ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . pts_wrap_behavior as * const _ as usize } , 568usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( pts_wrap_behavior ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . update_initial_durations_done as * const _ as usize } , 572usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( update_initial_durations_done ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . pts_reorder_error as * const _ as usize } , 576usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( pts_reorder_error ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . pts_reorder_error_count as * const _ as usize } , 712usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( pts_reorder_error_count ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . last_dts_for_order_check as * const _ as usize } , 736usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( last_dts_for_order_check ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . dts_ordered as * const _ as usize } , 744usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( dts_ordered ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . dts_misordered as * const _ as usize } , 745usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( dts_misordered ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . inject_global_side_data as * const _ as usize } , 748usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( inject_global_side_data ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . recommended_encoder_configuration as * const _ as usize } , 752usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( recommended_encoder_configuration ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . display_aspect_ratio as * const _ as usize } , 760usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( display_aspect_ratio ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . priv_pts as * const _ as usize } , 768usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( priv_pts ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . internal as * const _ as usize } , 776usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( internal ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVStream ) ) . codecpar as * const _ as usize } , 784usize , concat ! ( "Alignment of field: " , stringify ! ( AVStream ) , "::" , stringify ! ( codecpar ) ) ) ; } impl Clone for AVStream { fn clone ( & self ) -> Self { * self } } extern "C" { pub fn av_stream_get_r_frame_rate ( s : * const AVStream ) -> AVRational ; } extern "C" { pub fn av_stream_set_r_frame_rate ( s : * mut AVStream , r : AVRational ) ; } extern "C" { pub fn av_stream_get_parser ( s : * const AVStream ) -> * mut AVCodecParserContext ; } extern "C" { pub fn av_stream_get_recommended_encoder_configuration ( s : * const AVStream ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn av_stream_set_recommended_encoder_configuration ( s : * mut AVStream , configuration : * mut :: std :: os :: raw :: c_char ) ; } extern "C" { pub fn av_stream_get_end_pts ( st : * const AVStream ) -> i64 ; } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVProgram { pub id : :: std :: os :: raw :: c_int , pub flags : :: std :: os :: raw :: c_int , pub discard : AVDiscard , pub stream_index : * mut :: std :: os :: raw :: c_uint , pub nb_stream_indexes : :: std :: os :: raw :: c_uint , pub metadata : * mut AVDictionary , pub program_num : :: std :: os :: raw :: c_int , pub pmt_pid : :: std :: os :: raw :: c_int , pub pcr_pid : :: std :: os :: raw :: c_int , pub start_time : i64 , pub end_time : i64 , pub pts_wrap_reference : i64 , pub pts_wrap_behavior : :: std :: os :: raw :: c_int } # [ test ] fn bindgen_test_layout_AVProgram ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVProgram > ( ) , 88usize , concat ! ( "Size of: " , stringify ! ( AVProgram ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVProgram > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVProgram ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVProgram ) ) . id as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVProgram ) , "::" , stringify ! ( id ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVProgram ) ) . flags as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( AVProgram ) , "::" , stringify ! ( flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVProgram ) ) . discard as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( AVProgram ) , "::" , stringify ! ( discard ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVProgram ) ) . stream_index as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( AVProgram ) , "::" , stringify ! ( stream_index ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVProgram ) ) . nb_stream_indexes as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( AVProgram ) , "::" , stringify ! ( nb_stream_indexes ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVProgram ) ) . metadata as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( AVProgram ) , "::" , stringify ! ( metadata ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVProgram ) ) . program_num as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( AVProgram ) , "::" , stringify ! ( program_num ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVProgram ) ) . pmt_pid as * const _ as usize } , 44usize , concat ! ( "Alignment of field: " , stringify ! ( AVProgram ) , "::" , stringify ! ( pmt_pid ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVProgram ) ) . pcr_pid as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( AVProgram ) , "::" , stringify ! ( pcr_pid ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVProgram ) ) . start_time as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( AVProgram ) , "::" , stringify ! ( start_time ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVProgram ) ) . end_time as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( AVProgram ) , "::" , stringify ! ( end_time ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVProgram ) ) . pts_wrap_reference as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( AVProgram ) , "::" , stringify ! ( pts_wrap_reference ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVProgram ) ) . pts_wrap_behavior as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( AVProgram ) , "::" , stringify ! ( pts_wrap_behavior ) ) ) ; } impl Clone for AVProgram { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVChapter { pub id : :: std :: os :: raw :: c_int , pub time_base : AVRational , pub start : i64 , pub end : i64 , pub metadata : * mut AVDictionary } # [ test ] fn bindgen_test_layout_AVChapter ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVChapter > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( AVChapter ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVChapter > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVChapter ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVChapter ) ) . id as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVChapter ) , "::" , stringify ! ( id ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVChapter ) ) . time_base as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( AVChapter ) , "::" , stringify ! ( time_base ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVChapter ) ) . start as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( AVChapter ) , "::" , stringify ! ( start ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVChapter ) ) . end as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( AVChapter ) , "::" , stringify ! ( end ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVChapter ) ) . metadata as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( AVChapter ) , "::" , stringify ! ( metadata ) ) ) ; } impl Clone for AVChapter { fn clone ( & self ) -> Self { * self } } pub type av_format_control_message = :: std :: option :: Option < unsafe extern "C" fn ( s : * mut AVFormatContext , type_ : :: std :: os :: raw :: c_int , data : * mut :: std :: os :: raw :: c_void , data_size : usize ) -> :: std :: os :: raw :: c_int > ; pub type AVOpenCallback = :: std :: option :: Option < unsafe extern "C" fn ( s : * mut AVFormatContext , pb : * mut * mut AVIOContext , url : * const :: std :: os :: raw :: c_char , flags : :: std :: os :: raw :: c_int , int_cb : * const AVIOInterruptCB , options : * mut * mut AVDictionary ) -> :: std :: os :: raw :: c_int > ; # [ repr ( u32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum AVDurationEstimationMethod { AVFMT_DURATION_FROM_PTS = 0 , AVFMT_DURATION_FROM_STREAM = 1 , AVFMT_DURATION_FROM_BITRATE = 2 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct AVFormatInternal ( [ u8 ; 0 ] ) ; extern "C" { pub fn av_format_get_probe_score ( s : * const AVFormatContext ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_format_get_video_codec ( s : * const AVFormatContext ) -> * mut AVCodec ; } extern "C" { pub fn av_format_set_video_codec ( s : * mut AVFormatContext , c : * mut AVCodec ) ; } extern "C" { pub fn av_format_get_audio_codec ( s : * const AVFormatContext ) -> * mut AVCodec ; } extern "C" { pub fn av_format_set_audio_codec ( s : * mut AVFormatContext , c : * mut AVCodec ) ; } extern "C" { pub fn av_format_get_subtitle_codec ( s : * const AVFormatContext ) -> * mut AVCodec ; } extern "C" { pub fn av_format_set_subtitle_codec ( s : * mut AVFormatContext , c : * mut AVCodec ) ; } extern "C" { pub fn av_format_get_data_codec ( s : * const AVFormatContext ) -> * mut AVCodec ; } extern "C" { pub fn av_format_set_data_codec ( s : * mut AVFormatContext , c : * mut AVCodec ) ; } extern "C" { pub fn av_format_get_metadata_header_padding ( s : * const AVFormatContext ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_format_set_metadata_header_padding ( s : * mut AVFormatContext , c : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn av_format_get_opaque ( s : * const AVFormatContext ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn av_format_set_opaque ( s : * mut AVFormatContext , opaque : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { pub fn av_format_get_control_message_cb ( s : * const AVFormatContext ) -> av_format_control_message ; } extern "C" { pub fn av_format_set_control_message_cb ( s : * mut AVFormatContext , callback : av_format_control_message ) ; } extern "C" { pub fn av_format_get_open_cb ( s : * const AVFormatContext ) -> AVOpenCallback ; } extern "C" { pub fn av_format_set_open_cb ( s : * mut AVFormatContext , callback : AVOpenCallback ) ; } extern "C" { pub fn av_format_inject_global_side_data ( s : * mut AVFormatContext ) ; } extern "C" { pub fn av_fmt_ctx_get_duration_estimation_method ( ctx : * const AVFormatContext ) -> AVDurationEstimationMethod ; } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVPacketList { pub pkt : AVPacket , pub next : * mut AVPacketList } # [ test ] fn bindgen_test_layout_AVPacketList ( ) { assert_eq ! ( :: std :: mem :: size_of :: < AVPacketList > ( ) , 96usize , concat ! ( "Size of: " , stringify ! ( AVPacketList ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < AVPacketList > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( AVPacketList ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVPacketList ) ) . pkt as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( AVPacketList ) , "::" , stringify ! ( pkt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const AVPacketList ) ) . next as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( AVPacketList ) , "::" , stringify ! ( next ) ) ) ; } impl Clone for AVPacketList { fn clone ( & self ) -> Self { * self } } extern "C" { pub fn avformat_version ( ) -> :: std :: os :: raw :: c_uint ; } extern "C" { pub fn avformat_configuration ( ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn avformat_license ( ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn av_register_all ( ) ; } extern "C" { pub fn av_register_input_format ( format : * mut AVInputFormat ) ; } extern "C" { pub fn av_register_output_format ( format : * mut AVOutputFormat ) ; } extern "C" { pub fn avformat_network_init ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avformat_network_deinit ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_iformat_next ( f : * const AVInputFormat ) -> * mut AVInputFormat ; } extern "C" { pub fn av_oformat_next ( f : * const AVOutputFormat ) -> * mut AVOutputFormat ; } extern "C" { pub fn avformat_alloc_context ( ) -> * mut AVFormatContext ; } extern "C" { pub fn avformat_free_context ( s : * mut AVFormatContext ) ; } extern "C" { pub fn avformat_get_class ( ) -> * const AVClass ; } extern "C" { pub fn avformat_new_stream ( s : * mut AVFormatContext , c : * const AVCodec ) -> * mut AVStream ; } extern "C" { pub fn av_stream_add_side_data ( st : * mut AVStream , type_ : AVPacketSideDataType , data : * mut u8 , size : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_stream_new_side_data ( stream : * mut AVStream , type_ : AVPacketSideDataType , size : :: std :: os :: raw :: c_int ) -> * mut u8 ; } extern "C" { pub fn av_stream_get_side_data ( stream : * mut AVStream , type_ : AVPacketSideDataType , size : * mut :: std :: os :: raw :: c_int ) -> * mut u8 ; } extern "C" { pub fn av_new_program ( s : * mut AVFormatContext , id : :: std :: os :: raw :: c_int ) -> * mut AVProgram ; } extern "C" { pub fn avformat_alloc_output_context2 ( ctx : * mut * mut AVFormatContext , oformat : * mut AVOutputFormat , format_name : * const :: std :: os :: raw :: c_char , filename : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_find_input_format ( short_name : * const :: std :: os :: raw :: c_char ) -> * mut AVInputFormat ; } extern "C" { pub fn av_probe_input_format ( pd : * mut AVProbeData , is_opened : :: std :: os :: raw :: c_int ) -> * mut AVInputFormat ; } extern "C" { pub fn av_probe_input_format2 ( pd : * mut AVProbeData , is_opened : :: std :: os :: raw :: c_int , score_max : * mut :: std :: os :: raw :: c_int ) -> * mut AVInputFormat ; } extern "C" { pub fn av_probe_input_format3 ( pd : * mut AVProbeData , is_opened : :: std :: os :: raw :: c_int , score_ret : * mut :: std :: os :: raw :: c_int ) -> * mut AVInputFormat ; } extern "C" { pub fn av_probe_input_buffer2 ( pb : * mut AVIOContext , fmt : * mut * mut AVInputFormat , url : * const :: std :: os :: raw :: c_char , logctx : * mut :: std :: os :: raw :: c_void , offset : :: std :: os :: raw :: c_uint , max_probe_size : :: std :: os :: raw :: c_uint ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_probe_input_buffer ( pb : * mut AVIOContext , fmt : * mut * mut AVInputFormat , url : * const :: std :: os :: raw :: c_char , logctx : * mut :: std :: os :: raw :: c_void , offset : :: std :: os :: raw :: c_uint , max_probe_size : :: std :: os :: raw :: c_uint ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avformat_open_input ( ps : * mut * mut AVFormatContext , url : * const :: std :: os :: raw :: c_char , fmt : * mut AVInputFormat , options : * mut * mut AVDictionary ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_demuxer_open ( ic : * mut AVFormatContext ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avformat_find_stream_info ( ic : * mut AVFormatContext , options : * mut * mut AVDictionary ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_find_program_from_stream ( ic : * mut AVFormatContext , last : * mut AVProgram , s : :: std :: os :: raw :: c_int ) -> * mut AVProgram ; } extern "C" { pub fn av_program_add_stream_index ( ac : * mut AVFormatContext , progid : :: std :: os :: raw :: c_int , idx : :: std :: os :: raw :: c_uint ) ; } extern "C" { pub fn av_find_best_stream ( ic : * mut AVFormatContext , type_ : AVMediaType , wanted_stream_nb : :: std :: os :: raw :: c_int , related_stream : :: std :: os :: raw :: c_int , decoder_ret : * mut * mut AVCodec , flags : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_read_frame ( s : * mut AVFormatContext , pkt : * mut AVPacket ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_seek_frame ( s : * mut AVFormatContext , stream_index : :: std :: os :: raw :: c_int , timestamp : i64 , flags : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avformat_seek_file ( s : * mut AVFormatContext , stream_index : :: std :: os :: raw :: c_int , min_ts : i64 , ts : i64 , max_ts : i64 , flags : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avformat_flush ( s : * mut AVFormatContext ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_read_play ( s : * mut AVFormatContext ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_read_pause ( s : * mut AVFormatContext ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avformat_close_input ( s : * mut * mut AVFormatContext ) ; } extern "C" { pub fn avformat_write_header ( s : * mut AVFormatContext , options : * mut * mut AVDictionary ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avformat_init_output ( s : * mut AVFormatContext , options : * mut * mut AVDictionary ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_write_frame ( s : * mut AVFormatContext , pkt : * mut AVPacket ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_interleaved_write_frame ( s : * mut AVFormatContext , pkt : * mut AVPacket ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_write_uncoded_frame ( s : * mut AVFormatContext , stream_index : :: std :: os :: raw :: c_int , frame : * mut AVFrame ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_interleaved_write_uncoded_frame ( s : * mut AVFormatContext , stream_index : :: std :: os :: raw :: c_int , frame : * mut AVFrame ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_write_uncoded_frame_query ( s : * mut AVFormatContext , stream_index : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_write_trailer ( s : * mut AVFormatContext ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_guess_format ( short_name : * const :: std :: os :: raw :: c_char , filename : * const :: std :: os :: raw :: c_char , mime_type : * const :: std :: os :: raw :: c_char ) -> * mut AVOutputFormat ; } extern "C" { pub fn av_guess_codec ( fmt : * mut AVOutputFormat , short_name : * const :: std :: os :: raw :: c_char , filename : * const :: std :: os :: raw :: c_char , mime_type : * const :: std :: os :: raw :: c_char , type_ : AVMediaType ) -> AVCodecID ; } extern "C" { pub fn av_get_output_timestamp ( s : * mut AVFormatContext , stream : :: std :: os :: raw :: c_int , dts : * mut i64 , wall : * mut i64 ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_hex_dump ( f : * mut FILE , buf : * const u8 , size : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn av_hex_dump_log ( avcl : * mut :: std :: os :: raw :: c_void , level : :: std :: os :: raw :: c_int , buf : * const u8 , size : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn av_pkt_dump2 ( f : * mut FILE , pkt : * const AVPacket , dump_payload : :: std :: os :: raw :: c_int , st : * const AVStream ) ; } extern "C" { pub fn av_pkt_dump_log2 ( avcl : * mut :: std :: os :: raw :: c_void , level : :: std :: os :: raw :: c_int , pkt : * const AVPacket , dump_payload : :: std :: os :: raw :: c_int , st : * const AVStream ) ; } extern "C" { pub fn av_codec_get_id ( tags : * const * const AVCodecTag , tag : :: std :: os :: raw :: c_uint ) -> AVCodecID ; } extern "C" { pub fn av_codec_get_tag ( tags : * const * const AVCodecTag , id : AVCodecID ) -> :: std :: os :: raw :: c_uint ; } extern "C" { pub fn av_codec_get_tag2 ( tags : * const * const AVCodecTag , id : AVCodecID , tag : * mut :: std :: os :: raw :: c_uint ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_find_default_stream_index ( s : * mut AVFormatContext ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_index_search_timestamp ( st : * mut AVStream , timestamp : i64 , flags : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_add_index_entry ( st : * mut AVStream , pos : i64 , timestamp : i64 , size : :: std :: os :: raw :: c_int , distance : :: std :: os :: raw :: c_int , flags : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_url_split ( proto : * mut :: std :: os :: raw :: c_char , proto_size : :: std :: os :: raw :: c_int , authorization : * mut :: std :: os :: raw :: c_char , authorization_size : :: std :: os :: raw :: c_int , hostname : * mut :: std :: os :: raw :: c_char , hostname_size : :: std :: os :: raw :: c_int , port_ptr : * mut :: std :: os :: raw :: c_int , path : * mut :: std :: os :: raw :: c_char , path_size : :: std :: os :: raw :: c_int , url : * const :: std :: os :: raw :: c_char ) ; } extern "C" { pub fn av_dump_format ( ic : * mut AVFormatContext , index : :: std :: os :: raw :: c_int , url : * const :: std :: os :: raw :: c_char , is_output : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn av_get_frame_filename2 ( buf : * mut :: std :: os :: raw :: c_char , buf_size : :: std :: os :: raw :: c_int , path : * const :: std :: os :: raw :: c_char , number : :: std :: os :: raw :: c_int , flags : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_get_frame_filename ( buf : * mut :: std :: os :: raw :: c_char , buf_size : :: std :: os :: raw :: c_int , path : * const :: std :: os :: raw :: c_char , number : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_filename_number_test ( filename : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_sdp_create ( ac : * mut * mut AVFormatContext , n_files : :: std :: os :: raw :: c_int , buf : * mut :: std :: os :: raw :: c_char , size : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_match_ext ( filename : * const :: std :: os :: raw :: c_char , extensions : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avformat_query_codec ( ofmt : * const AVOutputFormat , codec_id : AVCodecID , std_compliance : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avformat_get_riff_video_tags ( ) -> * const AVCodecTag ; } extern "C" { pub fn avformat_get_riff_audio_tags ( ) -> * const AVCodecTag ; } extern "C" { pub fn avformat_get_mov_video_tags ( ) -> * const AVCodecTag ; } extern "C" { pub fn avformat_get_mov_audio_tags ( ) -> * const AVCodecTag ; } extern "C" { pub fn av_guess_sample_aspect_ratio ( format : * mut AVFormatContext , stream : * mut AVStream , frame : * mut AVFrame ) -> AVRational ; } extern "C" { pub fn av_guess_frame_rate ( ctx : * mut AVFormatContext , stream : * mut AVStream , frame : * mut AVFrame ) -> AVRational ; } extern "C" { pub fn avformat_match_stream_specifier ( s : * mut AVFormatContext , st : * mut AVStream , spec : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn avformat_queue_attached_pictures ( s : * mut AVFormatContext ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_apply_bitstream_filters ( codec : * mut AVCodecContext , pkt : * mut AVPacket , bsfc : * mut AVBitStreamFilterContext ) -> :: std :: os :: raw :: c_int ; } # [ repr ( i32 ) ] # [ derive ( Debug , Copy , Clone , PartialEq , Eq , Hash ) ] pub enum AVTimebaseSource { AVFMT_TBCF_AUTO = - 1 , AVFMT_TBCF_DECODER = 0 , AVFMT_TBCF_DEMUXER = 1 , AVFMT_TBCF_R_FRAMERATE = 2 , } extern "C" { pub fn avformat_transfer_internal_stream_timing_info ( ofmt : * const AVOutputFormat , ost : * mut AVStream , ist : * const AVStream , copy_tb : AVTimebaseSource ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn av_stream_get_codec_timebase ( st : * const AVStream ) -> AVRational ; } extern "C" { pub fn swscale_version ( ) -> :: std :: os :: raw :: c_uint ; } extern "C" { pub fn swscale_configuration ( ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn swscale_license ( ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn sws_getCoefficients ( colorspace : :: std :: os :: raw :: c_int ) -> * const :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct SwsVector { pub coeff : * mut f64 , pub length : :: std :: os :: raw :: c_int } # [ test ] fn bindgen_test_layout_SwsVector ( ) { assert_eq ! ( :: std :: mem :: size_of :: < SwsVector > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( SwsVector ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < SwsVector > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SwsVector ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const SwsVector ) ) . coeff as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( SwsVector ) , "::" , stringify ! ( coeff ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const SwsVector ) ) . length as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( SwsVector ) , "::" , stringify ! ( length ) ) ) ; } impl Clone for SwsVector { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct SwsFilter { pub lumH : * mut SwsVector , pub lumV : * mut SwsVector , pub chrH : * mut SwsVector , pub chrV : * mut SwsVector } # [ test ] fn bindgen_test_layout_SwsFilter ( ) { assert_eq ! ( :: std :: mem :: size_of :: < SwsFilter > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( SwsFilter ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < SwsFilter > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SwsFilter ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const SwsFilter ) ) . lumH as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( SwsFilter ) , "::" , stringify ! ( lumH ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const SwsFilter ) ) . lumV as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( SwsFilter ) , "::" , stringify ! ( lumV ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const SwsFilter ) ) . chrH as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( SwsFilter ) , "::" , stringify ! ( chrH ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const SwsFilter ) ) . chrV as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( SwsFilter ) , "::" , stringify ! ( chrV ) ) ) ; } impl Clone for SwsFilter { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SwsContext ( [ u8 ; 0 ] ) ; extern "C" { pub fn sws_isSupportedInput ( pix_fmt : AVPixelFormat ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn sws_isSupportedOutput ( pix_fmt : AVPixelFormat ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn sws_isSupportedEndiannessConversion ( pix_fmt : AVPixelFormat ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn sws_alloc_context ( ) -> * mut SwsContext ; } extern "C" { pub fn sws_init_context ( sws_context : * mut SwsContext , srcFilter : * mut SwsFilter , dstFilter : * mut SwsFilter ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn sws_freeContext ( swsContext : * mut SwsContext ) ; } extern "C" { pub fn sws_getContext ( srcW : :: std :: os :: raw :: c_int , srcH : :: std :: os :: raw :: c_int , srcFormat : AVPixelFormat , dstW : :: std :: os :: raw :: c_int , dstH : :: std :: os :: raw :: c_int , dstFormat : AVPixelFormat , flags : :: std :: os :: raw :: c_int , srcFilter : * mut SwsFilter , dstFilter : * mut SwsFilter , param : * const f64 ) -> * mut SwsContext ; } extern "C" { pub fn sws_scale ( c : * mut SwsContext , srcSlice : * const * const u8 , srcStride : * const :: std :: os :: raw :: c_int , srcSliceY : :: std :: os :: raw :: c_int , srcSliceH : :: std :: os :: raw :: c_int , dst : * const * const u8 , dstStride : * const :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn sws_setColorspaceDetails ( c : * mut SwsContext , inv_table : * const :: std :: os :: raw :: c_int , srcRange : :: std :: os :: raw :: c_int , table : * const :: std :: os :: raw :: c_int , dstRange : :: std :: os :: raw :: c_int , brightness : :: std :: os :: raw :: c_int , contrast : :: std :: os :: raw :: c_int , saturation : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn sws_getColorspaceDetails ( c : * mut SwsContext , inv_table : * mut * mut :: std :: os :: raw :: c_int , srcRange : * mut :: std :: os :: raw :: c_int , table : * mut * mut :: std :: os :: raw :: c_int , dstRange : * mut :: std :: os :: raw :: c_int , brightness : * mut :: std :: os :: raw :: c_int , contrast : * mut :: std :: os :: raw :: c_int , saturation : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn sws_allocVec ( length : :: std :: os :: raw :: c_int ) -> * mut SwsVector ; } extern "C" { pub fn sws_getGaussianVec ( variance : f64 , quality : f64 ) -> * mut SwsVector ; } extern "C" { pub fn sws_scaleVec ( a : * mut SwsVector , scalar : f64 ) ; } extern "C" { pub fn sws_normalizeVec ( a : * mut SwsVector , height : f64 ) ; } extern "C" { pub fn sws_getConstVec ( c : f64 , length : :: std :: os :: raw :: c_int ) -> * mut SwsVector ; } extern "C" { pub fn sws_getIdentityVec ( ) -> * mut SwsVector ; } extern "C" { pub fn sws_convVec ( a : * mut SwsVector , b : * mut SwsVector ) ; } extern "C" { pub fn sws_addVec ( a : * mut SwsVector , b : * mut SwsVector ) ; } extern "C" { pub fn sws_subVec ( a : * mut SwsVector , b : * mut SwsVector ) ; } extern "C" { pub fn sws_shiftVec ( a : * mut SwsVector , shift : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn sws_cloneVec ( a : * mut SwsVector ) -> * mut SwsVector ; } extern "C" { pub fn sws_printVec2 ( a : * mut SwsVector , log_ctx : * mut AVClass , log_level : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn sws_freeVec ( a : * mut SwsVector ) ; } extern "C" { pub fn sws_getDefaultFilter ( lumaGBlur : f32 , chromaGBlur : f32 , lumaSharpen : f32 , chromaSharpen : f32 , chromaHShift : f32 , chromaVShift : f32 , verbose : :: std :: os :: raw :: c_int ) -> * mut SwsFilter ; } extern "C" { pub fn sws_freeFilter ( filter : * mut SwsFilter ) ; } extern "C" { pub fn sws_getCachedContext ( context : * mut SwsContext , srcW : :: std :: os :: raw :: c_int , srcH : :: std :: os :: raw :: c_int , srcFormat : AVPixelFormat , dstW : :: std :: os :: raw :: c_int , dstH : :: std :: os :: raw :: c_int , dstFormat : AVPixelFormat , flags : :: std :: os :: raw :: c_int , srcFilter : * mut SwsFilter , dstFilter : * mut SwsFilter , param : * const f64 ) -> * mut SwsContext ; } extern "C" { pub fn sws_convertPalette8ToPacked32 ( src : * const u8 , dst : * mut u8 , num_pixels : :: std :: os :: raw :: c_int , palette : * const u8 ) ; } extern "C" { pub fn sws_convertPalette8ToPacked24 ( src : * const u8 , dst : * mut u8 , num_pixels : :: std :: os :: raw :: c_int , palette : * const u8 ) ; } extern "C" { pub fn sws_get_class ( ) -> * const AVClass ; } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct __va_list_tag { pub gp_offset : :: std :: os :: raw :: c_uint , pub fp_offset : :: std :: os :: raw :: c_uint , pub overflow_arg_area : * mut :: std :: os :: raw :: c_void , pub reg_save_area : * mut :: std :: os :: raw :: c_void } # [ test ] fn bindgen_test_layout___va_list_tag ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __va_list_tag > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( __va_list_tag ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __va_list_tag > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __va_list_tag ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( gp_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( fp_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( overflow_arg_area ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( reg_save_area ) ) ) ; } impl Clone for __va_list_tag { fn clone ( & self ) -> Self { * self } } pub type __builtin_va_list = [ __va_list_tag ; 1usize ] ; # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct __locale_data { pub _address : u8 } impl Clone for __locale_data { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct AVOption { pub _address : u8 } impl Clone for AVOption { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct URLContext { pub _address : u8 } impl Clone for URLContext { fn clone ( & self ) -> Self { * self } } # [ repr ( C ) ] # [ derive ( Debug , Copy ) ] pub struct FFFrac { pub _address : u8 } impl Clone for FFFrac { fn clone ( & self ) -> Self { * self } } pub const NOPTS_VALUE : i64 = - 9223372036854775808 ; pub const AVERROR_EAGAIN : :: std :: os :: raw :: c_int = - 11 ; pub const AVERROR_EOF : :: std :: os :: raw :: c_int = - 541478725 ;